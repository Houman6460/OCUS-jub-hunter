var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except2, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except2)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// lib/settings-storage.ts
var settings_storage_exports = {};
__export(settings_storage_exports, {
  SettingsStorage: () => SettingsStorage
});
var SettingsStorage;
var init_settings_storage = __esm({
  "lib/settings-storage.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    SettingsStorage = class {
      static {
        __name(this, "SettingsStorage");
      }
      db;
      constructor(database) {
        this.db = database;
      }
      async initializeSettings() {
        try {
          const result = await this.db.prepare(`
        CREATE TABLE IF NOT EXISTS settings (
          key TEXT PRIMARY KEY,
          value TEXT NOT NULL,
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
      `).run();
          console.log("Settings table initialized:", result);
        } catch (error) {
          console.error("Failed to initialize settings table:", error);
          throw error;
        }
      }
      async getSetting(key) {
        try {
          const result = await this.db.prepare(
            "SELECT value FROM settings WHERE key = ?"
          ).bind(key).first();
          return result ? result.value : null;
        } catch (error) {
          console.error("Failed to get setting:", error);
          return null;
        }
      }
      async setSetting(key, value) {
        try {
          console.log(`Setting ${key} with value length:`, value.length);
          const result = await this.db.prepare(
            "INSERT OR REPLACE INTO settings (key, value, updated_at) VALUES (?, ?, CURRENT_TIMESTAMP)"
          ).bind(key, value).run();
          console.log(`Successfully set ${key}, result:`, result);
        } catch (error) {
          console.error(`Failed to set setting ${key}:`, error);
          throw error;
        }
      }
      async getChatSettings() {
        try {
          const openaiApiKey = await this.getSetting("openai_api_key");
          const assistantId = await this.getSetting("openai_assistant_id");
          const chatModel = await this.getSetting("chat_model") || "gpt-4o-mini";
          const enabled = await this.getSetting("chat_enabled") || "true";
          return {
            openaiApiKey: openaiApiKey ? "***hidden***" : "",
            assistantId: assistantId || "",
            chatModel,
            enabled: enabled === "true"
          };
        } catch (error) {
          console.error("Failed to get chat settings:", error);
          return {
            openaiApiKey: "",
            assistantId: "",
            chatModel: "gpt-4o-mini",
            enabled: true
          };
        }
      }
      async setChatSettings(settings3) {
        try {
          if (settings3.openaiApiKey && settings3.openaiApiKey !== "***hidden***") {
            await this.setSetting("openai_api_key", settings3.openaiApiKey);
          }
          if (settings3.assistantId !== void 0) {
            await this.setSetting("openai_assistant_id", settings3.assistantId || "");
          }
          if (settings3.chatModel) {
            await this.setSetting("chat_model", settings3.chatModel);
          }
          if (settings3.enabled !== void 0) {
            await this.setSetting("chat_enabled", settings3.enabled.toString());
          }
        } catch (error) {
          console.error("Failed to set chat settings:", error);
          console.error("Settings object:", settings3);
          const message = error instanceof Error ? error.message : String(error);
          throw new Error(`Settings storage error: ${message}`);
        }
      }
      async getOpenAIApiKey() {
        return await this.getSetting("openai_api_key");
      }
    };
  }
});

// lib/translation-service.ts
var TranslationService;
var init_translation_service = __esm({
  "lib/translation-service.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    TranslationService = class {
      static {
        __name(this, "TranslationService");
      }
      static supportedLanguages = {
        en: "English",
        de: "German",
        fr: "French",
        es: "Spanish",
        it: "Italian",
        pt: "Portuguese",
        nl: "Dutch",
        da: "Danish",
        no: "Norwegian",
        fi: "Finnish",
        tr: "Turkish",
        pl: "Polish",
        ru: "Russian"
      };
      static async translateBadgeText(text2, targetLanguages, openaiApiKey) {
        if (!openaiApiKey) {
          console.warn("OpenAI API key not provided - returning empty translation map");
          return {};
        }
        const validLanguages = targetLanguages.filter(
          (lang) => lang in this.supportedLanguages && lang !== "en"
        );
        if (validLanguages.length === 0) {
          return {};
        }
        const languageNames = validLanguages.map(
          (code) => `${code}: ${this.supportedLanguages[code]}`
        ).join(", ");
        const prompt = `Translate the following announcement badge text into multiple languages.

Original text (English): "${text2}"
Context: Announcement badge for a Chrome extension product website
Target languages: ${languageNames}
Tone: Marketing/promotional tone

Requirements:
- Maintain the marketing/promotional tone
- Keep the same emotional impact as the original
- Adapt cultural nuances appropriately for each target market
- Keep translations concise and impactful for badge display
- Ensure translations sound natural to native speakers

Respond with a JSON object where keys are language codes (${validLanguages.join(", ")}) and values are the translated text.

Example format:
{
  "de": "German translation here",
  "fr": "French translation here"
}`;
        try {
          const response = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${openaiApiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              model: "gpt-4o",
              messages: [
                {
                  role: "system",
                  content: "You are a professional translator specializing in marketing and e-commerce content. Provide accurate, culturally appropriate translations that maintain the marketing impact of the original text."
                },
                {
                  role: "user",
                  content: prompt
                }
              ],
              response_format: { type: "json_object" },
              temperature: 0.3,
              max_tokens: 1e3
            })
          });
          if (!response.ok) {
            throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
          }
          const data = await response.json();
          const translationText = data.choices[0]?.message?.content;
          if (!translationText) {
            throw new Error("No translation received from OpenAI");
          }
          const translations = JSON.parse(translationText);
          const result = {};
          for (const lang of validLanguages) {
            if (translations[lang] && typeof translations[lang] === "string") {
              result[lang] = translations[lang].trim();
            }
          }
          return result;
        } catch (error) {
          console.error("Translation service error:", error);
          throw new Error(`Translation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      static getSupportedLanguages() {
        return this.supportedLanguages;
      }
    };
  }
});

// api/admin/announcement-badges/translate.ts
var onRequestOptions, onRequestPost;
var init_translate = __esm({
  "api/admin/announcement-badges/translate.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_settings_storage();
    init_translation_service();
    onRequestOptions = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
    onRequestPost = /* @__PURE__ */ __name(async (context) => {
      try {
        const requestData = await context.request.json();
        const { textEn, targetLanguages } = requestData;
        if (!textEn || !targetLanguages || !Array.isArray(targetLanguages)) {
          return new Response(JSON.stringify({
            error: "textEn and targetLanguages array are required"
          }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        let openaiApiKey = context.env.OPENAI_API_KEY;
        if (!openaiApiKey) {
          const settingsStorage = new SettingsStorage(context.env.DB);
          const apiKeySetting = await settingsStorage.getSetting("openai_api_key");
          openaiApiKey = apiKeySetting;
        }
        if (!openaiApiKey) {
          return new Response(JSON.stringify({
            error: "OpenAI API key not configured"
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        console.log("Translating badge text:", textEn, "to languages:", targetLanguages);
        const translations = await TranslationService.translateBadgeText(
          textEn,
          targetLanguages,
          openaiApiKey
        );
        console.log("Translation results:", translations);
        return new Response(JSON.stringify(translations), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error translating badge text:", error);
        return new Response(JSON.stringify({
          error: "Failed to translate badge text",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
  }
});

// api/invoices/admin/list.ts
function json(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
var onRequestGet;
var init_list = __esm({
  "api/invoices/admin/list.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json, "json");
    onRequestGet = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        const { results } = await env.DB.prepare(
          "SELECT * FROM invoices ORDER BY invoiceDate DESC"
        ).all();
        if (!results) {
          return json([]);
        }
        return json(results);
      } catch (error) {
        return json({
          error: error.message
        }, 500);
      }
    }, "onRequestGet");
  }
});

// api/admin/announcement-badges/[id].ts
var onRequestOptions2, onRequestGet2, onRequestPut, onRequestDelete;
var init_id = __esm({
  "api/admin/announcement-badges/[id].ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_settings_storage();
    onRequestOptions2 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, PUT, DELETE, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
    onRequestGet2 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const badgeId = context.params.id;
        if (!badgeId) {
          return new Response(JSON.stringify({ error: "Badge ID is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const badgesData = await settingsStorage.getSetting("announcement_badges");
        const badges = badgesData ? JSON.parse(badgesData) : [];
        const badge = badges.find((b) => b.id === badgeId);
        if (!badge) {
          return new Response(JSON.stringify({ error: "Badge not found" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        return new Response(JSON.stringify(badge), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error fetching announcement badge:", error);
        return new Response(JSON.stringify({
          error: "Failed to fetch announcement badge",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestPut = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const badgeId = context.params.id;
        const requestData = await context.request.json();
        if (!badgeId) {
          return new Response(JSON.stringify({ error: "Badge ID is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        console.log("Updating announcement badge:", badgeId, JSON.stringify(requestData, null, 2));
        const existingBadgesData = await settingsStorage.getSetting("announcement_badges");
        const existingBadges = existingBadgesData ? JSON.parse(existingBadgesData) : [];
        const badgeIndex = existingBadges.findIndex((badge) => badge.id === badgeId);
        if (badgeIndex === -1) {
          return new Response(JSON.stringify({ error: "Badge not found" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        existingBadges[badgeIndex] = {
          ...existingBadges[badgeIndex],
          title: requestData.title || requestData.text || requestData.badgeText || requestData.content || requestData.message || existingBadges[badgeIndex].title,
          subtitle: requestData.subtitle || existingBadges[badgeIndex].subtitle,
          backgroundColor: requestData.backgroundColor || requestData.bgColor || requestData.background || existingBadges[badgeIndex].backgroundColor,
          textColor: requestData.textColor || requestData.color || requestData.foreground || existingBadges[badgeIndex].textColor,
          priority: requestData.priority ? parseInt(requestData.priority) : existingBadges[badgeIndex].priority,
          isActive: requestData.isActive !== void 0 ? Boolean(requestData.isActive) : requestData.enabled !== void 0 ? Boolean(requestData.enabled) : existingBadges[badgeIndex].isActive,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        console.log("Updated badge object:", JSON.stringify(existingBadges[badgeIndex], null, 2));
        await settingsStorage.setSetting("announcement_badges", JSON.stringify(existingBadges));
        console.log("Updated announcement badge:", badgeId);
        return new Response(JSON.stringify(existingBadges[badgeIndex]), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error updating announcement badge:", error);
        return new Response(JSON.stringify({
          error: "Failed to update announcement badge",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPut");
    onRequestDelete = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const badgeId = context.params.id;
        if (!badgeId) {
          return new Response(JSON.stringify({ error: "Badge ID is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        console.log("Deleting announcement badge:", badgeId);
        const existingBadgesData = await settingsStorage.getSetting("announcement_badges");
        const existingBadges = existingBadgesData ? JSON.parse(existingBadgesData) : [];
        const updatedBadges = existingBadges.filter((badge) => badge.id !== badgeId);
        if (updatedBadges.length === existingBadges.length) {
          return new Response(JSON.stringify({ error: "Badge not found" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        await settingsStorage.setSetting("announcement_badges", JSON.stringify(updatedBadges));
        console.log("Deleted announcement badge:", badgeId);
        return new Response(JSON.stringify({ success: true }), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error deleting announcement badge:", error);
        return new Response(JSON.stringify({
          error: "Failed to delete announcement badge",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestDelete");
  }
});

// api/admin/countdown-banners/[id].ts
var onRequestOptions3, onRequestGet3, onRequestPut2, onRequestDelete2;
var init_id2 = __esm({
  "api/admin/countdown-banners/[id].ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_settings_storage();
    onRequestOptions3 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, PUT, DELETE, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
    onRequestGet3 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const bannerId = context.params.id;
        if (!bannerId) {
          return new Response(JSON.stringify({ error: "Banner ID is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const bannersData = await settingsStorage.getSetting("countdown_banners");
        const banners = bannersData ? JSON.parse(bannersData) : [];
        const banner = banners.find((b) => b.id === bannerId);
        if (!banner) {
          return new Response(JSON.stringify({ error: "Banner not found" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        return new Response(JSON.stringify(banner), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error fetching countdown banner:", error);
        return new Response(JSON.stringify({
          error: "Failed to fetch countdown banner",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestPut2 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const bannerId = context.params.id;
        const requestData = await context.request.json();
        if (!bannerId) {
          return new Response(JSON.stringify({ error: "Banner ID is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        console.log("Updating countdown banner:", bannerId, requestData);
        const existingBannersData = await settingsStorage.getSetting("countdown_banners");
        const existingBanners = existingBannersData ? JSON.parse(existingBannersData) : [];
        const bannerIndex = existingBanners.findIndex((banner) => banner.id === bannerId);
        if (bannerIndex === -1) {
          return new Response(JSON.stringify({ error: "Banner not found" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        existingBanners[bannerIndex] = {
          ...existingBanners[bannerIndex],
          title: requestData.title || existingBanners[bannerIndex].title,
          subtitle: requestData.subtitle || existingBanners[bannerIndex].subtitle,
          targetPrice: requestData.targetPrice ? parseFloat(requestData.targetPrice) : existingBanners[bannerIndex].targetPrice,
          originalPrice: requestData.originalPrice ? parseFloat(requestData.originalPrice) : existingBanners[bannerIndex].originalPrice,
          endDate: requestData.endDate || existingBanners[bannerIndex].endDate,
          priority: requestData.priority ? parseInt(requestData.priority) : existingBanners[bannerIndex].priority,
          backgroundColor: requestData.backgroundColor || existingBanners[bannerIndex].backgroundColor,
          textColor: requestData.textColor || existingBanners[bannerIndex].textColor,
          isActive: requestData.isActive !== void 0 ? requestData.isActive : existingBanners[bannerIndex].isActive,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        await settingsStorage.setSetting("countdown_banners", JSON.stringify(existingBanners));
        console.log("Updated countdown banner:", bannerId);
        return new Response(JSON.stringify(existingBanners[bannerIndex]), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error updating countdown banner:", error);
        return new Response(JSON.stringify({
          error: "Failed to update countdown banner",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPut");
    onRequestDelete2 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const bannerId = context.params.id;
        if (!bannerId) {
          return new Response(JSON.stringify({ error: "Banner ID is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        console.log("Deleting countdown banner:", bannerId);
        const existingBannersData = await settingsStorage.getSetting("countdown_banners");
        const existingBanners = existingBannersData ? JSON.parse(existingBannersData) : [];
        const updatedBanners = existingBanners.filter((banner) => banner.id !== bannerId);
        if (updatedBanners.length === existingBanners.length) {
          return new Response(JSON.stringify({ error: "Banner not found" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        await settingsStorage.setSetting("countdown_banners", JSON.stringify(updatedBanners));
        console.log("Deleted countdown banner:", bannerId);
        return new Response(JSON.stringify({ success: true }), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error deleting countdown banner:", error);
        return new Response(JSON.stringify({
          error: "Failed to delete countdown banner",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestDelete");
  }
});

// api/admin/dashboard-features/[feature].ts
var onRequestPut3, onRequestOptions4;
var init_feature = __esm({
  "api/admin/dashboard-features/[feature].ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestPut3 = /* @__PURE__ */ __name(async ({ request, params }) => {
      try {
        const featureName = params.feature;
        const { isEnabled, description } = await request.json();
        return new Response(JSON.stringify({
          success: true,
          message: `Feature ${featureName} updated successfully`,
          feature: {
            id: featureName,
            name: featureName.replace("-", " ").replace(/\b\w/g, (l) => l.toUpperCase()),
            isEnabled,
            description: description || `${featureName} feature`
          }
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          message: "Failed to update feature"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPut");
    onRequestOptions4 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "PUT, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/orders/[orderId].ts
async function onRequestPut4(context) {
  const { request, env, params } = context;
  const orderId = params.orderId;
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "PUT, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const { status } = await request.json();
    if (!status || !["pending", "completed", "failed", "refunded"].includes(status)) {
      return new Response(JSON.stringify({
        success: false,
        error: "Invalid status. Must be one of: pending, completed, failed, refunded"
      }), {
        status: 400,
        headers: { "Content-Type": "application/json", ...corsHeaders }
      });
    }
    const updateQuery = `
      UPDATE orders 
      SET status = ?, completedAt = ?
      WHERE id = ?
    `;
    const completedAt = status === "completed" ? (/* @__PURE__ */ new Date()).toISOString() : null;
    const updateResult = await env.DB.prepare(updateQuery).bind(status, completedAt, orderId).run();
    if (!updateResult.success) {
      throw new Error("Failed to update order status");
    }
    if (status === "completed") {
      const orderQuery = `
        SELECT customerEmail, finalAmount 
        FROM orders 
        WHERE id = ?
      `;
      const orderResult = await env.DB.prepare(orderQuery).bind(orderId).first();
      if (orderResult) {
        const userUpdateQuery = `
          UPDATE users 
          SET 
            isPremium = 1
          WHERE email = ?
        `;
        await env.DB.prepare(userUpdateQuery).bind(orderResult.customerEmail).run();
      }
    }
    return new Response(JSON.stringify({
      success: true,
      message: "Order status updated successfully"
    }), {
      status: 200,
      headers: { "Content-Type": "application/json", ...corsHeaders }
    });
  } catch (error) {
    console.error("Error updating order:", error);
    return new Response(JSON.stringify({
      success: false,
      error: "Failed to update order status"
    }), {
      status: 500,
      headers: { "Content-Type": "application/json", ...corsHeaders }
    });
  }
}
var init_orderId = __esm({
  "api/admin/orders/[orderId].ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(onRequestPut4, "onRequestPut");
  }
});

// api/extension/check/[id].ts
function json2(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
var onRequestGet4;
var init_id3 = __esm({
  "api/extension/check/[id].ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json2, "json");
    onRequestGet4 = /* @__PURE__ */ __name(async ({ request, params, env }) => {
      try {
        const paramId = params.id;
        const authHeader = request.headers.get("Authorization");
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          return json2({ canUse: false, reason: "Not authenticated" });
        }
        const token = authHeader.substring(7);
        if (token === "demo-jwt-token" && paramId === "1") {
          return json2({
            canUse: true,
            reason: "Premium access",
            trialUsed: 0,
            isBlocked: false
          });
        }
        if (token.startsWith("jwt-token-")) {
          const parts = token.split("-");
          if (parts.length < 3) {
            return json2({ canUse: false, reason: "Invalid token" }, 401);
          }
          const userEmail = parts[2];
          if (!env.DB) {
            return json2({ canUse: false, reason: "Database not available" }, 500);
          }
          const customer = await env.DB.prepare(
            "SELECT extension_activated FROM customers WHERE email = ?"
          ).bind(userEmail).first();
          if (customer && customer.extension_activated) {
            return json2({
              canUse: true,
              reason: "Premium access",
              trialUsed: 0,
              isBlocked: false
            });
          } else {
            return json2({
              canUse: true,
              reason: "Trial access",
              trialUsed: 5,
              // This could be dynamic in a real app
              isBlocked: false
            });
          }
        }
        return json2({ canUse: false, reason: "Invalid token" }, 401);
      } catch (error) {
        return json2({
          error: error.message
        }, 500);
      }
    }, "onRequestGet");
  }
});

// api/extension/downloads/[id].ts
function json3(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
var onRequestGet5;
var init_id4 = __esm({
  "api/extension/downloads/[id].ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json3, "json");
    onRequestGet5 = /* @__PURE__ */ __name(async ({ request, params, env }) => {
      try {
        const userId = params.id;
        const authHeader = request.headers.get("Authorization");
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          return json3([]);
        }
        const token = authHeader.substring(7);
        if (token === "demo-jwt-token" || token.startsWith("jwt-token-") && token.split("-")[2] === "1") {
          return json3([
            {
              id: 1,
              downloadToken: "demo-download-token",
              downloadType: "paid",
              downloadCount: 1,
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          ]);
        }
        return json3([]);
      } catch (error) {
        return json3({
          error: error.message
        }, 500);
      }
    }, "onRequestGet");
  }
});

// api/invoices/[id]/download.ts
function generateInvoiceHTML(invoice, order, settings3) {
  const company = settings3.company || {
    name: "OCUS Job Hunter",
    address: "Digital Services Company",
    email: "support@jobhunter.one",
    website: "https://jobhunter.one"
  };
  return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>Invoice #${invoice.invoiceNumber}</title>
      <style>
        body { font-family: sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 800px; margin: auto; padding: 20px; border: 1px solid #eee; }
        .header { display: flex; justify-content: space-between; align-items: flex-start; }
        .details { display: flex; justify-content: space-between; margin-top: 20px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 10px; border: 1px solid #ddd; }
        .totals { margin-top: 20px; text-align: right; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>Invoice</h1>
          <div>
            <strong>${company.name}</strong><br>
            ${company.address}<br>
            ${company.email}
          </div>
        </div>
        <div class="details">
          <div>
            <h3>Bill To:</h3>
            ${order.customerName}<br>
            ${order.customerEmail}
          </div>
          <div>
            <h3>Invoice Details:</h3>
            <strong>Invoice #:</strong> ${invoice.invoiceNumber}<br>
            <strong>Date:</strong> ${new Date(invoice.invoiceDate).toLocaleDateString()}
          </div>
        </div>
        <table>
          <thead>
            <tr>
              <th>Description</th>
              <th>Total</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>${order.productName}</td>
              <td>${order.finalAmount.toFixed(2)} ${order.currency}</td>
            </tr>
          </tbody>
        </table>
        <div class="totals">
          <h3>Total: ${order.finalAmount.toFixed(2)} ${order.currency}</h3>
        </div>
      </div>
    </body>
    </html>
  `;
}
var onRequestGet6;
var init_download = __esm({
  "api/invoices/[id]/download.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(generateInvoiceHTML, "generateInvoiceHTML");
    onRequestGet6 = /* @__PURE__ */ __name(async ({ params, env }) => {
      try {
        const invoiceId = params.id;
        if (!invoiceId) {
          return new Response("Invoice ID is required", { status: 400 });
        }
        const invoice = await env.DB.prepare("SELECT * FROM invoices WHERE id = ?").bind(invoiceId).first();
        if (!invoice) return new Response("Invoice not found", { status: 404 });
        const order = await env.DB.prepare("SELECT * FROM orders WHERE id = ?").bind(invoice.orderId).first();
        if (!order) return new Response("Associated order not found", { status: 404 });
        const settingsStmt = await env.DB.prepare("SELECT value FROM settings WHERE key = ?").bind("invoice_settings").first();
        const settings3 = settingsStmt ? JSON.parse(settingsStmt.value) : {};
        const html = generateInvoiceHTML(invoice, order, settings3);
        return new Response(html, {
          headers: {
            "Content-Type": "text/html",
            "Content-Disposition": `attachment; filename="invoice-${invoice.invoiceNumber}.html"`,
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        return new Response(`Error generating invoice: ${error.message}`, { status: 500 });
      }
    }, "onRequestGet");
  }
});

// api/invoices/[id]/download-receipt.ts
function generateReceiptHTML(invoice, order, settings3) {
  const company = settings3.company || {
    name: "OCUS Job Hunter",
    email: "support@jobhunter.one"
  };
  return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>Receipt for Invoice #${invoice.invoiceNumber}</title>
      <style>
        body { font-family: sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: auto; padding: 20px; border: 1px solid #eee; }
        .header { text-align: center; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .details { margin-top: 20px; }
        .summary { margin-top: 20px; }
        .total-amount { font-size: 1.2em; font-weight: bold; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>Payment Receipt</h1>
        </div>
        <div class="details">
          <p><strong>Receipt #:</strong> RCPT-${invoice.id}</p>
          <p><strong>Payment Date:</strong> ${new Date(order.completedAt).toLocaleDateString()}</p>
          <p><strong>Paid To:</strong> ${company.name}</p>
          <p><strong>Paid By:</strong> ${order.customerName}</p>
        </div>
        <div class="summary">
          <h3>Summary</h3>
          <p>Total Paid: <span class="total-amount">${order.finalAmount.toFixed(2)} ${order.currency}</span></p>
        </div>
      </div>
    </body>
    </html>
  `;
}
var onRequestGet7;
var init_download_receipt = __esm({
  "api/invoices/[id]/download-receipt.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(generateReceiptHTML, "generateReceiptHTML");
    onRequestGet7 = /* @__PURE__ */ __name(async ({ params, env }) => {
      try {
        const invoiceId = params.id;
        if (!invoiceId) {
          return new Response("Invoice ID is required", { status: 400 });
        }
        const invoice = await env.DB.prepare("SELECT * FROM invoices WHERE id = ?").bind(invoiceId).first();
        if (!invoice) return new Response("Invoice not found", { status: 404 });
        const order = await env.DB.prepare("SELECT * FROM orders WHERE id = ?").bind(invoice.orderId).first();
        if (!order) return new Response("Associated order not found", { status: 404 });
        const settingsStmt = await env.DB.prepare("SELECT value FROM settings WHERE key = ?").bind("invoice_settings").first();
        const settings3 = settingsStmt ? JSON.parse(settingsStmt.value) : {};
        const html = generateReceiptHTML(invoice, order, settings3);
        return new Response(html, {
          headers: {
            "Content-Type": "text/html",
            "Content-Disposition": `attachment; filename="receipt-${invoice.invoiceNumber}.html"`,
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        return new Response(`Error generating receipt: ${error.message}`, { status: 500 });
      }
    }, "onRequestGet");
  }
});

// api/invoices/[id]/html.ts
function generateInvoiceHTML2(invoice, order, settings3) {
  const company = settings3.company || {
    name: "OCUS Job Hunter",
    address: "Digital Services Company",
    email: "support@jobhunter.one",
    website: "https://jobhunter.one"
  };
  return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Invoice #${invoice.invoiceNumber}</title>
      <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; color: #333; background-color: #f9f9f9; margin: 0; padding: 0; }
        .container { max-width: 800px; margin: 20px auto; padding: 30px; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .header { display: flex; justify-content: space-between; align-items: flex-start; padding-bottom: 20px; border-bottom: 2px solid #eee; }
        .header h1 { font-size: 2.5em; color: #000; margin: 0; }
        .header .company-details { text-align: right; font-size: 0.9em; color: #555; }
        .details { display: flex; justify-content: space-between; margin-top: 30px; }
        .details .customer-details, .details .invoice-details { font-size: 0.95em; }
        .details h3 { margin-top: 0; font-size: 1.1em; color: #000; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        table { width: 100%; border-collapse: collapse; margin-top: 30px; }
        th, td { padding: 12px 15px; text-align: left; }
        thead { background-color: #f5f5f5; border-bottom: 2px solid #ddd; }
        th { font-weight: 600; color: #333; }
        tbody tr { border-bottom: 1px solid #eee; }
        .totals { margin-top: 30px; text-align: right; }
        .totals table { width: auto; float: right; }
        .totals td { text-align: right; }
        .totals .total-amount { font-size: 1.4em; font-weight: bold; color: #000; }
        .footer { margin-top: 40px; text-align: center; font-size: 0.85em; color: #777; border-top: 1px solid #eee; padding-top: 20px; }
        .status { font-size: 1.2em; font-weight: bold; padding: 8px 12px; border-radius: 6px; text-transform: uppercase; }
        .status.paid { color: #28a745; background-color: #e9f7ec; }
        .status.pending { color: #ffc107; background-color: #fff8e1; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>Invoice</h1>
          <div class="company-details">
            <strong>${company.name}</strong><br>
            ${company.address}<br>
            ${company.email}<br>
            ${company.website}
          </div>
        </div>
        <div class="details">
          <div class="customer-details">
            <h3>Bill To:</h3>
            <strong>${order.customerName}</strong><br>
            ${order.customerEmail}
          </div>
          <div class="invoice-details">
            <h3>Invoice Details:</h3>
            <strong>Invoice #:</strong> ${invoice.invoiceNumber}<br>
            <strong>Date:</strong> ${new Date(invoice.invoiceDate).toLocaleDateString()}<br>
            <strong>Due Date:</strong> ${new Date(invoice.dueDate).toLocaleDateString()}<br>
            <strong>Status:</strong> <span class="status ${invoice.status.toLowerCase()}">${invoice.status}</span>
          </div>
        </div>
        <table>
          <thead>
            <tr>
              <th>Description</th>
              <th>Quantity</th>
              <th>Unit Price</th>
              <th>Total</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>${order.productName}</td>
              <td>1</td>
              <td>${order.finalAmount.toFixed(2)} ${order.currency}</td>
              <td>${order.finalAmount.toFixed(2)} ${order.currency}</td>
            </tr>
          </tbody>
        </table>
        <div class="totals">
          <table>
            <tr>
              <td>Subtotal:</td>
              <td>${order.finalAmount.toFixed(2)} ${order.currency}</td>
            </tr>
            <tr>
              <td>Tax (0%):</td>
              <td>0.00 ${order.currency}</td>
            </tr>
            <tr>
              <td class="total-amount">Total:</td>
              <td class="total-amount">${order.finalAmount.toFixed(2)} ${order.currency}</td>
            </tr>
          </table>
        </div>
        <div class="footer">
          <p>Thank you for your business!</p>
          <p>If you have any questions, please contact us at ${company.email}.</p>
        </div>
      </div>
    </body>
    </html>
  `;
}
var onRequestGet8;
var init_html = __esm({
  "api/invoices/[id]/html.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(generateInvoiceHTML2, "generateInvoiceHTML");
    onRequestGet8 = /* @__PURE__ */ __name(async ({ params, env }) => {
      try {
        const invoiceId = params.id;
        if (!invoiceId) {
          return new Response("Invoice ID is required", { status: 400 });
        }
        const invoice = await env.DB.prepare(
          "SELECT * FROM invoices WHERE id = ?"
        ).bind(invoiceId).first();
        if (!invoice) {
          return new Response("Invoice not found", { status: 404 });
        }
        const order = await env.DB.prepare(
          "SELECT * FROM orders WHERE id = ?"
        ).bind(invoice.orderId).first();
        if (!order) {
          return new Response("Associated order not found", { status: 404 });
        }
        const settingsStmt = await env.DB.prepare("SELECT value FROM settings WHERE key = ?").bind("invoice_settings").first();
        const settings3 = settingsStmt ? JSON.parse(settingsStmt.value) : {};
        const html = generateInvoiceHTML2(invoice, order, settings3);
        return new Response(html, {
          headers: {
            "Content-Type": "text/html",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        return new Response(`Error generating invoice: ${error.message}`, { status: 500 });
      }
    }, "onRequestGet");
  }
});

// api/invoices/[id]/receipt.ts
function generateReceiptHTML2(invoice, order, settings3) {
  const company = settings3.company || {
    name: "OCUS Job Hunter",
    email: "support@jobhunter.one"
  };
  return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Receipt for Invoice #${invoice.invoiceNumber}</title>
      <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; color: #333; background-color: #f9f9f9; margin: 0; padding: 0; }
        .container { max-width: 600px; margin: 20px auto; padding: 30px; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .header { text-align: center; padding-bottom: 20px; border-bottom: 2px solid #eee; }
        .header h1 { font-size: 2.2em; color: #28a745; margin: 0; }
        .header p { font-size: 1.1em; color: #555; }
        .details { margin-top: 30px; font-size: 0.95em; }
        .details strong { color: #000; }
        .summary { margin-top: 30px; }
        .summary h3 { font-size: 1.2em; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        td { padding: 10px 0; }
        .total-amount { font-size: 1.5em; font-weight: bold; color: #000; }
        .footer { margin-top: 30px; text-align: center; font-size: 0.85em; color: #777; border-top: 1px solid #eee; padding-top: 20px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>Payment Receipt</h1>
          <p>Thank you for your purchase!</p>
        </div>
        <div class="details">
          <p><strong>Receipt #:</strong> RCPT-${invoice.id}</p>
          <p><strong>Invoice #:</strong> ${invoice.invoiceNumber}</p>
          <p><strong>Payment Date:</strong> ${new Date(order.completedAt).toLocaleDateString()}</p>
          <p><strong>Paid To:</strong> ${company.name}</p>
          <p><strong>Paid By:</strong> ${order.customerName} (${order.customerEmail})</p>
        </div>
        <div class="summary">
          <h3>Payment Summary</h3>
          <table>
            <tr>
              <td>${order.productName}</td>
              <td style="text-align: right;">${order.finalAmount.toFixed(2)} ${order.currency}</td>
            </tr>
            <tr>
              <td style="font-weight: bold;">Total Paid:</td>
              <td style="text-align: right;" class="total-amount">${order.finalAmount.toFixed(2)} ${order.currency}</td>
            </tr>
          </table>
        </div>
        <div class="footer">
          <p>If you have any questions, please contact us at ${company.email}.</p>
        </div>
      </div>
    </body>
    </html>
  `;
}
var onRequestGet9;
var init_receipt = __esm({
  "api/invoices/[id]/receipt.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(generateReceiptHTML2, "generateReceiptHTML");
    onRequestGet9 = /* @__PURE__ */ __name(async ({ params, env }) => {
      try {
        const invoiceId = params.id;
        if (!invoiceId) {
          return new Response("Invoice ID is required", { status: 400 });
        }
        const invoice = await env.DB.prepare("SELECT * FROM invoices WHERE id = ?").bind(invoiceId).first();
        if (!invoice) return new Response("Invoice not found", { status: 404 });
        const order = await env.DB.prepare("SELECT * FROM orders WHERE id = ?").bind(invoice.orderId).first();
        if (!order) return new Response("Associated order not found", { status: 404 });
        const settingsStmt = await env.DB.prepare("SELECT value FROM settings WHERE key = ?").bind("invoice_settings").first();
        const settings3 = settingsStmt ? JSON.parse(settingsStmt.value) : {};
        const html = generateReceiptHTML2(invoice, order, settings3);
        return new Response(html, {
          headers: { "Content-Type": "text/html", "Access-Control-Allow-Origin": "*" }
        });
      } catch (error) {
        return new Response(`Error generating receipt: ${error.message}`, { status: 500 });
      }
    }, "onRequestGet");
  }
});

// lib/db.ts
var TicketStorage;
var init_db = __esm({
  "lib/db.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    TicketStorage = class {
      constructor(db) {
        this.db = db;
      }
      static {
        __name(this, "TicketStorage");
      }
      async getAllTickets() {
        try {
          const result = await this.db.prepare("SELECT * FROM tickets ORDER BY created_at DESC").all();
          return result.results;
        } catch (error) {
          console.error("D1 getAllTickets error:", error);
          throw new Error(`Database query failed: ${error.message}`);
        }
      }
      async getTicketsByCustomerEmail(email) {
        try {
          const result = await this.db.prepare("SELECT * FROM tickets WHERE customer_email = ? ORDER BY created_at DESC").bind(email).all();
          return result.results;
        } catch (error) {
          console.error("D1 getTicketsByCustomerEmail error:", error);
          throw new Error(`Database query failed: ${error.message}`);
        }
      }
      async getTicketsByCustomerId(customerId) {
        try {
          const result = await this.db.prepare("SELECT * FROM tickets WHERE customer_id = ? ORDER BY created_at DESC").bind(customerId).all();
          return result.results;
        } catch (error) {
          console.error("D1 getTicketsByCustomerId error:", error);
          throw new Error(`Database query failed: ${error.message}`);
        }
      }
      async getTicketById(id) {
        const result = await this.db.prepare("SELECT * FROM tickets WHERE id = ?").bind(id).first();
        return result;
      }
      async createTicket(ticket) {
        if (ticket.customer_id === void 0) {
          throw new Error("customer_id is required to create a ticket.");
        }
        const now = (/* @__PURE__ */ new Date()).toISOString();
        try {
          const result = await this.db.prepare(`
        INSERT INTO tickets (customer_id, title, description, category, priority, status, customer_email, customer_name, assigned_to_user_id, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        RETURNING *
      `).bind(
            ticket.customer_id,
            ticket.title,
            ticket.description,
            ticket.category,
            ticket.priority,
            ticket.status,
            ticket.customer_email,
            ticket.customer_name,
            ticket.assigned_to_user_id || null,
            now,
            now
          ).first();
          if (!result) {
            throw new Error("Failed to insert ticket - no result returned");
          }
          return result;
        } catch (error) {
          console.error("D1 createTicket error:", error);
          throw new Error(`Database insert failed: ${error.message}`);
        }
      }
      async updateTicket(id, updates) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        try {
          const result = await this.db.prepare(`
        UPDATE tickets 
        SET title = COALESCE(?, title),
            description = COALESCE(?, description),
            category = COALESCE(?, category),
            priority = COALESCE(?, priority),
            status = COALESCE(?, status),
            assigned_to_user_id = COALESCE(?, assigned_to_user_id),
            updated_at = ?,
            resolved_at = CASE WHEN ? = 'resolved' THEN ? ELSE resolved_at END,
            archived_at = CASE WHEN ? = 'archived' THEN ? ELSE archived_at END
        WHERE id = ?
        RETURNING *
      `).bind(
            updates.title || null,
            updates.description || null,
            updates.category || null,
            updates.priority || null,
            updates.status || null,
            updates.assigned_to_user_id || null,
            now,
            updates.status,
            updates.status === "resolved" ? now : null,
            updates.status,
            updates.status === "archived" ? now : null,
            id
          ).first();
          return result;
        } catch (error) {
          console.error("D1 updateTicket error:", error);
          throw new Error(`Database update failed: ${error.message}`);
        }
      }
      async archiveTicket(id) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        try {
          const result = await this.db.prepare(`
        UPDATE tickets 
        SET status = 'archived',
            archived_at = ?,
            updated_at = ?
        WHERE id = ?
        RETURNING *
      `).bind(now, now, id).first();
          return result;
        } catch (error) {
          console.error("D1 archiveTicket error:", error);
          throw new Error(`Database archive failed: ${error.message}`);
        }
      }
      async updateTicketStatus(id, status) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        await this.db.prepare("UPDATE tickets SET status = ?, updated_at = ? WHERE id = ?").bind(status, now, id).run();
      }
      async deleteTicket(id) {
        await this.db.prepare("DELETE FROM ticket_messages WHERE ticket_id = ?").bind(id).run();
        await this.db.prepare("DELETE FROM tickets WHERE id = ?").bind(id).run();
      }
      async getTicketMessages(ticketId) {
        const result = await this.db.prepare("SELECT * FROM ticket_messages WHERE ticket_id = ? ORDER BY created_at ASC").bind(ticketId).all();
        return result.results;
      }
      async addTicketMessage(message) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const result = await this.db.prepare(`
      INSERT INTO ticket_messages (ticket_id, message, is_from_customer, sender_name, sender_email, created_at, attachments)
      VALUES (?, ?, ?, ?, ?, ?, ?)
      RETURNING *
    `).bind(
          message.ticket_id,
          message.message,
          message.is_from_customer ? 1 : 0,
          message.sender_name,
          message.sender_email || null,
          now,
          message.attachments || null
        ).first();
        await this.db.prepare("UPDATE tickets SET updated_at = ? WHERE id = ?").bind(now, message.ticket_id).run();
        return result;
      }
    };
  }
});

// api/tickets/[id]/archive.ts
var onRequestPost2;
var init_archive = __esm({
  "api/tickets/[id]/archive.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_db();
    onRequestPost2 = /* @__PURE__ */ __name(async ({ request, params, env }) => {
      const ticketId = Number(params.id);
      if (!ticketId || isNaN(ticketId)) {
        return Response.json({ success: false, message: "Invalid ticket ID" }, { status: 400 });
      }
      if (env.EXPRESS_API_BASE) {
        try {
          const proxyUrl = `${env.EXPRESS_API_BASE}/api/tickets/${ticketId}/archive`;
          const proxyResponse = await fetch(proxyUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": request.headers.get("Authorization") || ""
            }
          });
          const data = await proxyResponse.json();
          return Response.json(data, { status: proxyResponse.status });
        } catch (error) {
          console.error("Express proxy error:", error);
        }
      }
      if (!env.DB) {
        return Response.json({ success: false, message: "Database not available" }, { status: 500 });
      }
      try {
        const storage2 = new TicketStorage(env.DB);
        const existingTicket = await storage2.getTicketById(ticketId);
        if (!existingTicket) {
          return Response.json({ success: false, message: "Ticket not found" }, { status: 404 });
        }
        const archivedTicket = await storage2.archiveTicket(ticketId);
        if (!archivedTicket) {
          return Response.json({ success: false, message: "Failed to archive ticket" }, { status: 500 });
        }
        return Response.json({
          success: true,
          message: "Ticket archived successfully",
          ticket: archivedTicket
        });
      } catch (error) {
        console.error("Archive ticket error:", error);
        return Response.json({
          success: false,
          message: "Failed to archive ticket",
          error: error.message
        }, { status: 500 });
      }
    }, "onRequestPost");
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
    init_functionsRoutes_0_8044054200943971();
  }
});

// ../node_modules/bcryptjs/index.js
var bcryptjs_exports = {};
__export(bcryptjs_exports, {
  compare: () => compare,
  compareSync: () => compareSync,
  decodeBase64: () => decodeBase64,
  default: () => bcryptjs_default,
  encodeBase64: () => encodeBase64,
  genSalt: () => genSalt,
  genSaltSync: () => genSaltSync,
  getRounds: () => getRounds,
  getSalt: () => getSalt,
  hash: () => hash,
  hashSync: () => hashSync,
  setRandomFallback: () => setRandomFallback,
  truncates: () => truncates
});
function randomBytes(len) {
  try {
    return crypto.getRandomValues(new Uint8Array(len));
  } catch {
  }
  try {
    return import_crypto.default.randomBytes(len);
  } catch {
  }
  if (!randomFallback) {
    throw Error(
      "Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative"
    );
  }
  return randomFallback(len);
}
function setRandomFallback(random) {
  randomFallback = random;
}
function genSaltSync(rounds, seed_length) {
  rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
  if (typeof rounds !== "number")
    throw Error(
      "Illegal arguments: " + typeof rounds + ", " + typeof seed_length
    );
  if (rounds < 4) rounds = 4;
  else if (rounds > 31) rounds = 31;
  var salt = [];
  salt.push("$2b$");
  if (rounds < 10) salt.push("0");
  salt.push(rounds.toString());
  salt.push("$");
  salt.push(base64_encode(randomBytes(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
  return salt.join("");
}
function genSalt(rounds, seed_length, callback) {
  if (typeof seed_length === "function")
    callback = seed_length, seed_length = void 0;
  if (typeof rounds === "function") callback = rounds, rounds = void 0;
  if (typeof rounds === "undefined") rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
  else if (typeof rounds !== "number")
    throw Error("illegal arguments: " + typeof rounds);
  function _async(callback2) {
    nextTick(function() {
      try {
        callback2(null, genSaltSync(rounds));
      } catch (err) {
        callback2(err);
      }
    });
  }
  __name(_async, "_async");
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function hashSync(password, salt) {
  if (typeof salt === "undefined") salt = GENSALT_DEFAULT_LOG2_ROUNDS;
  if (typeof salt === "number") salt = genSaltSync(salt);
  if (typeof password !== "string" || typeof salt !== "string")
    throw Error("Illegal arguments: " + typeof password + ", " + typeof salt);
  return _hash(password, salt);
}
function hash(password, salt, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password === "string" && typeof salt === "number")
      genSalt(salt, function(err, salt2) {
        _hash(password, salt2, callback2, progressCallback);
      });
    else if (typeof password === "string" && typeof salt === "string")
      _hash(password, salt, callback2, progressCallback);
    else
      nextTick(
        callback2.bind(
          this,
          Error("Illegal arguments: " + typeof password + ", " + typeof salt)
        )
      );
  }
  __name(_async, "_async");
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function safeStringCompare(known, unknown) {
  var diff = known.length ^ unknown.length;
  for (var i = 0; i < known.length; ++i) {
    diff |= known.charCodeAt(i) ^ unknown.charCodeAt(i);
  }
  return diff === 0;
}
function compareSync(password, hash2) {
  if (typeof password !== "string" || typeof hash2 !== "string")
    throw Error("Illegal arguments: " + typeof password + ", " + typeof hash2);
  if (hash2.length !== 60) return false;
  return safeStringCompare(
    hashSync(password, hash2.substring(0, hash2.length - 31)),
    hash2
  );
}
function compare(password, hashValue, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password !== "string" || typeof hashValue !== "string") {
      nextTick(
        callback2.bind(
          this,
          Error(
            "Illegal arguments: " + typeof password + ", " + typeof hashValue
          )
        )
      );
      return;
    }
    if (hashValue.length !== 60) {
      nextTick(callback2.bind(this, null, false));
      return;
    }
    hash(
      password,
      hashValue.substring(0, 29),
      function(err, comp) {
        if (err) callback2(err);
        else callback2(null, safeStringCompare(comp, hashValue));
      },
      progressCallback
    );
  }
  __name(_async, "_async");
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function getRounds(hash2) {
  if (typeof hash2 !== "string")
    throw Error("Illegal arguments: " + typeof hash2);
  return parseInt(hash2.split("$")[2], 10);
}
function getSalt(hash2) {
  if (typeof hash2 !== "string")
    throw Error("Illegal arguments: " + typeof hash2);
  if (hash2.length !== 60)
    throw Error("Illegal hash length: " + hash2.length + " != 60");
  return hash2.substring(0, 29);
}
function truncates(password) {
  if (typeof password !== "string")
    throw Error("Illegal arguments: " + typeof password);
  return utf8Length(password) > 72;
}
function utf8Length(string) {
  var len = 0, c = 0;
  for (var i = 0; i < string.length; ++i) {
    c = string.charCodeAt(i);
    if (c < 128) len += 1;
    else if (c < 2048) len += 2;
    else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
      ++i;
      len += 4;
    } else len += 3;
  }
  return len;
}
function utf8Array(string) {
  var offset = 0, c1, c2;
  var buffer = new Array(utf8Length(string));
  for (var i = 0, k = string.length; i < k; ++i) {
    c1 = string.charCodeAt(i);
    if (c1 < 128) {
      buffer[offset++] = c1;
    } else if (c1 < 2048) {
      buffer[offset++] = c1 >> 6 | 192;
      buffer[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i;
      buffer[offset++] = c1 >> 18 | 240;
      buffer[offset++] = c1 >> 12 & 63 | 128;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    } else {
      buffer[offset++] = c1 >> 12 | 224;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    }
  }
  return buffer;
}
function base64_encode(b, len) {
  var off = 0, rs = [], c1, c2;
  if (len <= 0 || len > b.length) throw Error("Illegal len: " + len);
  while (off < len) {
    c1 = b[off++] & 255;
    rs.push(BASE64_CODE[c1 >> 2 & 63]);
    c1 = (c1 & 3) << 4;
    if (off >= len) {
      rs.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 4 & 15;
    rs.push(BASE64_CODE[c1 & 63]);
    c1 = (c2 & 15) << 2;
    if (off >= len) {
      rs.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 6 & 3;
    rs.push(BASE64_CODE[c1 & 63]);
    rs.push(BASE64_CODE[c2 & 63]);
  }
  return rs.join("");
}
function base64_decode(s, len) {
  var off = 0, slen = s.length, olen = 0, rs = [], c1, c2, c3, c4, o, code;
  if (len <= 0) throw Error("Illegal len: " + len);
  while (off < slen - 1 && olen < len) {
    code = s.charCodeAt(off++);
    c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    code = s.charCodeAt(off++);
    c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c1 == -1 || c2 == -1) break;
    o = c1 << 2 >>> 0;
    o |= (c2 & 48) >> 4;
    rs.push(String.fromCharCode(o));
    if (++olen >= len || off >= slen) break;
    code = s.charCodeAt(off++);
    c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c3 == -1) break;
    o = (c2 & 15) << 4 >>> 0;
    o |= (c3 & 60) >> 2;
    rs.push(String.fromCharCode(o));
    if (++olen >= len || off >= slen) break;
    code = s.charCodeAt(off++);
    c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    o = (c3 & 3) << 6 >>> 0;
    o |= c4;
    rs.push(String.fromCharCode(o));
    ++olen;
  }
  var res = [];
  for (off = 0; off < olen; off++) res.push(rs[off].charCodeAt(0));
  return res;
}
function _encipher(lr, off, P, S) {
  var n, l = lr[off], r = lr[off + 1];
  l ^= P[0];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[1];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[2];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[3];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[4];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[5];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[6];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[7];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[8];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[9];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[10];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[11];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[12];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[13];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[14];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[15];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[16];
  lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
  lr[off + 1] = l;
  return lr;
}
function _streamtoword(data, offp) {
  for (var i = 0, word = 0; i < 4; ++i)
    word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
  return { key: word, offp };
}
function _key(key, P, S) {
  var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0; i < plen; i++)
    sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
  for (i = 0; i < plen; i += 2)
    lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0; i < slen; i += 2)
    lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _ekskey(data, key, P, S) {
  var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0; i < plen; i++)
    sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
  offp = 0;
  for (i = 0; i < plen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0; i < slen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _crypt(b, salt, rounds, callback, progressCallback) {
  var cdata = C_ORIG.slice(), clen = cdata.length, err;
  if (rounds < 4 || rounds > 31) {
    err = Error("Illegal number of rounds (4-31): " + rounds);
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else throw err;
  }
  if (salt.length !== BCRYPT_SALT_LEN) {
    err = Error(
      "Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN
    );
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else throw err;
  }
  rounds = 1 << rounds >>> 0;
  var P, S, i = 0, j;
  if (typeof Int32Array === "function") {
    P = new Int32Array(P_ORIG);
    S = new Int32Array(S_ORIG);
  } else {
    P = P_ORIG.slice();
    S = S_ORIG.slice();
  }
  _ekskey(salt, b, P, S);
  function next() {
    if (progressCallback) progressCallback(i / rounds);
    if (i < rounds) {
      var start = Date.now();
      for (; i < rounds; ) {
        i = i + 1;
        _key(b, P, S);
        _key(salt, P, S);
        if (Date.now() - start > MAX_EXECUTION_TIME) break;
      }
    } else {
      for (i = 0; i < 64; i++)
        for (j = 0; j < clen >> 1; j++) _encipher(cdata, j << 1, P, S);
      var ret = [];
      for (i = 0; i < clen; i++)
        ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
      if (callback) {
        callback(null, ret);
        return;
      } else return ret;
    }
    if (callback) nextTick(next);
  }
  __name(next, "next");
  if (typeof callback !== "undefined") {
    next();
  } else {
    var res;
    while (true) if (typeof (res = next()) !== "undefined") return res || [];
  }
}
function _hash(password, salt, callback, progressCallback) {
  var err;
  if (typeof password !== "string" || typeof salt !== "string") {
    err = Error("Invalid string / salt: Not a string");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else throw err;
  }
  var minor, offset;
  if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
    err = Error("Invalid salt version: " + salt.substring(0, 2));
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else throw err;
  }
  if (salt.charAt(2) === "$") minor = String.fromCharCode(0), offset = 3;
  else {
    minor = salt.charAt(2);
    if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
      err = Error("Invalid salt revision: " + salt.substring(2, 4));
      if (callback) {
        nextTick(callback.bind(this, err));
        return;
      } else throw err;
    }
    offset = 4;
  }
  if (salt.charAt(offset + 2) > "$") {
    err = Error("Missing salt rounds");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else throw err;
  }
  var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
  password += minor >= "a" ? "\0" : "";
  var passwordb = utf8Array(password), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
  function finish(bytes) {
    var res = [];
    res.push("$2");
    if (minor >= "a") res.push(minor);
    res.push("$");
    if (rounds < 10) res.push("0");
    res.push(rounds.toString());
    res.push("$");
    res.push(base64_encode(saltb, saltb.length));
    res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
    return res.join("");
  }
  __name(finish, "finish");
  if (typeof callback == "undefined")
    return finish(_crypt(passwordb, saltb, rounds));
  else {
    _crypt(
      passwordb,
      saltb,
      rounds,
      function(err2, bytes) {
        if (err2) callback(err2, null);
        else callback(null, finish(bytes));
      },
      progressCallback
    );
  }
}
function encodeBase64(bytes, length) {
  return base64_encode(bytes, length);
}
function decodeBase64(string, length) {
  return base64_decode(string, length);
}
var import_crypto, randomFallback, nextTick, BASE64_CODE, BASE64_INDEX, BCRYPT_SALT_LEN, GENSALT_DEFAULT_LOG2_ROUNDS, BLOWFISH_NUM_ROUNDS, MAX_EXECUTION_TIME, P_ORIG, S_ORIG, C_ORIG, bcryptjs_default;
var init_bcryptjs = __esm({
  "../node_modules/bcryptjs/index.js"() {
    init_functionsRoutes_0_8044054200943971();
    import_crypto = __toESM(require_crypto(), 1);
    randomFallback = null;
    __name(randomBytes, "randomBytes");
    __name(setRandomFallback, "setRandomFallback");
    __name(genSaltSync, "genSaltSync");
    __name(genSalt, "genSalt");
    __name(hashSync, "hashSync");
    __name(hash, "hash");
    __name(safeStringCompare, "safeStringCompare");
    __name(compareSync, "compareSync");
    __name(compare, "compare");
    __name(getRounds, "getRounds");
    __name(getSalt, "getSalt");
    __name(truncates, "truncates");
    nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
    __name(utf8Length, "utf8Length");
    __name(utf8Array, "utf8Array");
    BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
    BASE64_INDEX = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    __name(base64_encode, "base64_encode");
    __name(base64_decode, "base64_decode");
    BCRYPT_SALT_LEN = 16;
    GENSALT_DEFAULT_LOG2_ROUNDS = 10;
    BLOWFISH_NUM_ROUNDS = 16;
    MAX_EXECUTION_TIME = 100;
    P_ORIG = [
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ];
    S_ORIG = [
      3509652390,
      2564797868,
      805139163,
      3491422135,
      3101798381,
      1780907670,
      3128725573,
      4046225305,
      614570311,
      3012652279,
      134345442,
      2240740374,
      1667834072,
      1901547113,
      2757295779,
      4103290238,
      227898511,
      1921955416,
      1904987480,
      2182433518,
      2069144605,
      3260701109,
      2620446009,
      720527379,
      3318853667,
      677414384,
      3393288472,
      3101374703,
      2390351024,
      1614419982,
      1822297739,
      2954791486,
      3608508353,
      3174124327,
      2024746970,
      1432378464,
      3864339955,
      2857741204,
      1464375394,
      1676153920,
      1439316330,
      715854006,
      3033291828,
      289532110,
      2706671279,
      2087905683,
      3018724369,
      1668267050,
      732546397,
      1947742710,
      3462151702,
      2609353502,
      2950085171,
      1814351708,
      2050118529,
      680887927,
      999245976,
      1800124847,
      3300911131,
      1713906067,
      1641548236,
      4213287313,
      1216130144,
      1575780402,
      4018429277,
      3917837745,
      3693486850,
      3949271944,
      596196993,
      3549867205,
      258830323,
      2213823033,
      772490370,
      2760122372,
      1774776394,
      2652871518,
      566650946,
      4142492826,
      1728879713,
      2882767088,
      1783734482,
      3629395816,
      2517608232,
      2874225571,
      1861159788,
      326777828,
      3124490320,
      2130389656,
      2716951837,
      967770486,
      1724537150,
      2185432712,
      2364442137,
      1164943284,
      2105845187,
      998989502,
      3765401048,
      2244026483,
      1075463327,
      1455516326,
      1322494562,
      910128902,
      469688178,
      1117454909,
      936433444,
      3490320968,
      3675253459,
      1240580251,
      122909385,
      2157517691,
      634681816,
      4142456567,
      3825094682,
      3061402683,
      2540495037,
      79693498,
      3249098678,
      1084186820,
      1583128258,
      426386531,
      1761308591,
      1047286709,
      322548459,
      995290223,
      1845252383,
      2603652396,
      3431023940,
      2942221577,
      3202600964,
      3727903485,
      1712269319,
      422464435,
      3234572375,
      1170764815,
      3523960633,
      3117677531,
      1434042557,
      442511882,
      3600875718,
      1076654713,
      1738483198,
      4213154764,
      2393238008,
      3677496056,
      1014306527,
      4251020053,
      793779912,
      2902807211,
      842905082,
      4246964064,
      1395751752,
      1040244610,
      2656851899,
      3396308128,
      445077038,
      3742853595,
      3577915638,
      679411651,
      2892444358,
      2354009459,
      1767581616,
      3150600392,
      3791627101,
      3102740896,
      284835224,
      4246832056,
      1258075500,
      768725851,
      2589189241,
      3069724005,
      3532540348,
      1274779536,
      3789419226,
      2764799539,
      1660621633,
      3471099624,
      4011903706,
      913787905,
      3497959166,
      737222580,
      2514213453,
      2928710040,
      3937242737,
      1804850592,
      3499020752,
      2949064160,
      2386320175,
      2390070455,
      2415321851,
      4061277028,
      2290661394,
      2416832540,
      1336762016,
      1754252060,
      3520065937,
      3014181293,
      791618072,
      3188594551,
      3933548030,
      2332172193,
      3852520463,
      3043980520,
      413987798,
      3465142937,
      3030929376,
      4245938359,
      2093235073,
      3534596313,
      375366246,
      2157278981,
      2479649556,
      555357303,
      3870105701,
      2008414854,
      3344188149,
      4221384143,
      3956125452,
      2067696032,
      3594591187,
      2921233993,
      2428461,
      544322398,
      577241275,
      1471733935,
      610547355,
      4027169054,
      1432588573,
      1507829418,
      2025931657,
      3646575487,
      545086370,
      48609733,
      2200306550,
      1653985193,
      298326376,
      1316178497,
      3007786442,
      2064951626,
      458293330,
      2589141269,
      3591329599,
      3164325604,
      727753846,
      2179363840,
      146436021,
      1461446943,
      4069977195,
      705550613,
      3059967265,
      3887724982,
      4281599278,
      3313849956,
      1404054877,
      2845806497,
      146425753,
      1854211946,
      1266315497,
      3048417604,
      3681880366,
      3289982499,
      290971e4,
      1235738493,
      2632868024,
      2414719590,
      3970600049,
      1771706367,
      1449415276,
      3266420449,
      422970021,
      1963543593,
      2690192192,
      3826793022,
      1062508698,
      1531092325,
      1804592342,
      2583117782,
      2714934279,
      4024971509,
      1294809318,
      4028980673,
      1289560198,
      2221992742,
      1669523910,
      35572830,
      157838143,
      1052438473,
      1016535060,
      1802137761,
      1753167236,
      1386275462,
      3080475397,
      2857371447,
      1040679964,
      2145300060,
      2390574316,
      1461121720,
      2956646967,
      4031777805,
      4028374788,
      33600511,
      2920084762,
      1018524850,
      629373528,
      3691585981,
      3515945977,
      2091462646,
      2486323059,
      586499841,
      988145025,
      935516892,
      3367335476,
      2599673255,
      2839830854,
      265290510,
      3972581182,
      2759138881,
      3795373465,
      1005194799,
      847297441,
      406762289,
      1314163512,
      1332590856,
      1866599683,
      4127851711,
      750260880,
      613907577,
      1450815602,
      3165620655,
      3734664991,
      3650291728,
      3012275730,
      3704569646,
      1427272223,
      778793252,
      1343938022,
      2676280711,
      2052605720,
      1946737175,
      3164576444,
      3914038668,
      3967478842,
      3682934266,
      1661551462,
      3294938066,
      4011595847,
      840292616,
      3712170807,
      616741398,
      312560963,
      711312465,
      1351876610,
      322626781,
      1910503582,
      271666773,
      2175563734,
      1594956187,
      70604529,
      3617834859,
      1007753275,
      1495573769,
      4069517037,
      2549218298,
      2663038764,
      504708206,
      2263041392,
      3941167025,
      2249088522,
      1514023603,
      1998579484,
      1312622330,
      694541497,
      2582060303,
      2151582166,
      1382467621,
      776784248,
      2618340202,
      3323268794,
      2497899128,
      2784771155,
      503983604,
      4076293799,
      907881277,
      423175695,
      432175456,
      1378068232,
      4145222326,
      3954048622,
      3938656102,
      3820766613,
      2793130115,
      2977904593,
      26017576,
      3274890735,
      3194772133,
      1700274565,
      1756076034,
      4006520079,
      3677328699,
      720338349,
      1533947780,
      354530856,
      688349552,
      3973924725,
      1637815568,
      332179504,
      3949051286,
      53804574,
      2852348879,
      3044236432,
      1282449977,
      3583942155,
      3416972820,
      4006381244,
      1617046695,
      2628476075,
      3002303598,
      1686838959,
      431878346,
      2686675385,
      1700445008,
      1080580658,
      1009431731,
      832498133,
      3223435511,
      2605976345,
      2271191193,
      2516031870,
      1648197032,
      4164389018,
      2548247927,
      300782431,
      375919233,
      238389289,
      3353747414,
      2531188641,
      2019080857,
      1475708069,
      455242339,
      2609103871,
      448939670,
      3451063019,
      1395535956,
      2413381860,
      1841049896,
      1491858159,
      885456874,
      4264095073,
      4001119347,
      1565136089,
      3898914787,
      1108368660,
      540939232,
      1173283510,
      2745871338,
      3681308437,
      4207628240,
      3343053890,
      4016749493,
      1699691293,
      1103962373,
      3625875870,
      2256883143,
      3830138730,
      1031889488,
      3479347698,
      1535977030,
      4236805024,
      3251091107,
      2132092099,
      1774941330,
      1199868427,
      1452454533,
      157007616,
      2904115357,
      342012276,
      595725824,
      1480756522,
      206960106,
      497939518,
      591360097,
      863170706,
      2375253569,
      3596610801,
      1814182875,
      2094937945,
      3421402208,
      1082520231,
      3463918190,
      2785509508,
      435703966,
      3908032597,
      1641649973,
      2842273706,
      3305899714,
      1510255612,
      2148256476,
      2655287854,
      3276092548,
      4258621189,
      236887753,
      3681803219,
      274041037,
      1734335097,
      3815195456,
      3317970021,
      1899903192,
      1026095262,
      4050517792,
      356393447,
      2410691914,
      3873677099,
      3682840055,
      3913112168,
      2491498743,
      4132185628,
      2489919796,
      1091903735,
      1979897079,
      3170134830,
      3567386728,
      3557303409,
      857797738,
      1136121015,
      1342202287,
      507115054,
      2535736646,
      337727348,
      3213592640,
      1301675037,
      2528481711,
      1895095763,
      1721773893,
      3216771564,
      62756741,
      2142006736,
      835421444,
      2531993523,
      1442658625,
      3659876326,
      2882144922,
      676362277,
      1392781812,
      170690266,
      3921047035,
      1759253602,
      3611846912,
      1745797284,
      664899054,
      1329594018,
      3901205900,
      3045908486,
      2062866102,
      2865634940,
      3543621612,
      3464012697,
      1080764994,
      553557557,
      3656615353,
      3996768171,
      991055499,
      499776247,
      1265440854,
      648242737,
      3940784050,
      980351604,
      3713745714,
      1749149687,
      3396870395,
      4211799374,
      3640570775,
      1161844396,
      3125318951,
      1431517754,
      545492359,
      4268468663,
      3499529547,
      1437099964,
      2702547544,
      3433638243,
      2581715763,
      2787789398,
      1060185593,
      1593081372,
      2418618748,
      4260947970,
      69676912,
      2159744348,
      86519011,
      2512459080,
      3838209314,
      1220612927,
      3339683548,
      133810670,
      1090789135,
      1078426020,
      1569222167,
      845107691,
      3583754449,
      4072456591,
      1091646820,
      628848692,
      1613405280,
      3757631651,
      526609435,
      236106946,
      48312990,
      2942717905,
      3402727701,
      1797494240,
      859738849,
      992217954,
      4005476642,
      2243076622,
      3870952857,
      3732016268,
      765654824,
      3490871365,
      2511836413,
      1685915746,
      3888969200,
      1414112111,
      2273134842,
      3281911079,
      4080962846,
      172450625,
      2569994100,
      980381355,
      4109958455,
      2819808352,
      2716589560,
      2568741196,
      3681446669,
      3329971472,
      1835478071,
      660984891,
      3704678404,
      4045999559,
      3422617507,
      3040415634,
      1762651403,
      1719377915,
      3470491036,
      2693910283,
      3642056355,
      3138596744,
      1364962596,
      2073328063,
      1983633131,
      926494387,
      3423689081,
      2150032023,
      4096667949,
      1749200295,
      3328846651,
      309677260,
      2016342300,
      1779581495,
      3079819751,
      111262694,
      1274766160,
      443224088,
      298511866,
      1025883608,
      3806446537,
      1145181785,
      168956806,
      3641502830,
      3584813610,
      1689216846,
      3666258015,
      3200248200,
      1692713982,
      2646376535,
      4042768518,
      1618508792,
      1610833997,
      3523052358,
      4130873264,
      2001055236,
      3610705100,
      2202168115,
      4028541809,
      2961195399,
      1006657119,
      2006996926,
      3186142756,
      1430667929,
      3210227297,
      1314452623,
      4074634658,
      4101304120,
      2273951170,
      1399257539,
      3367210612,
      3027628629,
      1190975929,
      2062231137,
      2333990788,
      2221543033,
      2438960610,
      1181637006,
      548689776,
      2362791313,
      3372408396,
      3104550113,
      3145860560,
      296247880,
      1970579870,
      3078560182,
      3769228297,
      1714227617,
      3291629107,
      3898220290,
      166772364,
      1251581989,
      493813264,
      448347421,
      195405023,
      2709975567,
      677966185,
      3703036547,
      1463355134,
      2715995803,
      1338867538,
      1343315457,
      2802222074,
      2684532164,
      233230375,
      2599980071,
      2000651841,
      3277868038,
      1638401717,
      4028070440,
      3237316320,
      6314154,
      819756386,
      300326615,
      590932579,
      1405279636,
      3267499572,
      3150704214,
      2428286686,
      3959192993,
      3461946742,
      1862657033,
      1266418056,
      963775037,
      2089974820,
      2263052895,
      1917689273,
      448879540,
      3550394620,
      3981727096,
      150775221,
      3627908307,
      1303187396,
      508620638,
      2975983352,
      2726630617,
      1817252668,
      1876281319,
      1457606340,
      908771278,
      3720792119,
      3617206836,
      2455994898,
      1729034894,
      1080033504,
      976866871,
      3556439503,
      2881648439,
      1522871579,
      1555064734,
      1336096578,
      3548522304,
      2579274686,
      3574697629,
      3205460757,
      3593280638,
      3338716283,
      3079412587,
      564236357,
      2993598910,
      1781952180,
      1464380207,
      3163844217,
      3332601554,
      1699332808,
      1393555694,
      1183702653,
      3581086237,
      1288719814,
      691649499,
      2847557200,
      2895455976,
      3193889540,
      2717570544,
      1781354906,
      1676643554,
      2592534050,
      3230253752,
      1126444790,
      2770207658,
      2633158820,
      2210423226,
      2615765581,
      2414155088,
      3127139286,
      673620729,
      2805611233,
      1269405062,
      4015350505,
      3341807571,
      4149409754,
      1057255273,
      2012875353,
      2162469141,
      2276492801,
      2601117357,
      993977747,
      3918593370,
      2654263191,
      753973209,
      36408145,
      2530585658,
      25011837,
      3520020182,
      2088578344,
      530523599,
      2918365339,
      1524020338,
      1518925132,
      3760827505,
      3759777254,
      1202760957,
      3985898139,
      3906192525,
      674977740,
      4174734889,
      2031300136,
      2019492241,
      3983892565,
      4153806404,
      3822280332,
      352677332,
      2297720250,
      60907813,
      90501309,
      3286998549,
      1016092578,
      2535922412,
      2839152426,
      457141659,
      509813237,
      4120667899,
      652014361,
      1966332200,
      2975202805,
      55981186,
      2327461051,
      676427537,
      3255491064,
      2882294119,
      3433927263,
      1307055953,
      942726286,
      933058658,
      2468411793,
      3933900994,
      4215176142,
      1361170020,
      2001714738,
      2830558078,
      3274259782,
      1222529897,
      1679025792,
      2729314320,
      3714953764,
      1770335741,
      151462246,
      3013232138,
      1682292957,
      1483529935,
      471910574,
      1539241949,
      458788160,
      3436315007,
      1807016891,
      3718408830,
      978976581,
      1043663428,
      3165965781,
      1927990952,
      4200891579,
      2372276910,
      3208408903,
      3533431907,
      1412390302,
      2931980059,
      4132332400,
      1947078029,
      3881505623,
      4168226417,
      2941484381,
      1077988104,
      1320477388,
      886195818,
      18198404,
      3786409e3,
      2509781533,
      112762804,
      3463356488,
      1866414978,
      891333506,
      18488651,
      661792760,
      1628790961,
      3885187036,
      3141171499,
      876946877,
      2693282273,
      1372485963,
      791857591,
      2686433993,
      3759982718,
      3167212022,
      3472953795,
      2716379847,
      445679433,
      3561995674,
      3504004811,
      3574258232,
      54117162,
      3331405415,
      2381918588,
      3769707343,
      4154350007,
      1140177722,
      4074052095,
      668550556,
      3214352940,
      367459370,
      261225585,
      2610173221,
      4209349473,
      3468074219,
      3265815641,
      314222801,
      3066103646,
      3808782860,
      282218597,
      3406013506,
      3773591054,
      379116347,
      1285071038,
      846784868,
      2669647154,
      3771962079,
      3550491691,
      2305946142,
      453669953,
      1268987020,
      3317592352,
      3279303384,
      3744833421,
      2610507566,
      3859509063,
      266596637,
      3847019092,
      517658769,
      3462560207,
      3443424879,
      370717030,
      4247526661,
      2224018117,
      4143653529,
      4112773975,
      2788324899,
      2477274417,
      1456262402,
      2901442914,
      1517677493,
      1846949527,
      2295493580,
      3734397586,
      2176403920,
      1280348187,
      1908823572,
      3871786941,
      846861322,
      1172426758,
      3287448474,
      3383383037,
      1655181056,
      3139813346,
      901632758,
      1897031941,
      2986607138,
      3066810236,
      3447102507,
      1393639104,
      373351379,
      950779232,
      625454576,
      3124240540,
      4148612726,
      2007998917,
      544563296,
      2244738638,
      2330496472,
      2058025392,
      1291430526,
      424198748,
      50039436,
      29584100,
      3605783033,
      2429876329,
      2791104160,
      1057563949,
      3255363231,
      3075367218,
      3463963227,
      1469046755,
      985887462
    ];
    C_ORIG = [
      1332899944,
      1700884034,
      1701343084,
      1684370003,
      1668446532,
      1869963892
    ];
    __name(_encipher, "_encipher");
    __name(_streamtoword, "_streamtoword");
    __name(_key, "_key");
    __name(_ekskey, "_ekskey");
    __name(_crypt, "_crypt");
    __name(_hash, "_hash");
    __name(encodeBase64, "encodeBase64");
    __name(decodeBase64, "decodeBase64");
    bcryptjs_default = {
      setRandomFallback,
      genSaltSync,
      genSalt,
      hashSync,
      hash,
      compareSync,
      compare,
      getRounds,
      getSalt,
      truncates,
      encodeBase64,
      decodeBase64
    };
  }
});

// lib/user-storage.ts
var UserStorage;
var init_user_storage = __esm({
  "lib/user-storage.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_bcryptjs();
    UserStorage = class {
      constructor(db) {
        this.db = db;
      }
      static {
        __name(this, "UserStorage");
      }
      async getAllCustomers() {
        try {
          const customers2 = await this.db.prepare(`
        SELECT id, email, name, is_premium, extension_activated, total_spent, total_orders, created_at
        FROM customers 
        ORDER BY created_at DESC
      `).all();
          return customers2.results || [];
        } catch (error) {
          console.error("Failed to get all customers:", error);
          return [];
        }
      }
      async initializeUsers() {
        try {
          await this.db.prepare(`
        CREATE TABLE IF NOT EXISTS users (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          email TEXT UNIQUE NOT NULL,
          password TEXT, -- Nullable for social logins
          name TEXT NOT NULL,
          role TEXT DEFAULT 'customer' NOT NULL,
          provider TEXT,
          provider_id TEXT,
          is_premium BOOLEAN DEFAULT 0,
          extension_activated BOOLEAN DEFAULT 0,
          premium_activated_at TEXT,
          total_spent REAL DEFAULT 0,
          total_orders INTEGER DEFAULT 0,
          created_at TEXT NOT NULL DEFAULT (datetime('now')),
          updated_at TEXT NOT NULL DEFAULT (datetime('now'))
        )
      `).run();
        } catch (error) {
          console.error("Failed to initialize users table:", error);
          throw new Error("Database initialization failed.");
        }
      }
      async createUser(email, password, name) {
        const hashedPassword = bcryptjs_default.hashSync(password, 10);
        const now = (/* @__PURE__ */ new Date()).toISOString();
        try {
          const result = await this.db.prepare(`
        INSERT INTO users (email, name, password, created_at, updatedAt)
        VALUES (?, ?, ?, datetime('now'), datetime('now'))
      `).bind(email, name, hashedPassword).run();
          const userId = result.meta.last_row_id;
          if (!userId) {
            throw new Error("Failed to get user ID after creation.");
          }
          const newUser = await this.getUserById(userId);
          if (!newUser) {
            throw new Error("Could not retrieve newly created user.");
          }
          return newUser;
        } catch (error) {
          console.error("Failed to create user:", error);
          throw error;
        }
      }
      async getUserByEmail(email) {
        try {
          const user = await this.db.prepare(
            "SELECT * FROM users WHERE email = ?"
          ).bind(email).first();
          return user || null;
        } catch (error) {
          console.error("Failed to get user by email:", error);
          return null;
        }
      }
      async validateUser(email, password) {
        try {
          const user = await this.getUserByEmail(email);
          if (user && user.password && bcryptjs_default.compareSync(password, user.password)) {
            const { password: _, ...userWithoutPassword } = user;
            return userWithoutPassword;
          }
          return null;
        } catch (error) {
          console.error("Failed to validate user:", error);
          return null;
        }
      }
      async getUserById(id) {
        try {
          const user = await this.db.prepare(
            "SELECT * FROM users WHERE id = ?"
          ).bind(id).first();
          return user || null;
        } catch (error) {
          console.error("Failed to get user by ID:", error);
          return null;
        }
      }
    };
  }
});

// api/tickets/[id]/messages.ts
function json4(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var onRequestPost3, onRequestGet10, onRequestOptions5;
var init_messages = __esm({
  "api/tickets/[id]/messages.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_db();
    init_user_storage();
    __name(json4, "json");
    onRequestPost3 = /* @__PURE__ */ __name(async ({ request, params, env }) => {
      try {
        const ticketId = Number(params.id);
        const expressBase = env?.EXPRESS_API_BASE;
        if (expressBase) {
          const base = expressBase.replace(/\/$/, "");
          const url = `${base}/api/tickets/${ticketId}/messages`;
          const headers = {};
          const cookie = request.headers.get("cookie");
          const ct2 = request.headers.get("content-type");
          const auth = request.headers.get("authorization");
          if (cookie) headers["cookie"] = cookie;
          if (ct2) headers["content-type"] = ct2;
          if (auth) headers["authorization"] = auth;
          const proxied = await fetch(url, {
            method: "POST",
            headers,
            body: request.body,
            redirect: "manual"
          });
          const respHeaders = new Headers(proxied.headers);
          const setCookie = respHeaders.get("set-cookie");
          if (setCookie) {
            const rewritten = setCookie.replace(/;\s*Domain=[^;]+/i, "");
            respHeaders.delete("set-cookie");
            respHeaders.append("set-cookie", rewritten);
          }
          return new Response(proxied.body, { status: proxied.status, headers: respHeaders });
        }
        let content;
        let customerEmail;
        let customerName;
        let isAdmin;
        let attachmentData;
        const ct = request.headers.get("content-type") || "";
        try {
          if (ct.includes("application/json")) {
            const body = await request.json();
            content = body?.content ?? body?.message;
            customerEmail = body?.customerEmail;
            customerName = body?.customerName;
            isAdmin = !!body?.isAdmin;
          } else if (ct.includes("multipart/form-data")) {
            const form = await request.formData();
            const raw = form.get("content") ?? form.get("message");
            content = typeof raw === "string" ? raw : void 0;
            const ce = form.get("customerEmail");
            customerEmail = typeof ce === "string" ? ce : void 0;
            const cn = form.get("customerName");
            customerName = typeof cn === "string" ? cn : void 0;
            const ia = form.get("isAdmin");
            isAdmin = typeof ia === "string" ? ia === "true" : false;
            const attachments = [];
            for (const [key, value] of form.entries()) {
              if (key.startsWith("attachment_") && value instanceof File) {
                attachments.push({
                  name: value.name,
                  type: value.type,
                  size: value.size
                });
              }
            }
            if (attachments.length > 0) {
              content = content || "[File attachment]";
              attachmentData = JSON.stringify(attachments);
            }
          } else {
            try {
              const body = await request.json();
              content = body?.content ?? body?.message;
              customerEmail = body?.customerEmail;
              customerName = body?.customerName;
              isAdmin = !!body?.isAdmin;
            } catch {
              const text2 = await request.text();
              content = text2 || void 0;
            }
          }
        } catch {
          const text2 = await request.text();
          content = text2 || void 0;
        }
        content = typeof content === "string" ? content.trim() : content;
        const hasAttachments = request.headers.get("content-type")?.includes("multipart/form-data");
        if (!content && !hasAttachments) {
          return json4({ success: false, message: "Missing content" }, 400);
        }
        if (!content && hasAttachments) {
          content = "[File attachment]";
        }
        const storage2 = new TicketStorage(env.DB);
        const ticket = await storage2.getTicketById(ticketId);
        if (!ticket) return json4({ success: false, message: "Ticket not found" }, 200);
        let finalSenderName = customerName;
        if (!customerName && customerEmail && !isAdmin) {
          try {
            const userStorage = new UserStorage(env.DB);
            await userStorage.initializeUsers();
            const user = await userStorage.getUserByEmail(customerEmail);
            if (user) {
              finalSenderName = user.name;
            }
          } catch (error) {
            console.error("Failed to fetch user name for message:", error);
          }
        }
        const msg = await storage2.addTicketMessage({
          ticket_id: ticketId,
          message: content || "[File attachment]",
          is_from_customer: !isAdmin,
          sender_name: finalSenderName || (isAdmin ? "Admin" : ticket.customer_name),
          sender_email: customerEmail || (isAdmin ? void 0 : ticket.customer_email),
          attachments: attachmentData
        });
        return json4({ success: true, message: msg });
      } catch (error) {
        console.error("Failed to add message:", error);
        const message = error instanceof Error ? error.message : "An unknown error occurred";
        return json4({ success: false, message }, 500);
      }
    }, "onRequestPost");
    onRequestGet10 = /* @__PURE__ */ __name(async ({ request, params, env }) => {
      const ticketId = Number(params.id);
      const expressBase = env?.EXPRESS_API_BASE;
      if (expressBase) {
        const base = expressBase.replace(/\/$/, "");
        const url = `${base}/api/tickets/${ticketId}/messages`;
        const headers = {};
        const cookie = request.headers.get("cookie");
        const auth = request.headers.get("authorization");
        if (cookie) headers["cookie"] = cookie;
        if (auth) headers["authorization"] = auth;
        const proxied = await fetch(url, { headers, redirect: "manual" });
        const respHeaders = new Headers(proxied.headers);
        const setCookie = respHeaders.get("set-cookie");
        if (setCookie) {
          const rewritten = setCookie.replace(/;\s*Domain=[^;]+/i, "");
          respHeaders.delete("set-cookie");
          respHeaders.append("set-cookie", rewritten);
        }
        return new Response(proxied.body, { status: proxied.status, headers: respHeaders });
      }
      const storage2 = new TicketStorage(env.DB);
      const messages = await storage2.getTicketMessages(ticketId);
      const mapped = messages.map((m) => ({
        id: m.id,
        ticketId: m.ticket_id,
        content: m.message,
        isAdmin: !m.is_from_customer,
        authorName: m.sender_name,
        createdAt: m.created_at,
        attachments: []
      }));
      return json4(mapped);
    }, "onRequestGet");
    onRequestOptions5 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/tickets/[id]/status.ts
function getStore() {
  const s = globalThis.__TICKET_STORE__;
  if (!s) {
    globalThis.__TICKET_STORE__ = { tickets: [], messages: /* @__PURE__ */ new Map(), seq: 1, msgSeq: 1 };
  }
  return globalThis.__TICKET_STORE__;
}
function json5(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
function toInternalStatus(input) {
  if (input === "in_progress") return "in-progress";
  if (input === "closed") return "closed";
  return input || "open";
}
var onRequestPut5, onRequestOptions6;
var init_status = __esm({
  "api/tickets/[id]/status.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(getStore, "getStore");
    __name(json5, "json");
    __name(toInternalStatus, "toInternalStatus");
    onRequestPut5 = /* @__PURE__ */ __name(async ({ request, params, env }) => {
      try {
        const ticketId = Number(params.id);
        const expressBase = env?.EXPRESS_API_BASE;
        if (expressBase) {
          const base = expressBase.replace(/\/$/, "");
          const url = `${base}/api/tickets/${ticketId}/status`;
          const headers = {};
          const cookie = request.headers.get("cookie");
          const ct = request.headers.get("content-type");
          const auth = request.headers.get("authorization");
          if (cookie) headers["cookie"] = cookie;
          if (ct) headers["content-type"] = ct;
          if (auth) headers["authorization"] = auth;
          const proxied = await fetch(url, { method: "PUT", headers, body: request.body, redirect: "manual" });
          const respHeaders = new Headers(proxied.headers);
          const setCookie = respHeaders.get("set-cookie");
          if (setCookie) {
            const rewritten = setCookie.replace(/;\s*Domain=[^;]+/i, "");
            respHeaders.delete("set-cookie");
            respHeaders.append("set-cookie", rewritten);
          }
          return new Response(proxied.body, { status: proxied.status, headers: respHeaders });
        }
        const body = await request.json().catch(() => ({}));
        const status = body?.status;
        if (!status) return json5({ success: false, message: "Missing status" }, 400);
        const store = getStore();
        const idx = store.tickets.findIndex((t) => t.id === ticketId);
        if (idx === -1) return json5({ success: false, message: "Ticket not found" }, 404);
        const now = (/* @__PURE__ */ new Date()).toISOString();
        store.tickets[idx] = {
          ...store.tickets[idx],
          status: toInternalStatus(status),
          updated_at: now
        };
        return json5({ success: true, ticket: store.tickets[idx] });
      } catch (e) {
        return json5({ success: false, message: "Failed to update status" }, 500);
      }
    }, "onRequestPut");
    onRequestOptions6 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "PUT, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/user/[id]/purchase-status.ts
function json6(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
var onRequestGet11;
var init_purchase_status = __esm({
  "api/user/[id]/purchase-status.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json6, "json");
    onRequestGet11 = /* @__PURE__ */ __name(async ({ request, params, env }) => {
      try {
        const userId = params.id;
        const authHeader = request.headers.get("Authorization");
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          return json6({
            hasPurchased: false,
            totalSpent: "0.00",
            completedOrders: 0,
            lastPurchaseDate: null
          });
        }
        const token = authHeader.substring(7);
        if (token === "demo-jwt-token" || token.startsWith("jwt-token-") && token.split("-")[2] === "1") {
          return json6({
            hasPurchased: true,
            totalSpent: "29.99",
            completedOrders: 1,
            lastPurchaseDate: Date.now()
          });
        }
        if (!env.DB) {
          return json6({
            hasPurchased: false,
            totalSpent: "0.00",
            completedOrders: 0,
            lastPurchaseDate: null
          });
        }
        try {
          if (!token.startsWith("jwt-token-")) {
            return json6({
              hasPurchased: false,
              totalSpent: "0.00",
              completedOrders: 0,
              lastPurchaseDate: null
            }, 401);
          }
          const parts = token.split("-");
          if (parts.length < 3) {
            return json6({
              hasPurchased: false,
              totalSpent: "0.00",
              completedOrders: 0,
              lastPurchaseDate: null
            }, 401);
          }
          const email = parts[2];
          const user = await env.DB.prepare(`
        SELECT id, email, extension_activated, is_premium
        FROM users WHERE email = ?
      `).bind(email).first();
          const customer = user ? null : await env.DB.prepare(`
        SELECT id, email, extension_activated
        FROM customers WHERE email = ?
      `).bind(email).first();
          if (!user && !customer) {
            return json6({
              hasPurchased: false,
              totalSpent: "0.00",
              completedOrders: 0,
              lastPurchaseDate: null
            });
          }
          const hasPremiumStatus = user?.is_premium === 1 || Boolean(customer?.extension_activated);
          const hasExtensionActivated = user?.extension_activated === 1 || Boolean(customer?.extension_activated);
          const orderStats = await env.DB.prepare(`
        SELECT COUNT(*) as completedOrders, 
               SUM(final_amount) as totalPaid,
               MAX(completed_at) as lastPurchaseDate
        FROM orders 
        WHERE customer_email = ? AND status = 'completed' AND final_amount > 0
      `).bind(email).first();
          const completedOrders = Number(orderStats?.completedOrders || 0);
          const totalPaid = String(orderStats?.totalPaid || "0.00");
          const lastPurchaseDate = orderStats?.lastPurchaseDate;
          const hasPurchased = completedOrders > 0 && parseFloat(totalPaid || "0") > 0 || (hasPremiumStatus || hasExtensionActivated);
          return json6({
            hasPurchased,
            totalSpent: totalPaid,
            completedOrders,
            lastPurchaseDate: lastPurchaseDate ? new Date(String(lastPurchaseDate)).getTime() : null
          });
        } catch (dbError) {
          console.error("Database error in purchase-status:", dbError);
          return json6({
            hasPurchased: false,
            totalSpent: "0.00",
            completedOrders: 0,
            lastPurchaseDate: null
          });
        }
      } catch (error) {
        return json6({
          error: error.message
        }, 500);
      }
    }, "onRequestGet");
  }
});

// api/user/[userId]/invoices.ts
var onRequestGet12, onRequestOptions7;
var init_invoices = __esm({
  "api/user/[userId]/invoices.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet12 = /* @__PURE__ */ __name(async (context) => {
      try {
        const authHeader = context.request.headers.get("Authorization");
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          return new Response(JSON.stringify({ error: "Unauthorized" }), {
            status: 401,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Methods": "GET, OPTIONS",
              "Access-Control-Allow-Headers": "Content-Type, Authorization"
            }
          });
        }
        const token = authHeader.substring(7);
        if (token === "demo-jwt-token") {
          const demoInvoice = {
            id: 1,
            invoiceNumber: "INV-2025-000001",
            orderId: 1,
            customerName: "Demo User",
            customerEmail: "demo@example.com",
            invoiceDate: (/* @__PURE__ */ new Date()).toISOString(),
            dueDate: (/* @__PURE__ */ new Date()).toISOString(),
            subtotal: "29.99",
            taxAmount: "0.00",
            discountAmount: "0.00",
            totalAmount: "29.99",
            currency: "USD",
            status: "paid",
            paidAt: (/* @__PURE__ */ new Date()).toISOString(),
            notes: "Premium extension purchase",
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
            paymentMethod: "stripe"
          };
          return new Response(JSON.stringify([demoInvoice]), {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Methods": "GET, OPTIONS",
              "Access-Control-Allow-Headers": "Content-Type, Authorization"
            }
          });
        }
        if (!token.startsWith("jwt-token-")) {
          return new Response(JSON.stringify({ error: "Invalid token" }), {
            status: 401,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Methods": "GET, OPTIONS",
              "Access-Control-Allow-Headers": "Content-Type, Authorization"
            }
          });
        }
        const parts = token.split("-");
        if (parts.length < 3) {
          return new Response(JSON.stringify({ error: "Invalid token format" }), {
            status: 401,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Methods": "GET, OPTIONS",
              "Access-Control-Allow-Headers": "Content-Type, Authorization"
            }
          });
        }
        const userEmail = parts[2];
        if (!context.env.DB) {
          return new Response(JSON.stringify({ error: "Database not available" }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Methods": "GET, OPTIONS",
              "Access-Control-Allow-Headers": "Content-Type, Authorization"
            }
          });
        }
        const query = `
      SELECT 
        i.id AS id,
        i.invoice_number AS invoiceNumber,
        i.order_id AS orderId,
        i.customer_name AS customerName,
        i.customer_email AS customerEmail,
        i.invoice_date AS invoiceDate,
        i.due_date AS dueDate,
        i.subtotal AS subtotal,
        i.tax_amount AS taxAmount,
        i.discount_amount AS discountAmount,
        i.total_amount AS totalAmount,
        i.currency AS currency,
        i.status AS status,
        i.paid_at AS paidAt,
        i.notes AS notes,
        i.created_at AS createdAt,
        i.updated_at AS updatedAt,
        o.payment_method AS paymentMethod
      FROM invoices i
      LEFT JOIN orders o ON i.order_id = o.id
      WHERE i.customer_email = ?
      ORDER BY i.created_at DESC
    `;
        try {
          const result = await context.env.DB.prepare(query).bind(userEmail).all();
          const invoices2 = result.results || [];
          return new Response(JSON.stringify(invoices2), {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Methods": "GET, OPTIONS",
              "Access-Control-Allow-Headers": "Content-Type, Authorization"
            }
          });
        } catch (dbErr) {
          console.error("DB error in /api/user/[userId]/invoices:", dbErr);
          return new Response(JSON.stringify({ error: "Database error" }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Methods": "GET, OPTIONS",
              "Access-Control-Allow-Headers": "Content-Type, Authorization"
            }
          });
        }
      } catch (error) {
        console.error("Error fetching user invoices:", error);
        return new Response(JSON.stringify({ error: "Failed to fetch invoices" }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type, Authorization"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions7 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
  }
});

// api/user/[userId]/orders.ts
var onRequestGet13, onRequestOptions8;
var init_orders = __esm({
  "api/user/[userId]/orders.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet13 = /* @__PURE__ */ __name(async (context) => {
      try {
        const { params } = context;
        const userId = params.userId;
        if (!userId) {
          return new Response(JSON.stringify({ error: "User ID is required" }), {
            status: 400,
            headers: { "Content-Type": "application/json" }
          });
        }
        const ordersQuery = `
      SELECT 
        id,
        customerEmail,
        customerName,
        productId,
        originalAmount,
        finalAmount,
        currency,
        status,
        paymentMethod,
        downloadToken,
        downloadCount,
        maxDownloads,
        activationCode,
        createdAt,
        completedAt
      FROM orders 
      WHERE customerEmail = (SELECT email FROM users WHERE id = ?)
      ORDER BY createdAt DESC
    `;
        const ordersResult = await context.env.DB.prepare(ordersQuery).bind(userId).all();
        return new Response(JSON.stringify(ordersResult.results || []), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type"
          }
        });
      } catch (error) {
        console.error("Error fetching user orders:", error);
        return new Response(JSON.stringify({ error: "Failed to fetch orders" }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions8 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/user/[userId]/purchase-status.ts
var onRequestGet14, onRequestOptions9;
var init_purchase_status2 = __esm({
  "api/user/[userId]/purchase-status.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet14 = /* @__PURE__ */ __name(async (context) => {
      try {
        const { params } = context;
        const userId = params.userId;
        if (!userId) {
          return new Response(JSON.stringify({ error: "User ID is required" }), {
            status: 400,
            headers: { "Content-Type": "application/json" }
          });
        }
        if (!context.env.DB) {
          return new Response(JSON.stringify({
            hasPurchased: false,
            totalSpent: "0.00",
            completedOrders: 0,
            lastPurchaseDate: null
          }), {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        let userResult = null;
        try {
          try {
            const customerQuery = `SELECT email FROM customers WHERE id = ?`;
            userResult = await context.env.DB.prepare(customerQuery).bind(userId).first();
          } catch (e) {
            try {
              const customerQuery = `SELECT email FROM customers WHERE id = ?`;
              userResult = await context.env.DB.prepare(customerQuery).bind(parseInt(userId)).first();
            } catch (e2) {
              console.log("Customers table query failed");
            }
          }
          if (!userResult) {
            try {
              const usersQuery = `SELECT email FROM users WHERE id = ?`;
              userResult = await context.env.DB.prepare(usersQuery).bind(userId).first();
            } catch (e) {
              try {
                const usersQuery = `SELECT email FROM users WHERE id = ?`;
                userResult = await context.env.DB.prepare(usersQuery).bind(parseInt(userId)).first();
              } catch (e2) {
                console.log("Users table query also failed");
              }
            }
          }
        } catch (tableError) {
          console.log("Table access error:", tableError);
        }
        if (!userResult) {
          return new Response(JSON.stringify({
            hasPurchased: false,
            totalSpent: "0.00",
            completedOrders: 0,
            lastPurchaseDate: null
          }), {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        let statusResult = null;
        try {
          const queryVariations = [
            `SELECT 
          COUNT(CASE WHEN status = 'completed' THEN 1 END) as completedOrders,
          COALESCE(SUM(CASE WHEN status = 'completed' THEN CAST(final_amount as REAL) ELSE 0 END), 0) as totalSpent,
          MAX(CASE WHEN status = 'completed' THEN created_at END) as lastPurchaseDate
        FROM orders 
        WHERE (user_id = ? OR customer_email = ?)`,
            `SELECT 
          COUNT(CASE WHEN status = 'completed' THEN 1 END) as completedOrders,
          COALESCE(SUM(CASE WHEN status = 'completed' THEN CAST("finalAmount" as REAL) ELSE 0 END), 0) as totalSpent,
          MAX(CASE WHEN status = 'completed' THEN "createdAt" END) as lastPurchaseDate
        FROM orders 
        WHERE ("userId" = ? OR "customerEmail" = ?)`,
            `SELECT 
          COUNT(CASE WHEN status = 'completed' THEN 1 END) as completedOrders,
          COALESCE(SUM(CASE WHEN status = 'completed' THEN CAST(finalAmount as REAL) ELSE 0 END), 0) as totalSpent,
          MAX(CASE WHEN status = 'completed' THEN createdAt END) as lastPurchaseDate
        FROM orders 
        WHERE (userId = ? OR customerEmail = ?)`
          ];
          for (const query of queryVariations) {
            try {
              statusResult = await context.env.DB.prepare(query).bind(userId, userResult.email).first();
              if (statusResult) break;
            } catch (e) {
              try {
                statusResult = await context.env.DB.prepare(query).bind(parseInt(userId), userResult.email).first();
                if (statusResult) break;
              } catch (e2) {
                console.log("Query variation failed, trying next");
              }
            }
          }
        } catch (queryError) {
          console.log("All order queries failed:", queryError);
        }
        const hasPurchased = (statusResult?.completedOrders || 0) > 0;
        const totalSpent = (statusResult?.totalSpent || 0).toFixed(2);
        const completedOrders = statusResult?.completedOrders || 0;
        const lastPurchaseDate = statusResult?.lastPurchaseDate ? new Date(statusResult.lastPurchaseDate).getTime() : null;
        return new Response(JSON.stringify({
          hasPurchased,
          totalSpent,
          completedOrders,
          lastPurchaseDate
        }), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type"
          }
        });
      } catch (error) {
        console.error("Error fetching purchase status:", error);
        return new Response(JSON.stringify({
          hasPurchased: false,
          totalSpent: "0.00",
          completedOrders: 0,
          lastPurchaseDate: null
        }), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions9 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/analytics.ts
var onRequestGet15, onRequestOptions10;
var init_analytics = __esm({
  "api/admin/analytics.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet15 = /* @__PURE__ */ __name(async (context) => {
      try {
        const ordersStatsQuery = `
      SELECT 
        COUNT(*) as totalOrders,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completedOrders,
        SUM(CASE WHEN status = 'completed' THEN CAST(final_amount as REAL) ELSE 0 END) as totalRevenue
      FROM orders
    `;
        const usersStatsQuery = `
      SELECT 
        COUNT(*) as totalUsers,
        COUNT(CASE WHEN is_premium = 1 THEN 1 END) as premiumUsers
      FROM users
    `;
        const [ordersStats, usersStats] = await Promise.all([
          context.env.DB.prepare(ordersStatsQuery).first(),
          context.env.DB.prepare(usersStatsQuery).first()
        ]);
        const analytics = {
          totalRevenue: Number(ordersStats?.totalRevenue) || 0,
          totalSales: Number(ordersStats?.completedOrders) || 0,
          activeCustomers: Number(usersStats?.totalUsers) || 0,
          avgRating: 4.9
          // Static rating
        };
        return new Response(JSON.stringify({
          success: true,
          ...analytics
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type"
          }
        });
      } catch (error) {
        console.error("Failed to get analytics:", error);
        return new Response(JSON.stringify({
          success: false,
          message: "Failed to load analytics",
          totalRevenue: 0,
          totalSales: 0,
          activeCustomers: 0,
          avgRating: 4.9
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions10 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/announcement-badges.ts
var onRequestOptions11, onRequestGet16, onRequestPost4, onRequestPut6, onRequestDelete3;
var init_announcement_badges = __esm({
  "api/admin/announcement-badges.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_settings_storage();
    onRequestOptions11 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
    onRequestGet16 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const badgesData = await settingsStorage.getSetting("announcement_badges");
        const badges = badgesData ? JSON.parse(badgesData) : [];
        console.log("Retrieved announcement badges:", badges.length);
        return new Response(JSON.stringify(badges), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error fetching announcement badges:", error);
        return new Response(JSON.stringify({
          error: "Failed to fetch announcement badges",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestPost4 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const requestData = await context.request.json();
        console.log("Creating new announcement badge:", JSON.stringify(requestData, null, 2));
        const newBadge = {
          id: crypto.randomUUID(),
          title: requestData.title || requestData.text || requestData.badgeText || requestData.content || requestData.message || "",
          subtitle: requestData.subtitle || "",
          backgroundColor: requestData.backgroundColor || requestData.bgColor || requestData.background || "#007cba",
          textColor: requestData.textColor || requestData.color || requestData.foreground || "#ffffff",
          priority: parseInt(requestData.priority) || 1,
          isActive: requestData.isActive !== void 0 ? Boolean(requestData.isActive) : requestData.enabled !== void 0 ? Boolean(requestData.enabled) : true,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        console.log("Created badge object:", JSON.stringify(newBadge, null, 2));
        if (requestData.autoTranslate !== false && newBadge.title) {
          try {
            let openaiApiKey = context.env.OPENAI_API_KEY;
            if (!openaiApiKey) {
              const apiKeySetting = await settingsStorage.getSetting("openai_api_key");
              openaiApiKey = apiKeySetting;
            }
            if (openaiApiKey) {
              const supportedLanguages = ["de", "fr", "es", "it", "pt", "nl", "da", "no", "fi", "tr", "pl", "ru"];
              const translationResponse = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: {
                  "Authorization": `Bearer ${openaiApiKey}`,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify({
                  model: "gpt-4o",
                  messages: [
                    {
                      role: "system",
                      content: "You are a professional translator specializing in marketing content. Provide accurate, culturally appropriate translations that maintain the marketing impact of the original text."
                    },
                    {
                      role: "user",
                      content: `Translate the following announcement badge text into multiple languages.

Original text (English): "${newBadge.title}"
Context: Announcement badge for a Chrome extension product website
Target languages: ${supportedLanguages.map((code) => `${code}: ${{ "de": "German", "fr": "French", "es": "Spanish", "it": "Italian", "pt": "Portuguese", "nl": "Dutch", "da": "Danish", "no": "Norwegian", "fi": "Finnish", "tr": "Turkish", "pl": "Polish", "ru": "Russian" }[code]}`).join(", ")}
Tone: Marketing/promotional tone

Requirements:
- Maintain the marketing/promotional tone
- Keep the same emotional impact as the original
- Adapt cultural nuances appropriately for each target market
- Keep translations concise and impactful for badge display
- Ensure translations sound natural to native speakers

Respond with a JSON object where keys are language codes (${supportedLanguages.join(", ")}) and values are the translated text.

Example format:
{
  "de": "German translation here",
  "fr": "French translation here"
}`
                    }
                  ],
                  response_format: { type: "json_object" },
                  temperature: 0.3,
                  max_tokens: 1e3
                })
              });
              if (translationResponse.ok) {
                const data = await translationResponse.json();
                const translationText = data.choices[0]?.message?.content;
                if (translationText) {
                  const translations = JSON.parse(translationText);
                  newBadge.textTranslations = translations;
                  console.log("Auto-translated badge to languages:", Object.keys(translations));
                }
              }
            }
          } catch (translationError) {
            console.warn("Auto-translation failed, continuing without translations:", translationError);
          }
        }
        const existingBadgesData = await settingsStorage.getSetting("announcement_badges");
        const existingBadges = existingBadgesData ? JSON.parse(existingBadgesData) : [];
        existingBadges.push(newBadge);
        await settingsStorage.setSetting("announcement_badges", JSON.stringify(existingBadges));
        console.log("Created announcement badge:", newBadge.id);
        return new Response(JSON.stringify({ badge: newBadge }), {
          status: 201,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error creating announcement badge:", error);
        return new Response(JSON.stringify({
          error: "Failed to create announcement badge",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
    onRequestPut6 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const requestData = await context.request.json();
        const badgeId = requestData.id;
        if (!badgeId) {
          return new Response(JSON.stringify({ error: "Badge ID is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        console.log("Updating announcement badge:", badgeId);
        const existingBadgesData = await settingsStorage.getSetting("announcement_badges");
        const existingBadges = existingBadgesData ? JSON.parse(existingBadgesData) : [];
        const badgeIndex = existingBadges.findIndex((badge) => badge.id === badgeId);
        if (badgeIndex === -1) {
          return new Response(JSON.stringify({ error: "Badge not found" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        existingBadges[badgeIndex] = {
          ...existingBadges[badgeIndex],
          title: requestData.title || requestData.text || requestData.badgeText || existingBadges[badgeIndex].title,
          subtitle: requestData.subtitle || existingBadges[badgeIndex].subtitle,
          backgroundColor: requestData.backgroundColor || requestData.bgColor || existingBadges[badgeIndex].backgroundColor,
          textColor: requestData.textColor || requestData.color || existingBadges[badgeIndex].textColor,
          priority: requestData.priority ? parseInt(requestData.priority) : existingBadges[badgeIndex].priority,
          isActive: requestData.isActive !== void 0 ? requestData.isActive : existingBadges[badgeIndex].isActive,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        await settingsStorage.setSetting("announcement_badges", JSON.stringify(existingBadges));
        console.log("Updated announcement badge:", badgeId);
        return new Response(JSON.stringify({ badge: existingBadges[badgeIndex] }), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error updating announcement badge:", error);
        return new Response(JSON.stringify({
          error: "Failed to update announcement badge",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPut");
    onRequestDelete3 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const url = new URL(context.request.url);
        const badgeId = url.searchParams.get("id");
        if (!badgeId) {
          return new Response(JSON.stringify({ error: "Badge ID is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        console.log("Deleting announcement badge:", badgeId);
        const existingBadgesData = await settingsStorage.getSetting("announcement_badges");
        const existingBadges = existingBadgesData ? JSON.parse(existingBadgesData) : [];
        const updatedBadges = existingBadges.filter((badge) => badge.id !== badgeId);
        if (updatedBadges.length === existingBadges.length) {
          return new Response(JSON.stringify({ error: "Badge not found" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        await settingsStorage.setSetting("announcement_badges", JSON.stringify(updatedBadges));
        console.log("Deleted announcement badge:", badgeId);
        return new Response(JSON.stringify({ success: true }), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error deleting announcement badge:", error);
        return new Response(JSON.stringify({
          error: "Failed to delete announcement badge",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestDelete");
  }
});

// api/admin/auth-settings.ts
var onRequestGet17, onRequestPut7, onRequestOptions12;
var init_auth_settings = __esm({
  "api/admin/auth-settings.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet17 = /* @__PURE__ */ __name(async (context) => {
      const { env } = context;
      try {
        const selectQuery = `SELECT * FROM auth_settings WHERE id = 1`;
        const result = await env.DB.prepare(selectQuery).first();
        if (!result) {
          const defaultSettings2 = {
            googleEnabled: false,
            facebookEnabled: false,
            githubEnabled: false,
            recaptchaEnabled: false,
            recaptchaCustomerEnabled: false,
            recaptchaAdminEnabled: false,
            recaptchaSiteKey: "",
            googleClientId: "",
            googleClientSecret: "",
            facebookAppId: "",
            facebookAppSecret: "",
            githubClientId: "",
            githubClientSecret: "",
            jwtSecret: "demo-jwt-secret",
            sessionTimeout: 3600
          };
          return new Response(JSON.stringify(defaultSettings2), {
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const authSettings2 = {
          googleEnabled: Boolean(result.google_enabled),
          facebookEnabled: Boolean(result.facebook_enabled),
          githubEnabled: Boolean(result.github_enabled),
          recaptchaEnabled: Boolean(result.recaptcha_enabled),
          recaptchaCustomerEnabled: Boolean(result.recaptcha_customer_enabled),
          recaptchaAdminEnabled: Boolean(result.recaptcha_admin_enabled),
          recaptchaSiteKey: result.recaptcha_site_key || "",
          googleClientId: result.google_client_id || "",
          googleClientSecret: result.google_client_secret || "",
          facebookAppId: result.facebook_app_id || "",
          facebookAppSecret: result.facebook_app_secret || "",
          githubClientId: result.github_client_id || "",
          githubClientSecret: result.github_client_secret || "",
          jwtSecret: result.jwt_secret || "demo-jwt-secret",
          sessionTimeout: result.session_timeout || 3600
        };
        return new Response(JSON.stringify(authSettings2), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error fetching auth settings:", error);
        return new Response(JSON.stringify({
          message: "Error fetching auth settings: " + error.message
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestPut7 = /* @__PURE__ */ __name(async (context) => {
      const { request, env } = context;
      try {
        const settings3 = await request.json();
        const updateData = {
          google_enabled: settings3.googleEnabled ? 1 : 0,
          google_client_id: settings3.googleClientId || null,
          google_client_secret: settings3.googleClientSecret || null,
          facebook_enabled: settings3.facebookEnabled ? 1 : 0,
          facebook_app_id: settings3.facebookAppId || null,
          facebook_app_secret: settings3.facebookAppSecret || null,
          github_enabled: settings3.githubEnabled ? 1 : 0,
          github_client_id: settings3.githubClientId || null,
          github_client_secret: settings3.githubClientSecret || null,
          recaptcha_enabled: settings3.recaptchaEnabled ? 1 : 0,
          recaptcha_site_key: settings3.recaptchaSiteKey || null,
          recaptcha_secret_key: settings3.recaptchaSecretKey || null,
          recaptcha_mode: settings3.recaptchaMode || "v2",
          recaptcha_customer_enabled: settings3.recaptchaCustomerEnabled ? 1 : 0,
          recaptcha_admin_enabled: settings3.recaptchaAdminEnabled ? 1 : 0,
          jwt_secret: settings3.jwtSecret || "demo-jwt-secret",
          session_timeout: settings3.sessionTimeout || 3600,
          stripe_enabled: settings3.stripeEnabled ? 1 : 0,
          stripe_public_key: settings3.stripePublicKey || null,
          stripe_secret_key: settings3.stripeSecretKey || null,
          updated_at: (/* @__PURE__ */ new Date()).toISOString()
        };
        const updateQuery = `
      UPDATE auth_settings 
      SET google_enabled = ?, google_client_id = ?, google_client_secret = ?,
          facebook_enabled = ?, facebook_app_id = ?, facebook_app_secret = ?,
          github_enabled = ?, github_client_id = ?, github_client_secret = ?,
          recaptcha_enabled = ?, recaptcha_site_key = ?, recaptcha_secret_key = ?,
          recaptcha_mode = ?, recaptcha_customer_enabled = ?, recaptcha_admin_enabled = ?,
          jwt_secret = ?, session_timeout = ?, stripe_enabled = ?, stripe_public_key = ?, 
          stripe_secret_key = ?, updated_at = ?
      WHERE id = 1
    `;
        await env.DB.prepare(updateQuery).bind(
          updateData.google_enabled,
          updateData.google_client_id,
          updateData.google_client_secret,
          updateData.facebook_enabled,
          updateData.facebook_app_id,
          updateData.facebook_app_secret,
          updateData.github_enabled,
          updateData.github_client_id,
          updateData.github_client_secret,
          updateData.recaptcha_enabled,
          updateData.recaptcha_site_key,
          updateData.recaptcha_secret_key,
          updateData.recaptcha_mode,
          updateData.recaptcha_customer_enabled,
          updateData.recaptcha_admin_enabled,
          updateData.jwt_secret,
          updateData.session_timeout,
          updateData.stripe_enabled,
          updateData.stripe_public_key,
          updateData.stripe_secret_key,
          updateData.updated_at
        ).run();
        const selectQuery = `SELECT * FROM auth_settings WHERE id = 1`;
        const result = await env.DB.prepare(selectQuery).first();
        const updatedSettings = {
          googleEnabled: Boolean(result.google_enabled),
          facebookEnabled: Boolean(result.facebook_enabled),
          githubEnabled: Boolean(result.github_enabled),
          recaptchaEnabled: Boolean(result.recaptcha_enabled),
          recaptchaCustomerEnabled: Boolean(result.recaptcha_customer_enabled),
          recaptchaAdminEnabled: Boolean(result.recaptcha_admin_enabled),
          recaptchaSiteKey: result.recaptcha_site_key || "",
          googleClientId: result.google_client_id || "",
          facebookAppId: result.facebook_app_id || "",
          githubClientId: result.github_client_id || ""
        };
        return new Response(JSON.stringify(updatedSettings), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error updating auth settings:", error);
        return new Response(JSON.stringify({
          success: false,
          message: "Failed to update authentication settings: " + error.message
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPut");
    onRequestOptions12 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, PUT, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/chat-settings.ts
var onRequestGet18, onRequestPut8, onRequestOptions13;
var init_chat_settings = __esm({
  "api/admin/chat-settings.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_settings_storage();
    onRequestGet18 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        if (!env.DB) {
          return new Response(JSON.stringify({
            success: false,
            message: "Database not available"
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const settingsStorage = new SettingsStorage(env.DB);
        await settingsStorage.initializeSettings();
        const settings3 = await settingsStorage.getChatSettings();
        return new Response(JSON.stringify({
          success: true,
          ...settings3
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Failed to get chat settings:", error);
        return new Response(JSON.stringify({
          success: false,
          message: "Failed to load chat settings"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestPut8 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        console.log("Chat settings PUT request received");
        console.log("Environment DB available:", !!env.DB);
        if (!env.DB) {
          console.error("Database not available in environment");
          return new Response(JSON.stringify({
            success: false,
            message: "Database not available"
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const requestBody = await request.json();
        console.log("Request body received:", requestBody);
        const { openaiApiKey, assistantId, chatModel, enabled } = requestBody;
        console.log("Initializing settings storage...");
        const settingsStorage = new SettingsStorage(env.DB);
        try {
          await settingsStorage.initializeSettings();
          console.log("Settings storage initialized successfully");
        } catch (initError) {
          console.error("Failed to initialize settings storage:", initError);
          throw initError;
        }
        const settingsToUpdate = {};
        if (openaiApiKey && openaiApiKey.trim() !== "" && openaiApiKey !== "***hidden***") {
          settingsToUpdate.openaiApiKey = openaiApiKey.trim();
        }
        if (assistantId !== void 0) {
          settingsToUpdate.assistantId = assistantId;
        }
        if (chatModel && chatModel.trim() !== "") {
          settingsToUpdate.chatModel = chatModel.trim();
        }
        if (enabled !== void 0) {
          settingsToUpdate.enabled = enabled;
        }
        console.log("Settings to update:", settingsToUpdate);
        try {
          await settingsStorage.setChatSettings(settingsToUpdate);
          console.log("Settings updated successfully");
        } catch (updateError) {
          console.error("Failed to update settings:", updateError);
          throw updateError;
        }
        return new Response(JSON.stringify({
          success: true,
          message: "Chat settings updated successfully"
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Chat settings PUT error:", error);
        console.error("Error stack:", error.stack);
        return new Response(JSON.stringify({
          success: false,
          message: `Failed to update chat settings: ${error.message || error}`,
          error: error.toString()
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPut");
    onRequestOptions13 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, PUT, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/check-user-data.ts
function json7(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var onRequestGet19;
var init_check_user_data = __esm({
  "api/admin/check-user-data.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json7, "json");
    onRequestGet19 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const url = new URL(request.url);
        const email = url.searchParams.get("email");
        if (!email) {
          return json7({ success: false, message: "Email required" }, 400);
        }
        if (!env.DB) {
          return json7({ success: false, message: "Database not available" }, 500);
        }
        const user = await env.DB.prepare(`
      SELECT id, email, name, is_premium, extension_activated, premium_activated_at, created_at
      FROM users WHERE email = ?
    `).bind(email).first();
        const customer = await env.DB.prepare(`
      SELECT id, email, name, is_premium, extension_activated, created_at
      FROM customers WHERE email = ?
    `).bind(email).first();
        const orders2 = await env.DB.prepare(`
      SELECT id, customer_id, customer_email, original_amount, final_amount, status, created_at, completed_at
      FROM orders WHERE customer_email = ?
    `).bind(email).all();
        const invoices2 = await env.DB.prepare(`
      SELECT id, invoice_number, customer_id, order_id, amount, status, created_at
      FROM invoices WHERE customer_id IN (
        SELECT id FROM customers WHERE email = ?
        UNION
        SELECT id FROM users WHERE email = ?
      )
    `).bind(email, email).all();
        return json7({
          success: true,
          email,
          user,
          customer,
          orders: orders2.results,
          invoices: invoices2.results,
          summary: {
            userExists: !!user,
            customerExists: !!customer,
            userPremium: user?.is_premium === 1,
            customerPremium: customer?.is_premium === 1,
            userExtensionActivated: user?.extension_activated === 1,
            customerExtensionActivated: customer?.extension_activated === 1,
            totalOrders: orders2.results?.length || 0,
            totalInvoices: invoices2.results?.length || 0
          }
        });
      } catch (error) {
        console.error("Error checking user data:", error);
        return json7({
          success: false,
          message: error.message
        }, 500);
      }
    }, "onRequestGet");
  }
});

// api/admin/countdown-banners.ts
var onRequestOptions14, onRequestGet20, onRequestPost5, onRequestPut9, onRequestDelete4;
var init_countdown_banners = __esm({
  "api/admin/countdown-banners.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_settings_storage();
    onRequestOptions14 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
    onRequestGet20 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const bannersData = await settingsStorage.getSetting("countdown_banners");
        const banners = bannersData ? JSON.parse(bannersData) : [];
        console.log("Retrieved countdown banners:", banners.length);
        return new Response(JSON.stringify(banners), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error fetching countdown banners:", error);
        return new Response(JSON.stringify({
          error: "Failed to fetch countdown banners",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestPost5 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const requestData = await context.request.json();
        console.log("Creating new countdown banner:", requestData);
        const newBanner = {
          id: crypto.randomUUID(),
          title: requestData.title || "",
          subtitle: requestData.subtitle || "",
          targetPrice: parseFloat(requestData.targetPrice) || 0,
          originalPrice: parseFloat(requestData.originalPrice) || 0,
          endDate: requestData.endDate || new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3).toISOString(),
          priority: requestData.priority || 1,
          backgroundColor: requestData.backgroundColor || "#007cba",
          textColor: requestData.textColor || "#ffffff",
          isActive: requestData.isActive !== false,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        if (requestData.autoTranslate !== false && (newBanner.title || newBanner.subtitle)) {
          try {
            let openaiApiKey = context.env.OPENAI_API_KEY;
            if (!openaiApiKey) {
              const apiKeySetting = await settingsStorage.getSetting("openai_api_key");
              openaiApiKey = apiKeySetting || void 0;
            }
            if (openaiApiKey) {
              const supportedLanguages = ["de", "fr", "es", "it", "pt", "nl", "da", "no", "fi", "tr", "pl", "ru"];
              const translationPromises = [];
              if (newBanner.title) {
                translationPromises.push(
                  fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST",
                    headers: {
                      "Authorization": `Bearer ${openaiApiKey}`,
                      "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                      model: "gpt-4o",
                      messages: [
                        {
                          role: "system",
                          content: "You are a professional translator specializing in marketing content. Provide accurate, culturally appropriate translations that maintain the marketing impact of the original text."
                        },
                        {
                          role: "user",
                          content: `Translate the following countdown banner title into multiple languages.

Original text (English): "${newBanner.title}"
Context: Countdown banner title for limited-time promotion on Chrome extension website
Target languages: ${supportedLanguages.map((code) => `${code}: ${{ "de": "German", "fr": "French", "es": "Spanish", "it": "Italian", "pt": "Portuguese", "nl": "Dutch", "da": "Danish", "no": "Norwegian", "fi": "Finnish", "tr": "Turkish", "pl": "Polish", "ru": "Russian" }[code]}`).join(", ")}
Tone: Urgent/promotional tone

Requirements:
- Maintain the urgent/promotional tone
- Keep the same emotional impact as the original
- Adapt cultural nuances appropriately for each target market
- Keep translations concise and impactful for banner display
- Ensure translations sound natural to native speakers

Respond with a JSON object where keys are language codes (${supportedLanguages.join(", ")}) and values are the translated text.

Example format:
{
  "de": "German translation here",
  "fr": "French translation here"
}`
                        }
                      ],
                      response_format: { type: "json_object" },
                      temperature: 0.3,
                      max_tokens: 1e3
                    })
                  })
                );
              }
              if (newBanner.subtitle) {
                translationPromises.push(
                  fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST",
                    headers: {
                      "Authorization": `Bearer ${openaiApiKey}`,
                      "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                      model: "gpt-4o",
                      messages: [
                        {
                          role: "system",
                          content: "You are a professional translator specializing in marketing content. Provide accurate, culturally appropriate translations that maintain the marketing impact of the original text."
                        },
                        {
                          role: "user",
                          content: `Translate the following countdown banner subtitle into multiple languages.

Original text (English): "${newBanner.subtitle}"
Context: Countdown banner subtitle describing promotional offer on Chrome extension website
Target languages: ${supportedLanguages.map((code) => `${code}: ${{ "de": "German", "fr": "French", "es": "Spanish", "it": "Italian", "pt": "Portuguese", "nl": "Dutch", "da": "Danish", "no": "Norwegian", "fi": "Finnish", "tr": "Turkish", "pl": "Polish", "ru": "Russian" }[code]}`).join(", ")}
Tone: Marketing/promotional tone

Requirements:
- Maintain the marketing/promotional tone
- Keep the same emotional impact as the original
- Adapt cultural nuances appropriately for each target market
- Keep translations concise and impactful for banner display
- Ensure translations sound natural to native speakers

Respond with a JSON object where keys are language codes (${supportedLanguages.join(", ")}) and values are the translated text.

Example format:
{
  "de": "German translation here",
  "fr": "French translation here"
}`
                        }
                      ],
                      response_format: { type: "json_object" },
                      temperature: 0.3,
                      max_tokens: 1e3
                    })
                  })
                );
              }
              const responses = await Promise.all(translationPromises);
              const translations = {};
              if (responses[0] && responses[0].ok) {
                const titleData = await responses[0].json();
                const titleTranslations = JSON.parse(titleData.choices[0]?.message?.content || "{}");
                translations.titleTranslations = titleTranslations;
              }
              if (responses[1] && responses[1].ok) {
                const subtitleData = await responses[1].json();
                const subtitleTranslations = JSON.parse(subtitleData.choices[0]?.message?.content || "{}");
                translations.subtitleTranslations = subtitleTranslations;
              }
              Object.assign(newBanner, translations);
              console.log("Auto-translated banner to languages:", Object.keys(translations));
            }
          } catch (translationError) {
            console.warn("Auto-translation failed, continuing without translations:", translationError);
          }
        }
        const existingBannersData = await settingsStorage.getSetting("countdown_banners");
        const existingBanners = existingBannersData ? JSON.parse(existingBannersData) : [];
        existingBanners.push(newBanner);
        await settingsStorage.setSetting("countdown_banners", JSON.stringify(existingBanners));
        console.log("Created countdown banner:", newBanner.id);
        return new Response(JSON.stringify({ banner: newBanner }), {
          status: 201,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error creating countdown banner:", error);
        return new Response(JSON.stringify({
          error: "Failed to create countdown banner",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
    onRequestPut9 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const requestData = await context.request.json();
        const bannerId = requestData.id;
        if (!bannerId) {
          return new Response(JSON.stringify({ error: "Banner ID is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        console.log("Updating countdown banner:", bannerId);
        const existingBannersData = await settingsStorage.getSetting("countdown_banners");
        const existingBanners = existingBannersData ? JSON.parse(existingBannersData) : [];
        const bannerIndex = existingBanners.findIndex((banner) => banner.id === bannerId);
        if (bannerIndex === -1) {
          return new Response(JSON.stringify({ error: "Banner not found" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        existingBanners[bannerIndex] = {
          ...existingBanners[bannerIndex],
          ...requestData,
          targetPrice: requestData.targetPrice ? parseFloat(requestData.targetPrice) : existingBanners[bannerIndex].targetPrice,
          originalPrice: requestData.originalPrice ? parseFloat(requestData.originalPrice) : existingBanners[bannerIndex].originalPrice,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        await settingsStorage.setSetting("countdown_banners", JSON.stringify(existingBanners));
        console.log("Updated countdown banner:", bannerId);
        return new Response(JSON.stringify({ banner: existingBanners[bannerIndex] }), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error updating countdown banner:", error);
        return new Response(JSON.stringify({
          error: "Failed to update countdown banner",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPut");
    onRequestDelete4 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const url = new URL(context.request.url);
        const bannerId = url.searchParams.get("id");
        if (!bannerId) {
          return new Response(JSON.stringify({ error: "Banner ID is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        console.log("Deleting countdown banner:", bannerId);
        const existingBannersData = await settingsStorage.getSetting("countdown_banners");
        const existingBanners = existingBannersData ? JSON.parse(existingBannersData) : [];
        const updatedBanners = existingBanners.filter((banner) => banner.id !== bannerId);
        if (updatedBanners.length === existingBanners.length) {
          return new Response(JSON.stringify({ error: "Banner not found" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        await settingsStorage.setSetting("countdown_banners", JSON.stringify(updatedBanners));
        console.log("Deleted countdown banner:", bannerId);
        return new Response(JSON.stringify({ success: true }), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error deleting countdown banner:", error);
        return new Response(JSON.stringify({
          error: "Failed to delete countdown banner",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestDelete");
  }
});

// api/admin/create-default-banner.ts
var onRequestPost6, onRequestOptions15;
var init_create_default_banner = __esm({
  "api/admin/create-default-banner.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestPost6 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        const existingBanner = await env.DB.prepare(`
      SELECT id FROM countdown_banners 
      WHERE isActive = 1 
      LIMIT 1
    `).first();
        if (existingBanner) {
          return new Response(JSON.stringify({
            success: true,
            message: "Active banner already exists",
            bannerId: existingBanner.id
          }), {
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const endDate = /* @__PURE__ */ new Date();
        endDate.setDate(endDate.getDate() + 7);
        await env.DB.prepare(`
      UPDATE countdown_banners 
      SET targetPrice = '1.00' 
      WHERE id = 1
    `).run();
        const result = await env.DB.prepare(`
      INSERT INTO countdown_banners (
        titleEn, subtitleEn, titleTranslations, subtitleTranslations,
        targetPrice, originalPrice, endDateTime, isEnabled, backgroundColor, textColor, priority
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
          "Limited Time Offer!",
          "Get OCUS Job Hunter Extension at Special Price",
          "{}",
          "{}",
          "1.00",
          "299.99",
          endDate.toISOString(),
          1,
          "#FF6B35",
          "#FFFFFF",
          1
        ).run();
        return new Response(JSON.stringify({
          success: true,
          message: "Default countdown banner created successfully",
          bannerId: result.meta.last_row_id
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error creating default banner:", error);
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to create default banner",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
    onRequestOptions15 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/customers.ts
var onRequestGet21, onRequestOptions16;
var init_customers = __esm({
  "api/admin/customers.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_user_storage();
    onRequestGet21 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        const userStorage = new UserStorage(env.DB);
        await userStorage.initializeUsers();
        const customers2 = await userStorage.getAllCustomers();
        return new Response(JSON.stringify({
          success: true,
          customers: customers2
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Failed to get customers:", error);
        return new Response(JSON.stringify({
          success: false,
          message: "Failed to load customers"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions16 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/dashboard-features.ts
var FeatureStorage, onRequestGet22, onRequestPut10, onRequestOptions17;
var init_dashboard_features = __esm({
  "api/admin/dashboard-features.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    FeatureStorage = class {
      static {
        __name(this, "FeatureStorage");
      }
      db;
      constructor(db) {
        this.db = db;
      }
      async getFeatureStates() {
        try {
          const result = await this.db.prepare(`
        SELECT feature_name, is_enabled 
        FROM dashboard_features
      `).all();
          const states = {
            "affiliate-program": true,
            "analytics": true,
            "billing": true
          };
          if (result.results) {
            result.results.forEach((row) => {
              states[row.feature_name] = Boolean(row.is_enabled);
            });
          }
          return states;
        } catch (error) {
          console.error("Failed to get feature states:", error);
          return {
            "affiliate-program": true,
            "analytics": true,
            "billing": true
          };
        }
      }
      async updateFeatureState(featureName, isEnabled) {
        try {
          await this.db.prepare(`
        INSERT OR REPLACE INTO dashboard_features (feature_name, is_enabled, updated_at)
        VALUES (?, ?, datetime('now'))
      `).bind(featureName, isEnabled ? 1 : 0).run();
        } catch (error) {
          console.error("Failed to update feature state:", error);
          throw error;
        }
      }
      async initializeFeatures() {
        try {
          await this.db.prepare(`
        CREATE TABLE IF NOT EXISTS dashboard_features (
          feature_name TEXT PRIMARY KEY,
          is_enabled INTEGER DEFAULT 1,
          updated_at TEXT DEFAULT (datetime('now'))
        )
      `).run();
          const defaultFeatures = ["affiliate-program", "analytics", "billing"];
          for (const feature of defaultFeatures) {
            await this.db.prepare(`
          INSERT OR IGNORE INTO dashboard_features (feature_name, is_enabled)
          VALUES (?, 1)
        `).bind(feature).run();
          }
        } catch (error) {
          console.error("Failed to initialize features:", error);
        }
      }
    };
    onRequestGet22 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        const storage2 = new FeatureStorage(env.DB);
        await storage2.initializeFeatures();
        const states = await storage2.getFeatureStates();
        const features = [
          {
            id: "affiliate-program",
            name: "Affiliate Program",
            description: "Controls visibility of referral system and commission tracking",
            isEnabled: states["affiliate-program"],
            category: "monetization"
          },
          {
            id: "analytics",
            name: "Analytics",
            description: "Controls visibility of usage statistics and performance metrics",
            isEnabled: states["analytics"],
            category: "insights"
          },
          {
            id: "billing",
            name: "Billing",
            description: "Controls visibility of payment history and subscription management",
            isEnabled: states["billing"],
            category: "payments"
          }
        ];
        return new Response(JSON.stringify(features), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error getting features:", error);
        return new Response(JSON.stringify([]), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestPut10 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const { featureName, isEnabled } = await request.json();
        const storage2 = new FeatureStorage(env.DB);
        await storage2.updateFeatureState(featureName, isEnabled);
        return new Response(JSON.stringify({
          success: true,
          message: `Feature ${featureName} updated successfully`,
          feature: {
            id: featureName,
            isEnabled
          }
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          message: "Failed to update feature"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPut");
    onRequestOptions17 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, PUT, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/fix-banner-price.ts
var onRequestPost7;
var init_fix_banner_price = __esm({
  "api/admin/fix-banner-price.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestPost7 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        const updateResult = await env.DB.prepare(`
      UPDATE countdown_banners 
      SET targetPrice = '1.00'
      WHERE id = 1
    `).run();
        const updatedBanner = await env.DB.prepare(`
      SELECT id, targetPrice, originalPrice FROM countdown_banners WHERE id = 1
    `).first();
        return new Response(JSON.stringify({
          success: true,
          message: "Banner price updated to \u20AC1.00",
          updateResult: {
            success: updateResult.success,
            meta: updateResult.meta
          },
          banner: updatedBanner
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to update banner price",
          details: String(error)
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
  }
});

// api/admin/fix-existing-purchases.ts
function json8(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var onRequestPost8, onRequestOptions18;
var init_fix_existing_purchases = __esm({
  "api/admin/fix-existing-purchases.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json8, "json");
    onRequestPost8 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        if (!env.DB) {
          return json8({ success: false, message: "Database not available" }, 500);
        }
        const now = (/* @__PURE__ */ new Date()).toISOString();
        let updatedRecords = 0;
        const completedOrders = await env.DB.prepare(`
      SELECT DISTINCT customer_id, customer_email, customer_name, final_amount
      FROM orders 
      WHERE status = 'completed' AND final_amount > 0
    `).all();
        console.log("Found completed orders:", completedOrders.results?.length);
        if (completedOrders.results && completedOrders.results.length > 0) {
          for (const order of completedOrders.results) {
            const orderData = order;
            if (orderData.customer_id) {
              const customerUpdate = await env.DB.prepare(`
            UPDATE customers 
            SET is_premium = 1, 
                extension_activated = 1,
                total_spent = COALESCE(total_spent, 0) + ?,
                total_orders = COALESCE(total_orders, 0) + 1,
                updated_at = ?
            WHERE id = ? AND (is_premium != 1 OR extension_activated != 1)
          `).bind(orderData.final_amount, now, orderData.customer_id).run();
              if (customerUpdate.meta?.changes && customerUpdate.meta.changes > 0) {
                updatedRecords++;
                console.log("Updated customer:", orderData.customer_id);
              }
            }
            if (orderData.customer_email) {
              const userUpdate = await env.DB.prepare(`
            UPDATE users 
            SET is_premium = 1, 
                extension_activated = 1,
                premium_activated_at = ?,
                total_spent = COALESCE(total_spent, 0) + ?,
                total_orders = COALESCE(total_orders, 0) + 1
            WHERE email = ? AND (is_premium != 1 OR extension_activated != 1)
          `).bind(now, orderData.final_amount, orderData.customer_email).run();
              if (userUpdate.meta?.changes && userUpdate.meta.changes > 0) {
                updatedRecords++;
                console.log("Updated user:", orderData.customer_email);
              }
            }
          }
        }
        const missingPremiumCustomers = await env.DB.prepare(`
      SELECT c.id, c.email, c.name
      FROM customers c
      WHERE c.id IN (
        SELECT DISTINCT customer_id 
        FROM orders 
        WHERE status = 'completed' AND final_amount > 0
      ) AND (c.is_premium != 1 OR c.extension_activated != 1)
    `).all();
        if (missingPremiumCustomers.results && missingPremiumCustomers.results.length > 0) {
          for (const customer of missingPremiumCustomers.results) {
            const customerData = customer;
            await env.DB.prepare(`
          UPDATE customers 
          SET is_premium = 1, extension_activated = 1, updated_at = ?
          WHERE id = ?
        `).bind(now, customerData.id).run();
            updatedRecords++;
            console.log("Fixed missing premium status for customer:", customerData.id);
          }
        }
        return json8({
          success: true,
          message: `Updated ${updatedRecords} records with premium status`,
          updatedRecords
        });
      } catch (error) {
        console.error("Error fixing existing purchases:", error);
        return json8({
          success: false,
          message: "Failed to fix existing purchases",
          error: error.message
        }, 500);
      }
    }, "onRequestPost");
    onRequestOptions18 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/fix-premium-users.ts
var onRequestPost9;
var init_fix_premium_users = __esm({
  "api/admin/fix-premium-users.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestPost9 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const body = await request.json();
        if (body.adminKey !== "fix-premium-2024") {
          return new Response(JSON.stringify({
            success: false,
            message: "Invalid admin key"
          }), {
            status: 403,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        if (!env.DB) {
          return new Response(JSON.stringify({
            success: false,
            message: "Database not available"
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const results = {
          usersChecked: 0,
          customersChecked: 0,
          usersFixed: 0,
          customersFixed: 0,
          errors: []
        };
        const customersWithOrders = await env.DB.prepare(`
      SELECT DISTINCT c.id, c.email, c.name, c.is_premium, c.extension_activated,
             COUNT(o.id) as orderCount, SUM(o.final_amount) as totalPaid
      FROM customers c
      JOIN orders o ON c.id = o.customer_id
      WHERE o.status = 'completed' AND o.final_amount > 0
      GROUP BY c.id, c.email, c.name, c.is_premium, c.extension_activated
    `).all();
        console.log("Found customers with completed orders:", customersWithOrders.results?.length);
        for (const customer of customersWithOrders.results || []) {
          results.customersChecked++;
          const needsUpdate = customer.is_premium !== 1 || customer.extension_activated !== 1;
          if (needsUpdate) {
            try {
              await env.DB.prepare(`
            UPDATE customers 
            SET is_premium = 1, extension_activated = 1, premium_activated_at = datetime('now')
            WHERE id = ?
          `).bind(customer.id).run();
              results.customersFixed++;
              console.log(`Fixed customer ${customer.email} (ID: ${customer.id})`);
            } catch (error) {
              results.errors.push(`Failed to fix customer ${customer.email}: ${error.message}`);
            }
          }
        }
        const usersWithOrders = await env.DB.prepare(`
      SELECT DISTINCT u.id, u.email, u.name, u.is_premium, u.extension_activated,
             COUNT(o.id) as orderCount, SUM(o.final_amount) as totalPaid
      FROM users u
      JOIN orders o ON u.email = o.customer_email
      WHERE o.status = 'completed' AND o.final_amount > 0
      GROUP BY u.id, u.email, u.name, u.is_premium, u.extension_activated
    `).all();
        console.log("Found users with completed orders:", usersWithOrders.results?.length);
        for (const user of usersWithOrders.results || []) {
          results.usersChecked++;
          const needsUpdate = user.is_premium !== 1 || user.extension_activated !== 1;
          if (needsUpdate) {
            try {
              await env.DB.prepare(`
            UPDATE users 
            SET is_premium = 1, extension_activated = 1, premium_activated_at = datetime('now')
            WHERE id = ?
          `).bind(user.id).run();
              results.usersFixed++;
              console.log(`Fixed user ${user.email} (ID: ${user.id})`);
            } catch (error) {
              results.errors.push(`Failed to fix user ${user.email}: ${error.message}`);
            }
          }
        }
        const customersNeedingCodes = await env.DB.prepare(`
      SELECT c.id, c.email
      FROM customers c
      WHERE c.is_premium = 1 AND c.extension_activated = 1
      AND NOT EXISTS (
        SELECT 1 FROM activation_codes ac WHERE ac.customer_id = c.id
      )
    `).all();
        let codesCreated = 0;
        for (const customer of customersNeedingCodes.results || []) {
          try {
            const activationCode = `OCUS-${Date.now()}-${Math.random().toString(36).substr(2, 8).toUpperCase()}`;
            await env.DB.prepare(`
          INSERT INTO activation_codes (customer_id, code, created_at)
          VALUES (?, ?, datetime('now'))
        `).bind(customer.id, activationCode).run();
            codesCreated++;
            console.log(`Created activation code for customer ${customer.email}`);
          } catch (error) {
            results.errors.push(`Failed to create activation code for ${customer.email}: ${error.message}`);
          }
        }
        return new Response(JSON.stringify({
          success: true,
          message: "Premium activation fix completed",
          results: {
            ...results,
            activationCodesCreated: codesCreated
          }
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error fixing premium users:", error);
        return new Response(JSON.stringify({
          success: false,
          message: error.message
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
  }
});

// api/admin/fix-purchased-users.ts
function json9(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var onRequestPost10;
var init_fix_purchased_users = __esm({
  "api/admin/fix-purchased-users.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json9, "json");
    onRequestPost10 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const body = await request.json();
        const { emails } = body;
        if (!emails || !Array.isArray(emails)) {
          return json9({ success: false, message: "Array of emails required" }, 400);
        }
        if (!env.DB) {
          return json9({ success: false, message: "Database not available" }, 500);
        }
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const results = [];
        for (const email of emails) {
          try {
            const user = await env.DB.prepare(`
          SELECT id, email, name FROM users WHERE email = ?
        `).bind(email).first();
            if (user) {
              await env.DB.prepare(`
            UPDATE users 
            SET is_premium = 1,
                extension_activated = 1,
                premium_activated_at = ?
            WHERE email = ?
          `).bind(now, email).run();
              results.push({
                email,
                status: "updated",
                message: "User premium status activated"
              });
            } else {
              results.push({
                email,
                status: "not_found",
                message: "User not found in users table"
              });
            }
          } catch (error) {
            results.push({
              email,
              status: "error",
              message: error.message
            });
          }
        }
        return json9({
          success: true,
          message: "Batch update completed",
          results
        });
      } catch (error) {
        console.error("Error fixing purchased users:", error);
        return json9({
          success: false,
          message: error.message
        }, 500);
      }
    }, "onRequestPost");
  }
});

// api/admin/force-update-price.ts
var onRequestGet23;
var init_force_update_price = __esm({
  "api/admin/force-update-price.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet23 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        const updateResult = await env.DB.prepare(`
      UPDATE countdown_banners 
      SET targetPrice = '1.00'
      WHERE id = 1
    `).run();
        const banner = await env.DB.prepare(`
      SELECT id, targetPrice, originalPrice FROM countdown_banners WHERE id = 1
    `).first();
        return new Response(JSON.stringify({
          success: true,
          message: "Banner price force updated to \u20AC1.00",
          updateResult: {
            success: updateResult.success,
            meta: updateResult.meta
          },
          currentBanner: banner
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to update banner price",
          details: String(error)
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
  }
});

// api/admin/invoices.ts
var onRequestGet24, onRequestOptions19;
var init_invoices2 = __esm({
  "api/admin/invoices.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet24 = /* @__PURE__ */ __name(async (context) => {
      try {
        const invoicesQuery = `
      SELECT 
        i.id,
        i.invoice_number,
        i.order_id,
        i.customer_id,
        i.total_amount as amount,
        i.currency,
        i.tax_amount,
        i.status,
        i.invoice_date,
        i.due_date,
        i.paid_at,
        i.created_at,
        i.customer_name,
        i.customer_email,
        o.payment_method
      FROM invoices i
      LEFT JOIN orders o ON i.order_id = o.id
      ORDER BY i.created_at DESC
    `;
        const invoicesResult = await context.env.DB.prepare(invoicesQuery).all();
        return new Response(JSON.stringify(invoicesResult.results || []), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type"
          }
        });
      } catch (error) {
        console.error("Error fetching admin invoices:", error);
        return new Response(JSON.stringify({ error: "Failed to fetch invoices" }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions19 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/login.ts
var onRequestPost11, onRequestOptions20;
var init_login = __esm({
  "api/admin/login.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestPost11 = /* @__PURE__ */ __name(async ({ request }) => {
      try {
        const { username, password, recaptchaToken } = await request.json();
        if (username === "admin" && password === "admin123") {
          return new Response(JSON.stringify({
            success: true,
            user: {
              id: 1,
              username: "admin",
              role: "admin"
            },
            token: "demo-admin-jwt-token"
          }), {
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        return new Response(JSON.stringify({
          success: false,
          message: "Invalid credentials"
        }), {
          status: 401,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          message: "Login failed"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
    onRequestOptions20 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/orders.ts
var onRequestGet25, onRequestOptions21;
var init_orders2 = __esm({
  "api/admin/orders.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet25 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        let orders2 = [];
        let stats = {
          totalOrders: 0,
          totalRevenue: 0,
          completedOrders: 0,
          pendingOrders: 0
        };
        try {
          const orderResults = await env.DB.prepare(`
        SELECT 
          id, 
          customer_email as customerEmail, 
          customer_name as customerName, 
          product_id as productId,
          original_amount as originalAmount, 
          final_amount as finalAmount, 
          currency, 
          status, 
          payment_method as paymentMethod,
          download_token as downloadToken, 
          download_count as downloadCount, 
          max_downloads as maxDownloads, 
          activation_code as activationCode,
          created_at as createdAt, 
          completed_at as completedAt
        FROM orders 
        ORDER BY created_at DESC
      `).all();
          orders2 = orderResults.results || [];
          const statsResult = await env.DB.prepare(`
        SELECT 
          COUNT(*) as totalOrders,
          SUM(CASE WHEN status = 'completed' THEN CAST(final_amount as REAL) ELSE 0 END) as totalRevenue,
          COUNT(CASE WHEN status = 'completed' THEN 1 END) as completedOrders,
          COUNT(CASE WHEN status = 'pending' THEN 1 END) as pendingOrders
        FROM orders
      `).first();
          if (statsResult) {
            stats = {
              totalOrders: Number(statsResult.totalOrders) || 0,
              totalRevenue: Number(statsResult.totalRevenue) || 0,
              completedOrders: Number(statsResult.completedOrders) || 0,
              pendingOrders: Number(statsResult.pendingOrders) || 0
            };
          }
        } catch (dbError) {
          console.log("Orders table not found, checking fallback storage:", dbError);
          const settingsResults = await env.DB.prepare(`
        SELECT key, value FROM settings 
        WHERE key LIKE 'order_%'
      `).all();
          const allOrders = [];
          for (const setting of settingsResults.results || []) {
            try {
              const orderData = JSON.parse(setting.value);
              allOrders.push(orderData);
            } catch (parseError) {
              console.log("Error parsing order data:", parseError);
            }
          }
          orders2 = allOrders.sort((a, b) => {
            const dateA = new Date(a.completedAt || a.createdAt);
            const dateB = new Date(b.completedAt || b.createdAt);
            return dateB.getTime() - dateA.getTime();
          });
          stats.totalOrders = orders2.length;
          stats.completedOrders = orders2.filter((o) => o.status === "completed").length;
          stats.pendingOrders = orders2.filter((o) => o.status === "pending").length;
          stats.totalRevenue = orders2.filter((o) => o.status === "completed").reduce((sum, o) => sum + (parseFloat(o.finalAmount) || 0), 0);
        }
        return new Response(JSON.stringify({
          success: true,
          orders: orders2,
          stats
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error fetching admin orders:", error);
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to fetch orders",
          details: String(error)
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions21 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/payment-settings.ts
var onRequestGet26, onRequestPut11, onRequestOptions22;
var init_payment_settings = __esm({
  "api/admin/payment-settings.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet26 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        const result = await env.DB.prepare(`
      SELECT key, value FROM settings 
      WHERE key LIKE 'payment_%'
    `).all();
        const settings3 = {
          stripeEnabled: false,
          paypalEnabled: false,
          stripePublicKey: "",
          stripeSecretKey: "",
          paypalClientId: "",
          paypalClientSecret: "",
          defaultPaymentMethod: "stripe"
        };
        result.results?.forEach((row) => {
          const key = row.key.replace("payment_", "");
          let value = row.value;
          if (value === "true") value = true;
          if (value === "false") value = false;
          settings3[key] = value;
        });
        return new Response(JSON.stringify(settings3), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error fetching payment settings:", error);
        const defaultSettings2 = {
          stripeEnabled: false,
          paypalEnabled: false,
          stripePublicKey: "",
          stripeSecretKey: "",
          paypalClientId: "",
          paypalClientSecret: "",
          defaultPaymentMethod: "stripe"
        };
        return new Response(JSON.stringify(defaultSettings2), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestPut11 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const settings3 = await request.json();
        const settingsToSave = [
          { key: "payment_stripeEnabled", value: String(settings3.stripeEnabled || false) },
          { key: "payment_paypalEnabled", value: String(settings3.paypalEnabled || false) },
          { key: "payment_stripePublicKey", value: settings3.stripePublicKey || "" },
          { key: "payment_stripeSecretKey", value: settings3.stripeSecretKey || "" },
          { key: "payment_paypalClientId", value: settings3.paypalClientId || "" },
          { key: "payment_paypalClientSecret", value: settings3.paypalClientSecret || "" },
          { key: "payment_defaultPaymentMethod", value: settings3.defaultPaymentMethod || "stripe" }
        ];
        await env.DB.batch([
          // First, delete existing payment settings
          env.DB.prepare(`DELETE FROM settings WHERE key LIKE 'payment_%'`),
          // Then insert new settings
          ...settingsToSave.map(
            (setting) => env.DB.prepare(`INSERT INTO settings (key, value) VALUES (?, ?)`).bind(setting.key, setting.value)
          )
        ]);
        return new Response(JSON.stringify({
          success: true,
          message: "Payment settings saved successfully",
          settings: settings3
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error saving payment settings:", error);
        return new Response(JSON.stringify({
          success: false,
          message: "Failed to save payment settings",
          error: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPut");
    onRequestOptions22 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, PUT, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/pricing.ts
async function onRequestGet27(context) {
  const { env } = context;
  try {
    if (!env.DB) {
      console.error("Database not available, returning default pricing");
      return new Response(JSON.stringify({
        id: 1,
        name: "OCUS Job Hunter Extension",
        price: "29.99",
        beforePrice: null
      }), {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }
    const selectQuery = `SELECT * FROM products WHERE id = 1 AND isActive = 1`;
    const result = await env.DB.prepare(selectQuery).first();
    if (!result) {
      console.log("No product found in database, returning default pricing");
      return new Response(JSON.stringify({
        id: 1,
        name: "OCUS Job Hunter Extension",
        price: "29.99",
        beforePrice: null
      }), {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }
    return new Response(JSON.stringify({
      id: result.id,
      name: result.name,
      price: result.price.toString(),
      beforePrice: result.beforePrice ? result.beforePrice.toString() : null
    }), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization"
      }
    });
  } catch (error) {
    console.error("Error fetching pricing:", error);
    return new Response(JSON.stringify({
      message: "Error fetching pricing: " + error.message
    }), {
      status: 500,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization"
      }
    });
  }
}
async function onRequestPut12(context) {
  const { request, env } = context;
  try {
    const body = await request.json();
    const { price, beforePrice } = body;
    if (!price || price <= 0) {
      return new Response(JSON.stringify({ message: "Valid price is required" }), {
        status: 400,
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }
    if (beforePrice && beforePrice <= price) {
      return new Response(JSON.stringify({ message: "Before price must be higher than current price" }), {
        status: 400,
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }
    const updateQuery = `
      INSERT OR REPLACE INTO products (id, name, price, beforePrice, updatedAt)
      VALUES (1, 'OCUS Job Hunter Extension', ?, ?, datetime('now'))
    `;
    await env.DB.prepare(updateQuery).bind(price, beforePrice || null).run();
    const selectQuery = `SELECT * FROM products WHERE id = 1`;
    const result = await env.DB.prepare(selectQuery).first();
    return new Response(JSON.stringify({
      success: true,
      product: result,
      message: "Pricing updated successfully"
    }), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization"
      }
    });
  } catch (error) {
    console.error("Error updating pricing:", error);
    return new Response(JSON.stringify({ message: "Error updating pricing: " + error.message }), {
      status: 500,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization"
      }
    });
  }
}
async function onRequestOptions23(context) {
  return new Response(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
var init_pricing = __esm({
  "api/admin/pricing.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(onRequestGet27, "onRequestGet");
    __name(onRequestPut12, "onRequestPut");
    __name(onRequestOptions23, "onRequestOptions");
  }
});

// api/admin/reset-db.ts
function toD1Batch(db, sql2) {
  return sql2.split(";").filter((query) => query.trim() !== "").map((query) => db.prepare(query));
}
var SCHEMA_SQL, onRequestPost12, onRequestOptions24;
var init_reset_db = __esm({
  "api/admin/reset-db.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    SCHEMA_SQL = `-- D1 Database Schema for OCUS Ticket System
-- Run: wrangler d1 execute ocus-tickets --file=./functions/schema.sql

-- Drop existing tables if they exist (for development)
DROP TABLE IF EXISTS ticket_messages;
DROP TABLE IF EXISTS tickets;
DROP TABLE IF EXISTS countdown_banners;
DROP TABLE IF EXISTS orders;
DROP TABLE IF EXISTS products;
DROP TABLE IF EXISTS auth_settings;
DROP TABLE IF EXISTS settings;
DROP TABLE IF EXISTS users;
DROP TABLE IF EXISTS customers;
DROP TABLE IF EXISTS invoices;
DROP TABLE IF EXISTS activation_codes;

CREATE TABLE IF NOT EXISTS tickets (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  category TEXT NOT NULL DEFAULT 'general',
  priority TEXT NOT NULL DEFAULT 'medium',
  status TEXT NOT NULL DEFAULT 'open',
  customer_email TEXT NOT NULL,
  customer_name TEXT NOT NULL,
  assigned_to_user_id INTEGER,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  resolved_at TEXT,
  archived_at TEXT
);

CREATE TABLE IF NOT EXISTS ticket_messages (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  ticket_id INTEGER NOT NULL,
  message TEXT NOT NULL,
  is_from_customer BOOLEAN NOT NULL DEFAULT 1,
  sender_name TEXT NOT NULL,
  sender_email TEXT,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY (ticket_id) REFERENCES tickets(id) ON DELETE CASCADE
);

-- Countdown Banners Table
CREATE TABLE IF NOT EXISTS countdown_banners (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  subtitle TEXT NOT NULL,
  titleTranslations TEXT,
  subtitleTranslations TEXT,
  targetPrice REAL NOT NULL,
  originalPrice REAL,
  endDate TEXT NOT NULL,
  priority INTEGER NOT NULL DEFAULT 0,
  backgroundColor TEXT NOT NULL DEFAULT '#000000',
  textColor TEXT NOT NULL DEFAULT '#ffffff',
  isActive BOOLEAN NOT NULL DEFAULT 0,
  createdAt TEXT NOT NULL DEFAULT (datetime('now')),
  updatedAt TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Products Table
CREATE TABLE IF NOT EXISTS products (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL DEFAULT 'OCUS Job Hunter Extension',
  price REAL NOT NULL,
  beforePrice REAL,
  description TEXT,
  isActive BOOLEAN NOT NULL DEFAULT 1,
  createdAt TEXT NOT NULL DEFAULT (datetime('now')),
  updatedAt TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Insert default product if not exists
INSERT OR IGNORE INTO products (id, name, price, beforePrice) 
VALUES (1, 'OCUS Job Hunter Extension', 250.00, NULL);

-- Auth Settings Table
CREATE TABLE IF NOT EXISTS auth_settings (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  google_enabled BOOLEAN DEFAULT 0,
  google_client_id TEXT,
  google_client_secret TEXT,
  facebook_enabled BOOLEAN DEFAULT 0,
  facebook_app_id TEXT,
  facebook_app_secret TEXT,
  github_enabled BOOLEAN DEFAULT 0,
  github_client_id TEXT,
  github_client_secret TEXT,
  recaptcha_enabled BOOLEAN DEFAULT 0,
  recaptcha_site_key TEXT,
  recaptcha_secret_key TEXT,
  recaptcha_mode TEXT DEFAULT 'v2',
  recaptcha_customer_enabled BOOLEAN DEFAULT 0,
  recaptcha_admin_enabled BOOLEAN DEFAULT 0,
  jwt_secret TEXT DEFAULT 'demo-jwt-secret',
  session_timeout INTEGER DEFAULT 3600,
  stripe_enabled BOOLEAN DEFAULT 0,
  stripe_public_key TEXT,
  stripe_secret_key TEXT,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Insert default auth settings if not exists
INSERT OR IGNORE INTO auth_settings (id) VALUES (1);

-- Generic Settings Table for flexible key-value storage
CREATE TABLE IF NOT EXISTS settings (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  key TEXT NOT NULL UNIQUE,
  value TEXT,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Orders/Purchases Table
CREATE TABLE IF NOT EXISTS orders (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  customerId INTEGER,
  customerEmail TEXT NOT NULL,
  customerName TEXT NOT NULL,
  productId INTEGER NOT NULL,
  productName TEXT NOT NULL,
  originalAmount REAL NOT NULL,
  finalAmount REAL NOT NULL,
  currency TEXT NOT NULL DEFAULT 'EUR',
  status TEXT NOT NULL DEFAULT 'pending',
  paymentMethod TEXT NOT NULL DEFAULT 'stripe',
  paymentIntentId TEXT,
  downloadToken TEXT UNIQUE,
  downloadCount INTEGER DEFAULT 0,
  maxDownloads INTEGER DEFAULT 5,
  activationCode TEXT,
  invoiceNumber TEXT UNIQUE,
  createdAt TEXT NOT NULL DEFAULT (datetime('now')),
  completedAt TEXT,
  FOREIGN KEY (productId) REFERENCES products(id)
);

-- Customers Table (renamed from users for clarity)
CREATE TABLE IF NOT EXISTS customers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  email TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  hashedPassword TEXT,
  isActive BOOLEAN DEFAULT 1,
  isPremium BOOLEAN DEFAULT 0, -- Deprecated, use extension_activated
  extension_activated BOOLEAN DEFAULT 0,
  registrationDate TEXT NOT NULL DEFAULT (datetime('now')),
  lastLoginAt TEXT,
  activationToken TEXT,
  passwordResetToken TEXT,
  createdAt TEXT NOT NULL DEFAULT (datetime('now')),
  updatedAt TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Create a view for backward compatibility if 'users' is still used elsewhere
CREATE VIEW IF NOT EXISTS users AS SELECT * FROM customers;

CREATE TABLE IF NOT EXISTS activation_codes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    order_id INTEGER NOT NULL,
    code TEXT NOT NULL UNIQUE,
    is_used BOOLEAN DEFAULT 0,
    created_at TEXT DEFAULT (datetime('now')),
    FOREIGN KEY (order_id) REFERENCES orders(id)
);

-- Invoices Table
CREATE TABLE IF NOT EXISTS invoices (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  orderId INTEGER NOT NULL,
  customerId INTEGER NOT NULL,
  invoiceNumber TEXT NOT NULL UNIQUE,
  amount REAL NOT NULL,
  currency TEXT NOT NULL DEFAULT 'EUR',
  taxAmount REAL DEFAULT 0,
  status TEXT NOT NULL DEFAULT 'unpaid', -- unpaid, paid, void
  invoiceDate TEXT NOT NULL DEFAULT (datetime('now')),
  dueDate TEXT,
  paidAt TEXT,
  pdfUrl TEXT,
  createdAt TEXT NOT NULL DEFAULT (datetime('now')),
  updatedAt TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY (orderId) REFERENCES orders(id),
  FOREIGN KEY (customerId) REFERENCES customers(id)
);


-- Index for settings lookup
CREATE INDEX IF NOT EXISTS idx_settings_key ON settings(key);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_tickets_customer_email ON tickets(customer_email);
CREATE INDEX IF NOT EXISTS idx_tickets_status ON tickets(status);
CREATE INDEX IF NOT EXISTS idx_tickets_created_at ON tickets(created_at);
CREATE INDEX IF NOT EXISTS idx_ticket_messages_ticket_id ON ticket_messages(ticket_id);
CREATE INDEX IF NOT EXISTS idx_ticket_messages_created_at ON ticket_messages(created_at);
CREATE INDEX IF NOT EXISTS idx_countdown_banners_active ON countdown_banners(isActive);
CREATE INDEX IF NOT EXISTS idx_countdown_banners_priority ON countdown_banners(priority);
CREATE INDEX IF NOT EXISTS idx_products_active ON products(isActive);
CREATE INDEX IF NOT EXISTS idx_orders_customer_email ON orders(customerEmail);
CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_created_at ON orders(createdAt);
CREATE INDEX IF NOT EXISTS idx_customers_email ON customers(email);
CREATE INDEX IF NOT EXISTS idx_customers_active ON customers(isActive);
CREATE INDEX IF NOT EXISTS idx_invoices_customer_id ON invoices(customerId);
CREATE INDEX IF NOT EXISTS idx_invoices_order_id ON invoices(orderId);
CREATE INDEX IF NOT EXISTS idx_orders_customer_id ON orders(customerId);
`;
    __name(toD1Batch, "toD1Batch");
    onRequestPost12 = /* @__PURE__ */ __name(async (context) => {
      const { request, env } = context;
      const adminSecret = request.headers.get("X-Admin-Secret");
      if (adminSecret !== "ocus-power-secret") {
        return new Response("Unauthorized", { status: 401 });
      }
      try {
        if (!env.DB) {
          return new Response("Database not available", { status: 500 });
        }
        const statements = toD1Batch(env.DB, SCHEMA_SQL);
        await env.DB.batch(statements);
        return new Response("Database reset and initialized successfully.", {
          status: 200,
          headers: { "Content-Type": "text/plain" }
        });
      } catch (error) {
        console.error("Database reset failed:", error);
        return new Response(`Database reset failed: ${error.message}`, {
          status: 500,
          headers: { "Content-Type": "text/plain" }
        });
      }
    }, "onRequestPost");
    onRequestOptions24 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 204,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, X-Admin-Secret"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/seo-settings.ts
var onRequestGet28, onRequestPut13, onRequestPatch, onRequestOptions25;
var init_seo_settings = __esm({
  "api/admin/seo-settings.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_settings_storage();
    onRequestGet28 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        if (!env.DB) {
          return new Response(JSON.stringify({
            success: false,
            message: "Database not available"
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const settingsStorage = new SettingsStorage(env.DB);
        await settingsStorage.initializeSettings();
        const title = await settingsStorage.getSetting("seo_title") || "OCUS Job Hunter";
        const description = await settingsStorage.getSetting("seo_description") || "Automated job application Chrome extension";
        const keywords = await settingsStorage.getSetting("seo_keywords") || "job hunting, automation, chrome extension";
        const coverImage = await settingsStorage.getSetting("seo_cover_image") || "";
        const logo = await settingsStorage.getSetting("seo_logo") || "";
        const favicon = await settingsStorage.getSetting("seo_favicon") || "";
        console.log("GET SEO Settings - Retrieved from DB:", {
          title,
          description,
          keywords,
          coverImage: coverImage ? "Has image data" : "No image",
          logo: logo ? "Has logo data" : "No logo",
          favicon: favicon ? "Has favicon data" : "No favicon"
        });
        return new Response(JSON.stringify({
          success: true,
          title,
          description,
          keywords,
          coverImage,
          logo,
          favicon
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Failed to get SEO settings:", error);
        return new Response(JSON.stringify({
          success: false,
          message: "Failed to load SEO settings"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestPut13 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        if (!env.DB) {
          return new Response(JSON.stringify({
            success: false,
            message: "Database not available"
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const formData = await request.formData();
        const settingsStorage = new SettingsStorage(env.DB);
        await settingsStorage.initializeSettings();
        console.log("FormData keys:", Array.from(formData.keys()));
        console.log("FormData entries:");
        for (const [key, value] of formData.entries()) {
          console.log(`${key}:`, value instanceof File ? `File(${value.name}, ${value.size} bytes)` : value);
        }
        const title = formData.get("title")?.toString();
        const description = formData.get("description")?.toString();
        const keywords = formData.get("keywords")?.toString();
        if (title) {
          await settingsStorage.setSetting("seo_title", title);
        }
        if (description) {
          await settingsStorage.setSetting("seo_description", description);
        }
        if (keywords) {
          await settingsStorage.setSetting("seo_keywords", keywords);
        }
        const coverImageFile = formData.get("coverImage");
        const logoFile = formData.get("logo");
        const faviconFile = formData.get("favicon");
        console.log("File uploads check:", {
          coverImage: coverImageFile ? `${coverImageFile.name} (${coverImageFile.size} bytes)` : "null",
          logo: logoFile ? `${logoFile.name} (${logoFile.size} bytes)` : "null",
          favicon: faviconFile ? `${faviconFile.name} (${faviconFile.size} bytes)` : "null"
        });
        if (coverImageFile && coverImageFile.size > 0) {
          console.log("Processing cover image:", coverImageFile.name, coverImageFile.type, coverImageFile.size);
          const arrayBuffer = await coverImageFile.arrayBuffer();
          const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
          const dataUrl = `data:${coverImageFile.type};base64,${base64}`;
          console.log("Saving cover image to DB, data URL length:", dataUrl.length);
          await settingsStorage.setSetting("seo_cover_image", dataUrl);
          console.log("Cover image saved successfully");
        }
        if (logoFile && logoFile.size > 0) {
          const arrayBuffer = await logoFile.arrayBuffer();
          const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
          const dataUrl = `data:${logoFile.type};base64,${base64}`;
          await settingsStorage.setSetting("seo_logo", dataUrl);
        }
        if (faviconFile && faviconFile.size > 0) {
          const arrayBuffer = await faviconFile.arrayBuffer();
          const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
          const dataUrl = `data:${faviconFile.type};base64,${base64}`;
          await settingsStorage.setSetting("seo_favicon", dataUrl);
        }
        console.log("SEO settings updated successfully");
        return new Response(JSON.stringify({
          success: true,
          message: "SEO settings updated successfully"
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Failed to update SEO settings:", error);
        return new Response(JSON.stringify({
          success: false,
          message: `Failed to update SEO settings: ${error.message || error}`
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPut");
    onRequestPatch = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        if (!env.DB) {
          return new Response(JSON.stringify({
            success: false,
            message: "Database not available"
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const data = await request.json();
        const settingsStorage = new SettingsStorage(env.DB);
        await settingsStorage.initializeSettings();
        if (data.title) {
          await settingsStorage.setSetting("seo_title", data.title);
        }
        if (data.description) {
          await settingsStorage.setSetting("seo_description", data.description);
        }
        if (data.keywords) {
          await settingsStorage.setSetting("seo_keywords", data.keywords);
        }
        console.log("SEO text settings updated successfully");
        return new Response(JSON.stringify({
          success: true,
          message: "SEO settings updated successfully"
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Failed to update SEO text settings:", error);
        return new Response(JSON.stringify({
          success: false,
          message: `Failed to update SEO settings: ${error.message || error}`
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPatch");
    onRequestOptions25 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, PUT, PATCH, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/stats.ts
var onRequestGet29, onRequestOptions26;
var init_stats = __esm({
  "api/admin/stats.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet29 = /* @__PURE__ */ __name(async () => {
      const stats = {
        totalUsers: 1247,
        activeUsers: 892,
        newUsersToday: 23,
        totalTickets: 156,
        openTickets: 34,
        resolvedTickets: 122,
        revenue: {
          monthly: 15420,
          yearly: 184500,
          growth: 12.5
        },
        userGrowth: [
          { month: "Jan", users: 1100 },
          { month: "Feb", users: 1180 },
          { month: "Mar", users: 1247 }
        ],
        ticketStats: [
          { category: "Technical", count: 45 },
          { category: "Billing", count: 32 },
          { category: "Feature Request", count: 28 },
          { category: "General", count: 51 }
        ],
        recentActivity: [
          { time: "2 min ago", action: "New user registration: john@example.com" },
          { time: "5 min ago", action: "Ticket #156 resolved by support team" },
          { time: "12 min ago", action: "Payment received: $49.99 from user #1234" }
        ]
      };
      return new Response(JSON.stringify(stats), {
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*"
        }
      });
    }, "onRequestGet");
    onRequestOptions26 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/sync-banner-price.ts
var onRequestPost13, onRequestOptions27;
var init_sync_banner_price = __esm({
  "api/admin/sync-banner-price.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_settings_storage();
    onRequestPost13 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const requestData = await request.json();
        const { targetPrice } = requestData;
        if (!targetPrice) {
          return new Response(JSON.stringify({ error: "targetPrice is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const settingsStorage = new SettingsStorage(env.DB);
        const bannersData = await settingsStorage.getSetting("countdown_banners");
        let banners = bannersData ? JSON.parse(bannersData) : [];
        if (banners.length === 0) {
          banners = [{
            id: "1",
            title: "Limited Time Offer!",
            subtitle: "Get OCUS Job Hunter Extension at Special Price",
            targetPrice,
            originalPrice: 299.99,
            endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3).toISOString(),
            priority: 1,
            backgroundColor: "#FF6B35",
            textColor: "#FFFFFF",
            isActive: true,
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          }];
        } else {
          banners[0].targetPrice = targetPrice;
          banners[0].updatedAt = (/* @__PURE__ */ new Date()).toISOString();
        }
        await settingsStorage.setSetting("countdown_banners", JSON.stringify(banners));
        const updateProductResult = await env.DB.prepare(`
      UPDATE products 
      SET price = ? 
      WHERE id = 1
    `).bind(targetPrice.toString()).run();
        return new Response(JSON.stringify({
          success: true,
          message: "Banner price synced successfully",
          targetPrice
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to sync banner price",
          details: String(error)
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
    onRequestOptions27 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/tickets.ts
function mapStatus(status) {
  if (status === "in-progress") return "in_progress";
  if (status === "resolved") return "closed";
  return status || "open";
}
var onRequestGet30, onRequestOptions28;
var init_tickets = __esm({
  "api/admin/tickets.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_db();
    __name(mapStatus, "mapStatus");
    onRequestGet30 = /* @__PURE__ */ __name(async ({ request, env }) => {
      const expressBase = env?.EXPRESS_API_BASE;
      if (expressBase) {
        const base = expressBase.replace(/\/$/, "");
        const url = `${base}/api/admin/tickets`;
        const headers = {};
        const cookie = request.headers.get("cookie");
        const auth = request.headers.get("authorization");
        if (cookie) headers["cookie"] = cookie;
        if (auth) headers["authorization"] = auth;
        const proxied = await fetch(url, { headers, redirect: "manual" });
        const respHeaders = new Headers(proxied.headers);
        const setCookie = respHeaders.get("set-cookie");
        if (setCookie) {
          const rewritten = setCookie.replace(/;\s*Domain=[^;]+/i, "");
          respHeaders.delete("set-cookie");
          respHeaders.append("set-cookie", rewritten);
        }
        return new Response(proxied.body, { status: proxied.status, headers: respHeaders });
      }
      const storage2 = new TicketStorage(env.DB);
      const allTickets = await storage2.getAllTickets();
      const tickets2 = allTickets.map((t) => ({
        id: t.id,
        title: t.title,
        description: t.description,
        status: mapStatus(t.status),
        priority: t.priority,
        userId: t.assigned_to_user_id || 0,
        userName: t.customer_name,
        userEmail: t.customer_email,
        createdAt: t.created_at,
        updatedAt: t.updated_at
      }));
      return new Response(JSON.stringify(tickets2), {
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*"
        }
      });
    }, "onRequestGet");
    onRequestOptions28 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/update-banner-price.ts
var onRequestPost14, onRequestOptions29;
var init_update_banner_price = __esm({
  "api/admin/update-banner-price.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestPost14 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const { bannerId, targetPrice } = await request.json();
        const result = await env.DB.prepare(`
      UPDATE countdown_banners 
      SET targetPrice = ? 
      WHERE id = ?
    `).bind(targetPrice.toString(), bannerId).run();
        if (result.changes === 0) {
          return new Response(JSON.stringify({
            success: false,
            error: "Banner not found"
          }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        return new Response(JSON.stringify({
          success: true,
          message: "Banner price updated successfully",
          bannerId,
          newPrice: targetPrice
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error updating banner price:", error);
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to update banner price"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
    onRequestOptions29 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/update-banner-price-direct.ts
var onRequestGet31;
var init_update_banner_price_direct = __esm({
  "api/admin/update-banner-price-direct.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet31 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        const result = await env.DB.prepare(`
      UPDATE countdown_banners 
      SET targetPrice = '1.00' 
      WHERE id = 1
    `).run();
        const banner = await env.DB.prepare(`
      SELECT * FROM countdown_banners WHERE id = 1
    `).first();
        return new Response(JSON.stringify({
          success: true,
          message: "Banner price updated to \u20AC1.00",
          updated: result.changes > 0,
          banner
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error updating banner price:", error);
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to update banner price",
          details: error.message
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
  }
});

// api/admin/update-premium-status.ts
function json10(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var onRequestGet32, onRequestOptions30;
var init_update_premium_status = __esm({
  "api/admin/update-premium-status.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json10, "json");
    onRequestGet32 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        if (!env.DB) {
          return json10({ success: false, message: "Database not available" }, 500);
        }
        const now = (/* @__PURE__ */ new Date()).toISOString();
        let updatedRecords = 0;
        const completedOrders = await env.DB.prepare(`
      SELECT DISTINCT customer_id, customer_email, customer_name, final_amount
      FROM orders 
      WHERE status = 'completed' AND final_amount > 0
    `).all();
        console.log("Found completed orders:", completedOrders.results?.length);
        if (completedOrders.results && completedOrders.results.length > 0) {
          for (const order of completedOrders.results) {
            const orderData = order;
            if (orderData.customer_id) {
              const customerUpdate = await env.DB.prepare(`
            UPDATE customers 
            SET is_premium = 1, 
                extension_activated = 1,
                total_spent = COALESCE(total_spent, 0) + ?,
                total_orders = COALESCE(total_orders, 0) + 1,
                updated_at = ?
            WHERE id = ? AND (is_premium != 1 OR extension_activated != 1)
          `).bind(orderData.final_amount, now, orderData.customer_id).run();
              if (customerUpdate.meta?.changes && customerUpdate.meta.changes > 0) {
                updatedRecords++;
                console.log("Updated customer:", orderData.customer_id);
              }
            }
            if (orderData.customer_email) {
              const userUpdate = await env.DB.prepare(`
            UPDATE users 
            SET is_premium = 1, 
                extension_activated = 1,
                premium_activated_at = ?,
                total_spent = COALESCE(total_spent, 0) + ?,
                total_orders = COALESCE(total_orders, 0) + 1
            WHERE email = ? AND (is_premium != 1 OR extension_activated != 1)
          `).bind(now, orderData.final_amount, orderData.customer_email).run();
              if (userUpdate.meta?.changes && userUpdate.meta.changes > 0) {
                updatedRecords++;
                console.log("Updated user:", orderData.customer_email);
              }
            }
          }
        }
        const missingPremiumCustomers = await env.DB.prepare(`
      SELECT c.id, c.email, c.name
      FROM customers c
      WHERE c.id IN (
        SELECT DISTINCT customer_id 
        FROM orders 
        WHERE status = 'completed' AND final_amount > 0
      ) AND (c.is_premium != 1 OR c.extension_activated != 1)
    `).all();
        if (missingPremiumCustomers.results && missingPremiumCustomers.results.length > 0) {
          for (const customer of missingPremiumCustomers.results) {
            const customerData = customer;
            await env.DB.prepare(`
          UPDATE customers 
          SET is_premium = 1, extension_activated = 1, updated_at = ?
          WHERE id = ?
        `).bind(now, customerData.id).run();
            updatedRecords++;
            console.log("Fixed missing premium status for customer:", customerData.id);
          }
        }
        return json10({
          success: true,
          message: `Updated ${updatedRecords} records with premium status`,
          updatedRecords
        });
      } catch (error) {
        console.error("Error fixing existing purchases:", error);
        return json10({
          success: false,
          message: "Failed to fix existing purchases",
          error: error.message
        }, 500);
      }
    }, "onRequestGet");
    onRequestOptions30 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/admin/update-user-premium.ts
var onRequestPost15;
var init_update_user_premium = __esm({
  "api/admin/update-user-premium.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestPost15 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const body = await request.json();
        const { email, adminKey } = body;
        if (adminKey !== "fix-premium-2024") {
          return new Response(JSON.stringify({
            success: false,
            message: "Invalid admin key"
          }), {
            status: 403,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        if (!env.DB) {
          return new Response(JSON.stringify({ success: false, message: "Database not available" }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const results = {
          usersFixed: 0,
          customersFixed: 0,
          errors: []
        };
        if (email) {
          const user = await env.DB.prepare(`
        SELECT id, email, is_premium, extension_activated FROM users WHERE email = ?
      `).bind(email).first();
          if (user) {
            const userOrders = await env.DB.prepare(`
          SELECT COUNT(*) as count FROM orders 
          WHERE customer_email = ? AND status = 'completed' AND final_amount > 0
        `).bind(email).first();
            if (userOrders && userOrders.count > 0) {
              await env.DB.prepare(`
            UPDATE users 
            SET is_premium = 1, extension_activated = 1, premium_activated_at = datetime('now')
            WHERE id = ?
          `).bind(user.id).run();
              results.usersFixed++;
            }
          }
          const customer = await env.DB.prepare(`
        SELECT id, email, is_premium, extension_activated FROM customers WHERE email = ?
      `).bind(email).first();
          if (customer) {
            const customerOrders = await env.DB.prepare(`
          SELECT COUNT(*) as count FROM orders 
          WHERE customer_id = ? AND status = 'completed' AND final_amount > 0
        `).bind(customer.id).first();
            if (customerOrders && customerOrders.count > 0) {
              await env.DB.prepare(`
            UPDATE customers 
            SET is_premium = 1, extension_activated = 1, premium_activated_at = datetime('now')
            WHERE id = ?
          `).bind(customer.id).run();
              results.customersFixed++;
            }
          }
        } else {
          const usersToFix = await env.DB.prepare(`
        SELECT DISTINCT u.id, u.email
        FROM users u
        JOIN orders o ON u.email = o.customer_email
        WHERE o.status = 'completed' AND o.final_amount > 0
        AND (u.is_premium != 1 OR u.extension_activated != 1)
      `).all();
          for (const user of usersToFix.results || []) {
            await env.DB.prepare(`
          UPDATE users 
          SET is_premium = 1, extension_activated = 1, premium_activated_at = datetime('now')
          WHERE id = ?
        `).bind(user.id).run();
            results.usersFixed++;
          }
          const customersToFix = await env.DB.prepare(`
        SELECT DISTINCT c.id, c.email
        FROM customers c
        JOIN orders o ON c.id = o.customer_id
        WHERE o.status = 'completed' AND o.final_amount > 0
        AND (c.is_premium != 1 OR c.extension_activated != 1)
      `).all();
          for (const customer of customersToFix.results || []) {
            await env.DB.prepare(`
          UPDATE customers 
          SET is_premium = 1, extension_activated = 1, premium_activated_at = datetime('now')
          WHERE id = ?
        `).bind(customer.id).run();
            results.customersFixed++;
          }
        }
        return new Response(JSON.stringify({
          success: true,
          message: `Premium activation fix completed`,
          results
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error fixing premium activation:", error);
        return new Response(JSON.stringify({
          success: false,
          message: error.message
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
  }
});

// api/admin/users.ts
var onRequestGet33, onRequestOptions31;
var init_users = __esm({
  "api/admin/users.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet33 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        let users2 = [];
        let stats = {
          totalUsers: 0,
          activeUsers: 0,
          premiumUsers: 0
        };
        try {
          const userResults = await env.DB.prepare(`
        SELECT 
          u.id, 
          u.email, 
          u.name, 
          u.role,
          u.created_at,
          u.is_premium,
          u.premium_activated_at,
          u.total_spent,
          u.total_orders,
          u.extension_activated,
          COUNT(DISTINCT d.id) as trial_downloads,
          COUNT(DISTINCT o.id) as purchase_count,
          MAX(d.created_at) as last_download,
          MAX(o.created_at) as last_purchase
        FROM users u
        LEFT JOIN user_downloads d ON u.id = d.user_id
        LEFT JOIN orders o ON u.id = o.customer_id AND o.status = 'completed'
        GROUP BY u.id
        ORDER BY u.created_at DESC
      `).all();
          users2 = userResults.results || [];
          const statsResult = await env.DB.prepare(`
        SELECT 
          COUNT(*) as totalUsers,
          COUNT(CASE WHEN is_premium = 1 THEN 1 END) as premiumUsers,
          COUNT(DISTINCT d.user_id) as trialUsers
        FROM users u
        LEFT JOIN user_downloads d ON u.id = d.user_id
      `).first();
          if (statsResult) {
            stats = {
              totalUsers: Number(statsResult.totalUsers) || 0,
              activeUsers: Number(statsResult.trialUsers) || 0,
              premiumUsers: Number(statsResult.premiumUsers) || 0
            };
          }
        } catch (dbError) {
          console.log("Users table not found, checking fallback storage:", dbError);
          const settingsResults = await env.DB.prepare(`
        SELECT key, value FROM settings 
        WHERE key LIKE 'user_%'
      `).all();
          const allUsers = [];
          for (const setting of settingsResults.results || []) {
            try {
              const userData = JSON.parse(setting.value);
              userData.id = userData.email.replace("@", "_at_").replace(".", "_dot_");
              userData.registrationDate = userData.updatedAt;
              userData.createdAt = userData.updatedAt;
              userData.isActive = true;
              allUsers.push(userData);
            } catch (parseError) {
              console.log("Error parsing user data:", parseError);
            }
          }
          users2 = allUsers.sort((a, b) => {
            const dateA = new Date(a.updatedAt);
            const dateB = new Date(b.updatedAt);
            return dateB.getTime() - dateA.getTime();
          });
          stats.totalUsers = users2.length;
          stats.activeUsers = users2.filter((u) => u.isActive).length;
          stats.premiumUsers = users2.filter((u) => u.isPremium).length;
        }
        return new Response(JSON.stringify({
          success: true,
          users: users2,
          stats
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error fetching admin users:", error);
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to fetch users",
          details: String(error)
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions31 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/announcement-badge/active.ts
var onRequestOptions32, onRequestGet34;
var init_active = __esm({
  "api/announcement-badge/active.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_settings_storage();
    onRequestOptions32 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
    onRequestGet34 = /* @__PURE__ */ __name(async (context) => {
      try {
        const settingsStorage = new SettingsStorage(context.env.DB);
        const badgesData = await settingsStorage.getSetting("announcement_badges");
        const badges = badgesData ? JSON.parse(badgesData) : [];
        console.log("Retrieved announcement badges for active endpoint:", badges.length);
        const activeBadge = badges.filter((badge) => badge.isActive).sort((a, b) => b.priority - a.priority)[0];
        if (!activeBadge) {
          return new Response(JSON.stringify(null), {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const frontendBadge = {
          id: activeBadge.id,
          isEnabled: activeBadge.isActive,
          textEn: activeBadge.title,
          textTranslations: activeBadge.textTranslations || {},
          backgroundColor: activeBadge.backgroundColor,
          textColor: activeBadge.textColor,
          priority: activeBadge.priority
        };
        console.log("Returning active badge:", frontendBadge);
        return new Response(JSON.stringify(frontendBadge), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error fetching active announcement badge:", error);
        return new Response(JSON.stringify({
          error: "Failed to fetch active announcement badge",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
  }
});

// api/auth/facebook.ts
var onRequestGet35;
var init_facebook = __esm({
  "api/auth/facebook.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet35 = /* @__PURE__ */ __name(async ({ request, env }) => {
      const url = new URL(request.url);
      const code = url.searchParams.get("code");
      try {
        const authSettings2 = await env.DB.prepare(
          "SELECT facebook_enabled, facebook_app_id, facebook_app_secret FROM auth_settings WHERE id = 1"
        ).first();
        if (!authSettings2?.facebook_enabled) {
          return new Response("Facebook login is not enabled.", { status: 400 });
        }
        const { facebook_app_id, facebook_app_secret } = authSettings2;
        const redirectUri = `${url.origin}/api/auth/facebook`;
        if (!code) {
          const authUrl = new URL("https://www.facebook.com/v18.0/dialog/oauth");
          authUrl.searchParams.set("client_id", facebook_app_id);
          authUrl.searchParams.set("redirect_uri", redirectUri);
          authUrl.searchParams.set("response_type", "code");
          authUrl.searchParams.set("scope", "email,public_profile");
          return Response.redirect(authUrl.toString(), 302);
        }
        const tokenResponse = await fetch("https://graph.facebook.com/v18.0/oauth/access_token", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({
            client_id: facebook_app_id,
            client_secret: facebook_app_secret,
            redirect_uri: redirectUri,
            code
          })
        });
        if (!tokenResponse.ok) {
          const errorText = await tokenResponse.text();
          throw new Error(`Failed to get access token: ${errorText}`);
        }
        const tokenData = await tokenResponse.json();
        const userResponse = await fetch(`https://graph.facebook.com/me?fields=id,name,email&access_token=${tokenData.access_token}`);
        if (!userResponse.ok) {
          throw new Error("Failed to fetch user data from Facebook.");
        }
        const userData = await userResponse.json();
        if (!userData.email) {
          return new Response("Email not provided by Facebook.", { status: 400 });
        }
        let user = await env.DB.prepare("SELECT id, name, email FROM users WHERE email = ?").bind(userData.email).first();
        if (!user) {
          const now = (/* @__PURE__ */ new Date()).toISOString();
          await env.DB.prepare(
            "INSERT INTO users (email, name, provider, provider_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)"
          ).bind(userData.email, userData.name, "facebook", userData.id, now, now).run();
          user = await env.DB.prepare("SELECT id, name, email FROM users WHERE email = ?").bind(userData.email).first();
        }
        if (!user) {
          return new Response("Could not create or find user.", { status: 500 });
        }
        const redirectURL = new URL("/dashboard", url.origin);
        redirectURL.searchParams.set("userId", user.id.toString());
        redirectURL.searchParams.set("name", user.name);
        redirectURL.searchParams.set("email", user.email);
        return Response.redirect(redirectURL.toString(), 302);
      } catch (error) {
        console.error("Facebook OAuth Error:", error);
        const errorUrl = new URL("/login", url.origin);
        errorUrl.searchParams.set("error", "oauth_failed");
        errorUrl.searchParams.set("provider", "facebook");
        return Response.redirect(errorUrl.toString(), 302);
      }
    }, "onRequestGet");
  }
});

// api/auth/github.ts
var onRequestGet36;
var init_github = __esm({
  "api/auth/github.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet36 = /* @__PURE__ */ __name(async (context) => {
      const { request, env } = context;
      const url = new URL(request.url);
      const code = url.searchParams.get("code");
      const state = url.searchParams.get("state");
      try {
        const authSettings2 = await env.DB.prepare("SELECT github_enabled, github_client_id, github_client_secret FROM auth_settings WHERE id = 1").first();
        if (!authSettings2?.github_enabled) {
          return new Response("GitHub login is not enabled.", { status: 400 });
        }
        if (!authSettings2.github_client_id || !authSettings2.github_client_secret) {
          return new Response("GitHub client ID or secret is not configured.", { status: 500 });
        }
        if (!code) {
          const authUrl = new URL("https://github.com/login/oauth/authorize");
          authUrl.searchParams.set("client_id", authSettings2.github_client_id);
          authUrl.searchParams.set("redirect_uri", `${url.origin}/api/auth/github`);
          authUrl.searchParams.set("scope", "user:email");
          authUrl.searchParams.set("state", state || crypto.randomUUID());
          return Response.redirect(authUrl.toString(), 302);
        }
        const tokenResponse = await fetch("https://github.com/login/oauth/access_token", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          body: JSON.stringify({
            client_id: authSettings2.github_client_id,
            client_secret: authSettings2.github_client_secret,
            code
          })
        });
        const tokenData = await tokenResponse.json();
        if (tokenData.error || !tokenData.access_token) {
          throw new Error(`Failed to get access token: ${tokenData.error_description || "No token returned"}`);
        }
        const userResponse = await fetch("https://api.github.com/user", {
          headers: {
            "Authorization": `Bearer ${tokenData.access_token}`,
            "User-Agent": "OCUS-Job-Hunter"
          }
        });
        const userData = await userResponse.json();
        let userEmail = userData.email;
        if (!userEmail) {
          const emailResponse = await fetch("https://api.github.com/user/emails", {
            headers: {
              "Authorization": `Bearer ${tokenData.access_token}`,
              "User-Agent": "OCUS-Job-Hunter"
            }
          });
          const emails = await emailResponse.json();
          const primaryEmail = emails.find((e) => e.primary && e.verified);
          userEmail = primaryEmail?.email || null;
        }
        if (!userEmail) {
          return new Response("Could not retrieve a verified primary email from GitHub.", { status: 400 });
        }
        let user = await env.DB.prepare("SELECT id, name, email FROM users WHERE github_id = ?").bind(userData.id).first();
        if (!user) {
          const name = userData.name || userData.login;
          const now = (/* @__PURE__ */ new Date()).toISOString();
          await env.DB.prepare(
            "INSERT INTO users (email, name, provider, provider_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)"
          ).bind(userEmail, name, "github", userData.id, now, now).run();
          user = await env.DB.prepare("SELECT id, name, email FROM users WHERE github_id = ?").bind(userData.id).first();
        }
        if (!user) {
          return new Response("Failed to create or find user.", { status: 500 });
        }
        const redirectUrl = new URL(`${url.origin}/dashboard`);
        redirectUrl.searchParams.set("status", "loggedIn");
        redirectUrl.searchParams.set("userId", user.id.toString());
        redirectUrl.searchParams.set("name", user.name);
        redirectUrl.searchParams.set("email", user.email);
        return Response.redirect(redirectUrl.toString(), 302);
      } catch (error) {
        console.error("GitHub OAuth Error:", error);
        const errorUrl = new URL(`${url.origin}/login`);
        errorUrl.searchParams.set("error", "github_oauth_failed");
        return Response.redirect(errorUrl.toString(), 302);
      }
    }, "onRequestGet");
  }
});

// api/auth/google.ts
var onRequestGet37;
var init_google = __esm({
  "api/auth/google.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet37 = /* @__PURE__ */ __name(async ({ request, env }) => {
      const url = new URL(request.url);
      const code = url.searchParams.get("code");
      try {
        const authSettings2 = await env.DB.prepare(
          "SELECT google_enabled, google_client_id, google_client_secret FROM auth_settings WHERE id = 1"
        ).first();
        if (!authSettings2?.google_enabled) {
          return new Response("Google login is not enabled.", { status: 400 });
        }
        const { google_client_id, google_client_secret } = authSettings2;
        const redirectUri = `${url.origin}/api/auth/google`;
        if (!code) {
          const authUrl = new URL("https://accounts.google.com/o/oauth2/v2/auth");
          authUrl.searchParams.set("client_id", google_client_id);
          authUrl.searchParams.set("redirect_uri", redirectUri);
          authUrl.searchParams.set("response_type", "code");
          authUrl.searchParams.set("scope", "openid email profile");
          return Response.redirect(authUrl.toString(), 302);
        }
        const tokenResponse = await fetch("https://oauth2.googleapis.com/token", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({
            client_id: google_client_id,
            client_secret: google_client_secret,
            redirect_uri: redirectUri,
            grant_type: "authorization_code",
            code
          })
        });
        if (!tokenResponse.ok) {
          const errorText = await tokenResponse.text();
          throw new Error(`Failed to get access token: ${errorText}`);
        }
        const tokenData = await tokenResponse.json();
        const userResponse = await fetch("https://www.googleapis.com/oauth2/v2/userinfo", {
          headers: { "Authorization": `Bearer ${tokenData.access_token}` }
        });
        if (!userResponse.ok) {
          throw new Error("Failed to fetch user data from Google.");
        }
        const userData = await userResponse.json();
        if (!userData.email || !userData.verified_email) {
          return new Response("A verified email is required from Google.", { status: 400 });
        }
        let user = await env.DB.prepare("SELECT id, name, email FROM users WHERE email = ?").bind(userData.email).first();
        if (!user) {
          const now = (/* @__PURE__ */ new Date()).toISOString();
          await env.DB.prepare(
            "INSERT INTO users (email, name, provider, provider_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)"
          ).bind(userData.email, userData.name, "google", userData.id, now, now).run();
          user = await env.DB.prepare("SELECT id, name, email FROM users WHERE email = ?").bind(userData.email).first();
        }
        if (!user) {
          return new Response("Could not create or find user.", { status: 500 });
        }
        const redirectURL = new URL("/dashboard", url.origin);
        redirectURL.searchParams.set("userId", user.id.toString());
        redirectURL.searchParams.set("name", user.name);
        redirectURL.searchParams.set("email", user.email);
        return Response.redirect(redirectURL.toString(), 302);
      } catch (error) {
        console.error("Google OAuth Error:", error);
        const errorUrl = new URL("/login", url.origin);
        errorUrl.searchParams.set("error", "oauth_failed");
        errorUrl.searchParams.set("provider", "google");
        return Response.redirect(errorUrl.toString(), 302);
      }
    }, "onRequestGet");
  }
});

// api/auth/register.ts
var jsonResponse, onRequestPost16, onRequestOptions33;
var init_register = __esm({
  "api/auth/register.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_user_storage();
    jsonResponse = /* @__PURE__ */ __name((body, status) => {
      const headers = {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*"
      };
      return new Response(JSON.stringify(body), { status, headers });
    }, "jsonResponse");
    onRequestPost16 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const { email, password, name } = await request.json();
        if (!email || !password || !name) {
          return jsonResponse({ success: false, message: "Missing required fields." }, 400);
        }
        const userStorage = new UserStorage(env.DB);
        await userStorage.initializeUsers();
        const existingUser = await userStorage.getUserByEmail(email);
        if (existingUser) {
          return jsonResponse({ success: false, message: "An account with this email already exists." }, 409);
        }
        const newUser = await userStorage.createUser(email, password, name);
        const { password: _, ...userResponse } = newUser;
        return jsonResponse({ success: true, message: "Registration successful.", user: userResponse }, 201);
      } catch (error) {
        console.error("Registration Error:", error);
        const errorMessage = error instanceof Error ? error.message : "An unknown error occurred.";
        if (errorMessage.includes("UNIQUE constraint failed")) {
          return jsonResponse({ success: false, message: "An account with this email already exists." }, 409);
        }
        return jsonResponse({ success: false, message: "Registration failed.", error: errorMessage }, 500);
      }
    }, "onRequestPost");
    onRequestOptions33 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/countdown-banner/active.ts
var onRequestGet38, onRequestOptions34;
var init_active2 = __esm({
  "api/countdown-banner/active.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet38 = /* @__PURE__ */ __name(async (context) => {
      try {
        const { env } = context;
        const banner = await env.DB.prepare(`
      SELECT * FROM countdown_banners 
      WHERE isActive = 1 
      ORDER BY priority DESC, id ASC 
      LIMIT 1
    `).first();
        try {
          const settingsStorage = new (await Promise.resolve().then(() => (init_settings_storage(), settings_storage_exports))).SettingsStorage(env.DB);
          const bannersData = await settingsStorage.getSetting("countdown_banners");
          if (bannersData) {
            const banners = JSON.parse(bannersData);
            const activeBanner = banners.find((b) => b.isActive);
            if (activeBanner) {
              return new Response(JSON.stringify({
                id: activeBanner.id || 1,
                isEnabled: activeBanner.isActive ? 1 : 0,
                titleEn: activeBanner.title || "Limited Time Offer!",
                subtitleEn: activeBanner.subtitle || "Get OCUS Job Hunter Extension at Special Price",
                titleTranslations: activeBanner.titleTranslations || {},
                subtitleTranslations: activeBanner.subtitleTranslations || {},
                targetPrice: String(activeBanner.targetPrice || "1.00"),
                originalPrice: String(activeBanner.originalPrice || "299.99"),
                endDateTime: activeBanner.endDate || new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3).toISOString(),
                backgroundColor: activeBanner.backgroundColor || "#FF6B35",
                textColor: activeBanner.textColor || "#FFFFFF",
                priority: activeBanner.priority || 1
              }), {
                headers: {
                  "Content-Type": "application/json",
                  "Access-Control-Allow-Origin": "*"
                }
              });
            }
          }
        } catch (settingsError) {
          console.warn("Failed to check settings table for banners:", settingsError);
        }
        if (!banner) {
          return new Response(JSON.stringify({ message: "No active countdown banner found" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Methods": "GET, OPTIONS",
              "Access-Control-Allow-Headers": "Content-Type"
            }
          });
        }
        let titleTranslations = {};
        let subtitleTranslations = {};
        try {
          if (banner.titleTranslations && typeof banner.titleTranslations === "string") {
            titleTranslations = JSON.parse(banner.titleTranslations);
          }
        } catch (e) {
          console.warn("Failed to parse titleTranslations:", e);
        }
        try {
          if (banner.subtitleTranslations && typeof banner.subtitleTranslations === "string") {
            subtitleTranslations = JSON.parse(banner.subtitleTranslations);
          }
        } catch (e) {
          console.warn("Failed to parse subtitleTranslations:", e);
        }
        const transformedBanner = {
          id: parseInt(String(banner.id)) || 0,
          isEnabled: banner.isActive,
          titleEn: banner.title,
          subtitleEn: banner.subtitle,
          titleTranslations,
          subtitleTranslations,
          targetPrice: String(banner.targetPrice || "1.00"),
          originalPrice: banner.originalPrice ? String(banner.originalPrice) : void 0,
          endDateTime: banner.endDate,
          // Frontend expects endDateTime
          backgroundColor: banner.backgroundColor,
          textColor: banner.textColor,
          priority: banner.priority
        };
        return new Response(JSON.stringify(transformedBanner), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type"
          }
        });
      } catch (error) {
        console.error("Error fetching active countdown banner:", error);
        return new Response(JSON.stringify({
          error: "Failed to fetch active countdown banner",
          details: error instanceof Error ? error.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions34 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/customer/login.ts
var onRequestPost17, onRequestOptions35;
var init_login2 = __esm({
  "api/customer/login.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestPost17 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const { email, password, recaptchaToken } = await request.json();
        console.log("Login attempt for email:", email);
        if (email === "demo@example.com" && password === "demo123") {
          return new Response(JSON.stringify({
            success: true,
            user: {
              id: 1,
              email: "demo@example.com",
              name: "Demo User",
              role: "customer"
            },
            token: "demo-jwt-token"
          }), {
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        if (!env.DB) {
          console.error("Database not available");
          return new Response(JSON.stringify({
            success: false,
            message: "Database not available"
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        let user = null;
        try {
          console.log("Querying users table for email:", email);
          const emailOnlyResult = await env.DB.prepare(`
        SELECT id, email, name, role, created_at, password
        FROM users WHERE email = ?
      `).bind(email).first();
          if (emailOnlyResult) {
            console.log("User found with email:", email);
            console.log("Stored password starts with:", emailOnlyResult.password?.substring(0, 10));
            console.log("Input password:", password);
            if (emailOnlyResult.password?.startsWith("$2b$")) {
              console.log("Password is hashed, implementing bcrypt comparison");
              try {
                const bcrypt = await Promise.resolve().then(() => (init_bcryptjs(), bcryptjs_exports));
                const isMatch = await bcrypt.compare(password, emailOnlyResult.password);
                if (isMatch) {
                  user = emailOnlyResult;
                  console.log("Bcrypt password match for user:", user.email);
                } else {
                  console.log("Bcrypt password mismatch");
                }
              } catch (bcryptError) {
                console.log("Bcrypt comparison failed:", bcryptError);
              }
            } else {
              if (emailOnlyResult.password === password) {
                user = emailOnlyResult;
                console.log("Plain text password match for user:", user.email);
              } else {
                console.log("Plain text password mismatch");
              }
            }
          } else {
            console.log("No user found with this email in users table");
          }
        } catch (e) {
          console.log("Users table query failed:", e);
        }
        if (user) {
          return new Response(JSON.stringify({
            success: true,
            user,
            token: `jwt-token-${user.email}-${Date.now()}`
          }), {
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        console.log("User found:", user ? "Yes" : "No");
        console.log("Email check:", email);
        console.log("Password length:", password ? password.length : 0);
        return new Response(JSON.stringify({
          success: false,
          message: "Invalid credentials"
        }), {
          status: 401,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          message: "Login failed"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
    onRequestOptions35 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/customer/profile.ts
var onRequestGet39, onRequestPut14, onRequestOptions36;
var init_profile = __esm({
  "api/customer/profile.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_user_storage();
    onRequestGet39 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const url = new URL(request.url);
        const userId = url.searchParams.get("userId");
        if (!userId) {
          return new Response(JSON.stringify({
            success: false,
            message: "User ID is required"
          }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const userStorage = new UserStorage(env.DB);
        await userStorage.initializeUsers();
        const user = await userStorage.getUserById(parseInt(userId));
        if (!user) {
          return new Response(JSON.stringify({
            success: false,
            message: "User not found"
          }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const userQuery = `
      SELECT 
        id, email, name, role, created_at,
        is_premium, premium_activated_at, total_spent, 
        total_orders, extension_activated
      FROM users 
      WHERE id = ?
    `;
        const userResult = await env.DB.prepare(userQuery).bind(user.id).first();
        const profile = {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          isPremium: Boolean(userResult?.is_premium),
          premiumActivatedAt: userResult?.premium_activated_at,
          totalSpent: parseFloat(userResult?.total_spent || "0"),
          totalOrders: parseInt(userResult?.total_orders || "0"),
          extensionActivated: Boolean(userResult?.extension_activated),
          subscriptionStatus: userResult?.is_premium ? "premium" : "free",
          plan: userResult?.is_premium ? "premium" : "free",
          joinedDate: user.created_at?.split("T")[0] || "2024-01-15",
          lastLogin: (/* @__PURE__ */ new Date()).toISOString(),
          createdAt: user.created_at,
          settings: {
            notifications: true,
            emailUpdates: true,
            theme: "light"
          }
        };
        return new Response(JSON.stringify(profile), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Failed to get user profile:", error);
        return new Response(JSON.stringify({
          success: false,
          message: "Failed to load profile"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestPut14 = /* @__PURE__ */ __name(async ({ request }) => {
      try {
        const updates = await request.json();
        return new Response(JSON.stringify({
          success: true,
          message: "Profile updated successfully",
          profile: {
            ...updates,
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          message: "Failed to update profile"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPut");
    onRequestOptions36 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, PUT, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/customer/register.ts
var onRequestPost18, onRequestOptions37;
var init_register2 = __esm({
  "api/customer/register.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestPost18 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const { email, password, name, recaptchaToken } = await request.json();
        if (!email || !password || !name) {
          return new Response(JSON.stringify({
            success: false,
            message: "Missing required fields"
          }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        if (!env.DB) {
          console.error("D1 database not available");
          return new Response(JSON.stringify({
            success: false,
            message: "Database not available"
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        await env.DB.prepare(`
      CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        name TEXT NOT NULL,
        role TEXT DEFAULT 'customer',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `).run();
        await env.DB.prepare(`
      CREATE TABLE IF NOT EXISTS customers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT UNIQUE NOT NULL,
        name TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        is_premium BOOLEAN DEFAULT 0,
        extension_activated BOOLEAN DEFAULT 0,
        total_spent DECIMAL(10,2) DEFAULT 0,
        total_orders INTEGER DEFAULT 0
      )
    `).run();
        const now = (/* @__PURE__ */ new Date()).toISOString();
        console.log("Registering user:", email, "with password length:", password.length);
        const existingUser = await env.DB.prepare(`
      SELECT id FROM users WHERE email = ?
    `).bind(email).first();
        if (existingUser) {
          return new Response(JSON.stringify({
            success: false,
            message: "User already exists"
          }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const userResult = await env.DB.prepare(`
      INSERT INTO users (email, password, name, role, created_at)
      VALUES (?, ?, ?, 'customer', ?)
    `).bind(email, password, name, now).run();
        console.log("User inserted with ID:", userResult.meta.last_row_id);
        const customerResult = await env.DB.prepare(`
      INSERT INTO customers (email, name, created_at)
      VALUES (?, ?, ?)
    `).bind(email, name, now).run();
        console.log("Customer inserted with ID:", customerResult.meta.last_row_id);
        return new Response(JSON.stringify({
          success: true,
          message: "Registration successful",
          user: {
            id: userResult.meta.last_row_id,
            email,
            name,
            role: "customer"
          }
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Registration error:", error);
        return new Response(JSON.stringify({
          success: false,
          message: "Registration failed: " + error.message
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
    onRequestOptions37 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/customer/stats.ts
var onRequestGet40, onRequestOptions38;
var init_stats2 = __esm({
  "api/customer/stats.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet40 = /* @__PURE__ */ __name(async () => {
      const stats = {
        totalApplications: 47,
        successfulApplications: 12,
        pendingApplications: 8,
        rejectedApplications: 27,
        successRate: 25.5,
        averageResponseTime: "3.2 days",
        monthlyApplications: [
          { month: "Jan", applications: 15, success: 4 },
          { month: "Feb", applications: 12, success: 3 },
          { month: "Mar", applications: 20, success: 5 }
        ],
        recentActivity: [
          { date: "2024-03-15", action: "Applied to Software Engineer at TechCorp", status: "pending" },
          { date: "2024-03-14", action: "Interview scheduled with StartupXYZ", status: "success" },
          { date: "2024-03-13", action: "Application rejected by BigTech Inc", status: "rejected" }
        ]
      };
      return new Response(JSON.stringify(stats), {
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*"
        }
      });
    }, "onRequestGet");
    onRequestOptions38 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/download-extension/premium.ts
var onRequestGet41;
var init_premium = __esm({
  "api/download-extension/premium.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet41 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const authHeader = request.headers.get("Authorization");
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          return new Response("Unauthorized", { status: 401 });
        }
        const token = authHeader.substring(7);
        if (token === "demo-jwt-token") {
          const mockZipContent = new Uint8Array([
            80,
            75,
            3,
            4,
            20,
            0,
            0,
            0,
            8,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            80,
            75,
            5,
            6,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]);
          return new Response(mockZipContent, {
            headers: {
              "Content-Type": "application/zip",
              "Content-Disposition": 'attachment; filename="ocus-job-hunter-premium-v2.1.8-STABLE.zip"',
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        if (token.startsWith("jwt-token-")) {
          const parts = token.split("-");
          if (parts.length < 3) {
            return new Response("Invalid token format", { status: 401 });
          }
          const userEmail = parts[2];
          if (!env.DB) {
            return new Response("Database not available", { status: 500 });
          }
          const customer = await env.DB.prepare(
            "SELECT id, extension_activated, total_spent FROM customers WHERE email = ?"
          ).bind(userEmail).first();
          if (!customer) {
            return new Response("Customer not found", { status: 404 });
          }
          const orderCheck = await env.DB.prepare(`
        SELECT COUNT(*) as orderCount, SUM(final_amount) as totalPaid
        FROM orders 
        WHERE customer_email = ? AND status = 'completed' AND final_amount > 0
      `).bind(userEmail).first();
          const hasValidPurchase = Boolean(customer.extension_activated) && orderCheck !== null && Number(orderCheck.orderCount || 0) > 0 && parseFloat(String(orderCheck.totalPaid || "0")) > 0;
          if (hasValidPurchase) {
            try {
              const downloadToken = `download_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
              const now = (/* @__PURE__ */ new Date()).toISOString();
              await env.DB.prepare(`
            INSERT INTO extension_downloads (
              customer_id, download_token, download_type, downloaded_at, 
              ip_address, user_agent, created_at
            ) VALUES (?, ?, 'premium', ?, ?, ?, ?)
          `).bind(
                customer.id,
                downloadToken,
                now,
                request.headers.get("CF-Connecting-IP") || "unknown",
                request.headers.get("User-Agent") || "unknown",
                now
              ).run();
            } catch (e) {
              console.log("Failed to log download:", e);
            }
            const mockZipContent = new Uint8Array([
              80,
              75,
              3,
              4,
              20,
              0,
              0,
              0,
              8,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              80,
              75,
              5,
              6,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ]);
            return new Response(mockZipContent, {
              headers: {
                "Content-Type": "application/zip",
                "Content-Disposition": 'attachment; filename="ocus-job-hunter-premium-v2.1.8-STABLE.zip"',
                "Access-Control-Allow-Origin": "*"
              }
            });
          }
        }
        return new Response("Premium access required", { status: 403 });
      } catch (error) {
        return new Response("Download failed", { status: 500 });
      }
    }, "onRequestGet");
  }
});

// api/download-extension/trial.ts
var onRequestGet42;
var init_trial = __esm({
  "api/download-extension/trial.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet42 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const mockZipContent = new Uint8Array([
          80,
          75,
          3,
          4,
          // ZIP file signature
          20,
          0,
          0,
          0,
          8,
          0,
          // Version, flags, compression
          0,
          0,
          0,
          0,
          // Date/time
          0,
          0,
          0,
          0,
          // CRC-32
          0,
          0,
          0,
          0,
          // Compressed size
          0,
          0,
          0,
          0,
          // Uncompressed size
          0,
          0,
          // Filename length
          0,
          0,
          // Extra field length
          80,
          75,
          5,
          6,
          // End of central directory signature
          0,
          0,
          0,
          0,
          // Number of entries
          0,
          0,
          0,
          0,
          // Size of central directory
          0,
          0,
          0,
          0,
          // Offset of central directory
          0,
          0
          // Comment length
        ]);
        return new Response(mockZipContent, {
          headers: {
            "Content-Type": "application/zip",
            "Content-Disposition": 'attachment; filename="ocus-job-hunter-trial-v2.1.8-STABLE.zip"',
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        return new Response("Download failed", { status: 500 });
      }
    }, "onRequestGet");
  }
});

// api/downloads/premium-extension.ts
var onRequestGet43, onRequestOptions39;
var init_premium_extension = __esm({
  "api/downloads/premium-extension.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet43 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const url = new URL(request.url);
        const downloadToken = url.searchParams.get("token");
        if (!downloadToken) {
          return new Response(JSON.stringify({ error: "Download token is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const order = await env.DB.prepare(`
      SELECT * FROM orders 
      WHERE downloadToken = ? AND status = 'completed'
    `).bind(downloadToken).first();
        if (!order) {
          return new Response(JSON.stringify({ error: "Invalid or expired download token" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        if (Number(order.downloadCount) >= Number(order.maxDownloads)) {
          return new Response(JSON.stringify({
            error: "Download limit exceeded",
            maxDownloads: order.maxDownloads,
            currentDownloads: order.downloadCount
          }), {
            status: 403,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        await env.DB.prepare(`
      UPDATE orders 
      SET downloadCount = downloadCount + 1 
      WHERE downloadToken = ?
    `).bind(downloadToken).run();
        console.log(`Premium extension downloaded for order ${order.id}, download count: ${Number(order.downloadCount) + 1}`);
        return new Response(JSON.stringify({
          success: true,
          message: "Premium extension download authorized",
          orderId: order.id,
          downloadCount: Number(order.downloadCount) + 1,
          maxDownloads: Number(order.maxDownloads),
          activationCode: order.activationCode
        }), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error processing download:", error);
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to process download",
          details: String(error)
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions39 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/invoices/customer.ts
function json11(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
var onRequestGet44;
var init_customer = __esm({
  "api/invoices/customer.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json11, "json");
    onRequestGet44 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const { searchParams } = new URL(request.url);
        const customerId = searchParams.get("customerId");
        if (!customerId) {
          return json11({ error: "Customer ID is required" }, 400);
        }
        const { results } = await env.DB.prepare(
          "SELECT * FROM invoices WHERE customerId = ? ORDER BY invoiceDate DESC"
        ).bind(customerId).all();
        if (!results) {
          return json11([]);
        }
        return json11(results);
      } catch (error) {
        return json11({
          error: error.message
        }, 500);
      }
    }, "onRequestGet");
  }
});

// api/invoices/generate.ts
var onRequestGet45, onRequestOptions40;
var init_generate = __esm({
  "api/invoices/generate.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet45 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const url = new URL(request.url);
        const orderId = url.searchParams.get("orderId");
        const invoiceNumber = url.searchParams.get("invoiceNumber");
        if (!orderId && !invoiceNumber) {
          return new Response(JSON.stringify({ error: "Order ID or Invoice Number is required" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        let order = null;
        try {
          const orderQuery = orderId ? `SELECT * FROM orders WHERE id = ?` : `SELECT * FROM orders WHERE invoiceNumber = ?`;
          order = await env.DB.prepare(orderQuery).bind(orderId || invoiceNumber).first();
        } catch (dbError) {
          console.log("Orders table not found, checking fallback storage:", dbError);
          const settingsResults = await env.DB.prepare(`
        SELECT key, value FROM settings 
        WHERE key LIKE 'order_%'
      `).all();
          for (const setting of settingsResults.results || []) {
            try {
              const orderData = JSON.parse(setting.value);
              if (orderId && orderData.id == orderId || invoiceNumber && orderData.invoiceNumber === invoiceNumber) {
                order = orderData;
                break;
              }
            } catch (parseError) {
              console.log("Error parsing order data:", parseError);
            }
          }
        }
        if (!order) {
          return new Response(JSON.stringify({ error: "Order not found" }), {
            status: 404,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const invoiceData = {
          invoiceNumber: order.invoiceNumber || "",
          orderId: order.id,
          customerEmail: order.customerEmail,
          customerName: order.customerName,
          issueDate: order.completedAt || order.createdAt,
          dueDate: order.completedAt || order.createdAt,
          // Company details
          company: {
            name: "OCUS Job Hunter",
            address: "Digital Services Company",
            email: "support@jobhunter.one",
            website: "https://jobhunter.one"
          },
          // Customer details
          customer: {
            name: order.customerName,
            email: order.customerEmail
          },
          // Items
          items: [{
            description: order.productName,
            quantity: 1,
            unitPrice: order.finalAmount,
            total: order.finalAmount
          }],
          // Totals
          subtotal: order.finalAmount,
          tax: 0,
          total: order.finalAmount,
          currency: order.currency,
          // Payment details
          paymentMethod: order.paymentMethod,
          paymentStatus: order.status,
          activationCode: order.activationCode,
          downloadToken: order.downloadToken
        };
        return new Response(JSON.stringify({
          success: true,
          invoice: invoiceData
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error generating invoice:", error);
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to generate invoice",
          details: String(error)
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions40 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/me/invoices.ts
function json12(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
var onRequestGet46, onRequestOptions41;
var init_invoices3 = __esm({
  "api/me/invoices.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json12, "json");
    onRequestGet46 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const authHeader = request.headers.get("Authorization");
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          return json12({ error: "Unauthorized" }, 401);
        }
        const token = authHeader.substring(7);
        if (token === "demo-jwt-token") {
          return json12([
            {
              id: 1,
              invoice_number: "INV-2025-000001",
              order_id: 1,
              customer_name: "Demo User",
              customer_email: "demo@example.com",
              invoice_date: (/* @__PURE__ */ new Date()).toISOString(),
              due_date: (/* @__PURE__ */ new Date()).toISOString(),
              subtotal: "29.99",
              tax_amount: "0.00",
              discount_amount: "0.00",
              total_amount: "29.99",
              currency: "USD",
              status: "paid",
              paid_at: (/* @__PURE__ */ new Date()).toISOString(),
              notes: "Premium extension purchase",
              created_at: (/* @__PURE__ */ new Date()).toISOString(),
              updated_at: (/* @__PURE__ */ new Date()).toISOString(),
              payment_method: "stripe"
            }
          ]);
        }
        if (token.startsWith("jwt-token-")) {
          const parts = token.split("-");
          if (parts.length < 3) {
            return json12({ error: "Invalid token" }, 401);
          }
          const userEmail = parts[2];
          if (!env.DB) {
            return json12({ error: "Database not available" }, 500);
          }
          try {
            const query = `
          SELECT 
            i.id AS id,
            i.invoice_number AS invoice_number,
            i.order_id AS order_id,
            i.customer_name AS customer_name,
            i.customer_email AS customer_email,
            i.invoice_date AS invoice_date,
            i.due_date AS due_date,
            i.subtotal AS subtotal,
            i.tax_amount AS tax_amount,
            i.discount_amount AS discount_amount,
            i.total_amount AS total_amount,
            i.currency AS currency,
            i.status AS status,
            i.paid_at AS paid_at,
            i.notes AS notes,
            i.created_at AS created_at,
            i.updated_at AS updated_at,
            o.payment_method AS payment_method
          FROM invoices i
          LEFT JOIN orders o ON i.order_id = o.id
          WHERE i.customer_email = ?
          ORDER BY i.created_at DESC
        `;
            const invoices2 = await env.DB.prepare(query).bind(userEmail).all();
            return json12(invoices2.results || []);
          } catch (dbError) {
            console.error("Database error in /api/me/invoices:", dbError);
            return json12({ error: "Database error" }, 500);
          }
        }
        return json12({ error: "Invalid token" }, 401);
      } catch (error) {
        return json12({
          error: error.message
        }, 500);
      }
    }, "onRequestGet");
    onRequestOptions41 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
  }
});

// api/me/orders.ts
function json13(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
var onRequestGet47, onRequestOptions42;
var init_orders3 = __esm({
  "api/me/orders.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json13, "json");
    onRequestGet47 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const authHeader = request.headers.get("Authorization");
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          return json13({ error: "Unauthorized" }, 401);
        }
        const token = authHeader.substring(7);
        if (token === "demo-jwt-token") {
          return json13([
            {
              id: 1,
              customerEmail: "demo@example.com",
              customerName: "Demo User",
              originalAmount: "29.99",
              finalAmount: "29.99",
              currency: "eur",
              status: "completed",
              paymentMethod: "stripe",
              downloadToken: "demo-download-token",
              downloadCount: 1,
              maxDownloads: 5,
              activationCode: "DEMO-ACTIVATION-CODE",
              createdAt: (/* @__PURE__ */ new Date()).toISOString(),
              completedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          ]);
        }
        if (token.startsWith("jwt-token-")) {
          const parts = token.split("-");
          if (parts.length >= 3) {
            const userId = parts[2];
            if (!env.DB) {
              return json13({ error: "Database not available" }, 500);
            }
            try {
              const session = env.DB.withSession("first-primary");
              const customer = await session.prepare(`
            SELECT id FROM customers WHERE email = ?
          `).bind(userId).first();
              if (!customer) {
                return json13([]);
              }
              const orders2 = await session.prepare(`
            SELECT 
              id,
              customer_email AS customerEmail,
              customer_name AS customerName,
              original_amount AS originalAmount,
              final_amount AS finalAmount,
              currency,
              status,
              payment_method AS paymentMethod,
              payment_intent_id AS paymentIntentId,
              download_token AS downloadToken,
              download_count AS downloadCount,
              max_downloads AS maxDownloads,
              activation_code AS activationCode,
              invoice_url AS invoiceUrl,
              created_at AS createdAt,
              completed_at AS completedAt
            FROM orders 
            WHERE customer_email = ?
            ORDER BY created_at DESC
          `).bind(userId).all();
              return json13(orders2.results || []);
            } catch (dbError) {
              console.error("Database error in /api/me/orders:", dbError);
              return json13({ error: "Database error" }, 500);
            }
          }
        }
        return json13({ error: "Invalid token" }, 401);
      } catch (error) {
        return json13({
          error: error.message
        }, 500);
      }
    }, "onRequestGet");
    onRequestOptions42 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
  }
});

// api/orders/complete-purchase.ts
var onRequestPost19, onRequestOptions43;
var init_complete_purchase = __esm({
  "api/orders/complete-purchase.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestPost19 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const body = await request.json();
        const { paymentIntentId, customerEmail, customerName, amount, currency } = body;
        if (!paymentIntentId || !customerEmail || !customerName || !amount) {
          return new Response(JSON.stringify({ error: "Missing required fields" }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const downloadToken = crypto.randomUUID();
        const activationCode = Math.random().toString(36).substring(2, 15).toUpperCase();
        const invoiceNumber = `INV-${Date.now()}-${Math.random().toString(36).substring(2, 8).toUpperCase()}`;
        let orderId = null;
        try {
          const orderResult = await env.DB.prepare(`
        INSERT INTO orders (
          customerEmail, customerName, productId, productName,
          originalAmount, finalAmount, currency, status, paymentMethod,
          paymentIntentId, downloadToken, activationCode, invoiceNumber,
          completedAt
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
      `).bind(
            customerEmail,
            customerName,
            1,
            // Product ID for OCUS Extension
            "OCUS Job Hunter Extension",
            amount,
            amount,
            currency.toUpperCase(),
            "completed",
            "stripe",
            paymentIntentId,
            downloadToken,
            activationCode,
            invoiceNumber
          ).run();
          orderId = orderResult.meta?.last_row_id;
        } catch (dbError) {
          console.log("Orders table not found, using fallback storage:", dbError);
          const orderData = {
            id: Date.now(),
            customerEmail,
            customerName,
            productId: 1,
            productName: "OCUS Job Hunter Extension",
            originalAmount: amount,
            finalAmount: amount,
            currency: currency.toUpperCase(),
            status: "completed",
            paymentMethod: "stripe",
            paymentIntentId,
            downloadToken,
            activationCode,
            invoiceNumber,
            completedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          const settingsKey = `order_${paymentIntentId}`;
          await env.DB.prepare(`
        INSERT OR REPLACE INTO settings (key, value, updated_at)
        VALUES (?, ?, datetime('now'))
      `).bind(settingsKey, JSON.stringify(orderData)).run();
          orderId = orderData.id;
        }
        try {
          await env.DB.prepare(`
        INSERT OR REPLACE INTO users (
          email, name, isPremium, lastLoginAt, updatedAt
        ) VALUES (?, ?, 1, datetime('now'), datetime('now'))
      `).bind(customerEmail, customerName).run();
        } catch (userDbError) {
          console.log("Users table not found, using fallback storage:", userDbError);
          const userData = {
            email: customerEmail,
            name: customerName,
            isPremium: true,
            lastLoginAt: (/* @__PURE__ */ new Date()).toISOString(),
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          const userSettingsKey = `user_${customerEmail.replace("@", "_at_").replace(".", "_dot_")}`;
          await env.DB.prepare(`
        INSERT OR REPLACE INTO settings (key, value, updated_at)
        VALUES (?, ?, datetime('now'))
      `).bind(userSettingsKey, JSON.stringify(userData)).run();
        }
        return new Response(JSON.stringify({
          success: true,
          orderId,
          downloadToken,
          activationCode,
          invoiceNumber,
          message: "Purchase completed successfully"
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error completing purchase:", error);
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to complete purchase",
          details: String(error)
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
    onRequestOptions43 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// ../node_modules/drizzle-orm/entity.js
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(
      `Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
    );
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}
var entityKind, hasOwnEntityKind;
var init_entity = __esm({
  "../node_modules/drizzle-orm/entity.js"() {
    init_functionsRoutes_0_8044054200943971();
    entityKind = Symbol.for("drizzle:entityKind");
    hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
    __name(is, "is");
  }
});

// ../node_modules/drizzle-orm/column.js
var Column;
var init_column = __esm({
  "../node_modules/drizzle-orm/column.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    Column = class {
      static {
        __name(this, "Column");
      }
      constructor(table, config) {
        this.table = table;
        this.config = config;
        this.name = config.name;
        this.keyAsName = config.keyAsName;
        this.notNull = config.notNull;
        this.default = config.default;
        this.defaultFn = config.defaultFn;
        this.onUpdateFn = config.onUpdateFn;
        this.hasDefault = config.hasDefault;
        this.primary = config.primaryKey;
        this.isUnique = config.isUnique;
        this.uniqueName = config.uniqueName;
        this.uniqueType = config.uniqueType;
        this.dataType = config.dataType;
        this.columnType = config.columnType;
        this.generated = config.generated;
        this.generatedIdentity = config.generatedIdentity;
      }
      static [entityKind] = "Column";
      name;
      keyAsName;
      primary;
      notNull;
      default;
      defaultFn;
      onUpdateFn;
      hasDefault;
      isUnique;
      uniqueName;
      uniqueType;
      dataType;
      columnType;
      enumValues = void 0;
      generated = void 0;
      generatedIdentity = void 0;
      config;
      mapFromDriverValue(value) {
        return value;
      }
      mapToDriverValue(value) {
        return value;
      }
      // ** @internal */
      shouldDisableInsert() {
        return this.config.generated !== void 0 && this.config.generated.type !== "byDefault";
      }
    };
  }
});

// ../node_modules/drizzle-orm/column-builder.js
var ColumnBuilder;
var init_column_builder = __esm({
  "../node_modules/drizzle-orm/column-builder.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    ColumnBuilder = class {
      static {
        __name(this, "ColumnBuilder");
      }
      static [entityKind] = "ColumnBuilder";
      config;
      constructor(name, dataType, columnType) {
        this.config = {
          name,
          keyAsName: name === "",
          notNull: false,
          default: void 0,
          hasDefault: false,
          primaryKey: false,
          isUnique: false,
          uniqueName: void 0,
          uniqueType: void 0,
          dataType,
          columnType,
          generated: void 0
        };
      }
      /**
       * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
       *
       * @example
       * ```ts
       * const users = pgTable('users', {
       * 	id: integer('id').$type<UserId>().primaryKey(),
       * 	details: json('details').$type<UserDetails>().notNull(),
       * });
       * ```
       */
      $type() {
        return this;
      }
      /**
       * Adds a `not null` clause to the column definition.
       *
       * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
       */
      notNull() {
        this.config.notNull = true;
        return this;
      }
      /**
       * Adds a `default <value>` clause to the column definition.
       *
       * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
       *
       * If you need to set a dynamic default value, use {@link $defaultFn} instead.
       */
      default(value) {
        this.config.default = value;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Adds a dynamic default value to the column.
       * The function will be called when the row is inserted, and the returned value will be used as the column value.
       *
       * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
       */
      $defaultFn(fn) {
        this.config.defaultFn = fn;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Alias for {@link $defaultFn}.
       */
      $default = this.$defaultFn;
      /**
       * Adds a dynamic update value to the column.
       * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.
       * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.
       *
       * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
       */
      $onUpdateFn(fn) {
        this.config.onUpdateFn = fn;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Alias for {@link $onUpdateFn}.
       */
      $onUpdate = this.$onUpdateFn;
      /**
       * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
       *
       * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
       */
      primaryKey() {
        this.config.primaryKey = true;
        this.config.notNull = true;
        return this;
      }
      /** @internal Sets the name of the column to the key within the table definition if a name was not given. */
      setName(name) {
        if (this.config.name !== "")
          return;
        this.config.name = name;
      }
    };
  }
});

// ../node_modules/drizzle-orm/table.utils.js
var TableName;
var init_table_utils = __esm({
  "../node_modules/drizzle-orm/table.utils.js"() {
    init_functionsRoutes_0_8044054200943971();
    TableName = Symbol.for("drizzle:Name");
  }
});

// ../node_modules/drizzle-orm/pg-core/foreign-keys.js
var ForeignKeyBuilder, ForeignKey;
var init_foreign_keys = __esm({
  "../node_modules/drizzle-orm/pg-core/foreign-keys.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_table_utils();
    ForeignKeyBuilder = class {
      static {
        __name(this, "ForeignKeyBuilder");
      }
      static [entityKind] = "PgForeignKeyBuilder";
      /** @internal */
      reference;
      /** @internal */
      _onUpdate = "no action";
      /** @internal */
      _onDelete = "no action";
      constructor(config, actions) {
        this.reference = () => {
          const { name, columns, foreignColumns } = config();
          return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
          this._onUpdate = actions.onUpdate;
          this._onDelete = actions.onDelete;
        }
      }
      onUpdate(action) {
        this._onUpdate = action === void 0 ? "no action" : action;
        return this;
      }
      onDelete(action) {
        this._onDelete = action === void 0 ? "no action" : action;
        return this;
      }
      /** @internal */
      build(table) {
        return new ForeignKey(table, this);
      }
    };
    ForeignKey = class {
      static {
        __name(this, "ForeignKey");
      }
      constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
      }
      static [entityKind] = "PgForeignKey";
      reference;
      onUpdate;
      onDelete;
      getName() {
        const { name, columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
          this.table[TableName],
          ...columnNames,
          foreignColumns[0].table[TableName],
          ...foreignColumnNames
        ];
        return name ?? `${chunks.join("_")}_fk`;
      }
    };
  }
});

// ../node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}
var init_tracing_utils = __esm({
  "../node_modules/drizzle-orm/tracing-utils.js"() {
    init_functionsRoutes_0_8044054200943971();
    __name(iife, "iife");
  }
});

// ../node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}
var UniqueConstraintBuilder, UniqueOnConstraintBuilder, UniqueConstraint;
var init_unique_constraint = __esm({
  "../node_modules/drizzle-orm/pg-core/unique-constraint.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_table_utils();
    __name(uniqueKeyName, "uniqueKeyName");
    UniqueConstraintBuilder = class {
      static {
        __name(this, "UniqueConstraintBuilder");
      }
      constructor(columns, name) {
        this.name = name;
        this.columns = columns;
      }
      static [entityKind] = "PgUniqueConstraintBuilder";
      /** @internal */
      columns;
      /** @internal */
      nullsNotDistinctConfig = false;
      nullsNotDistinct() {
        this.nullsNotDistinctConfig = true;
        return this;
      }
      /** @internal */
      build(table) {
        return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
      }
    };
    UniqueOnConstraintBuilder = class {
      static {
        __name(this, "UniqueOnConstraintBuilder");
      }
      static [entityKind] = "PgUniqueOnConstraintBuilder";
      /** @internal */
      name;
      constructor(name) {
        this.name = name;
      }
      on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
      }
    };
    UniqueConstraint = class {
      static {
        __name(this, "UniqueConstraint");
      }
      constructor(table, columns, nullsNotDistinct, name) {
        this.table = table;
        this.columns = columns;
        this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
        this.nullsNotDistinct = nullsNotDistinct;
      }
      static [entityKind] = "PgUniqueConstraint";
      columns;
      name;
      nullsNotDistinct = false;
      getName() {
        return this.name;
      }
    };
  }
});

// ../node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i = startFrom; i < arrayString.length; i++) {
    const char = arrayString[i];
    if (char === "\\") {
      i++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i = startFrom;
  let lastCharIsComma = false;
  while (i < arrayString.length) {
    const char = arrayString[i];
    if (char === ",") {
      if (lastCharIsComma || i === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i + 1);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
    result.push(value);
    i = newStartFrom;
  }
  return [result, i];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}
var init_array = __esm({
  "../node_modules/drizzle-orm/pg-core/utils/array.js"() {
    init_functionsRoutes_0_8044054200943971();
    __name(parsePgArrayValue, "parsePgArrayValue");
    __name(parsePgNestedArray, "parsePgNestedArray");
    __name(parsePgArray, "parsePgArray");
    __name(makePgArray, "makePgArray");
  }
});

// ../node_modules/drizzle-orm/pg-core/columns/common.js
var PgColumnBuilder, PgColumn, ExtraConfigColumn, IndexedColumn, PgArrayBuilder, PgArray;
var init_common = __esm({
  "../node_modules/drizzle-orm/pg-core/columns/common.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_column_builder();
    init_column();
    init_entity();
    init_foreign_keys();
    init_tracing_utils();
    init_unique_constraint();
    init_array();
    PgColumnBuilder = class extends ColumnBuilder {
      static {
        __name(this, "PgColumnBuilder");
      }
      foreignKeyConfigs = [];
      static [entityKind] = "PgColumnBuilder";
      array(size) {
        return new PgArrayBuilder(this.config.name, this, size);
      }
      references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
      }
      unique(name, config) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        this.config.uniqueType = config?.nulls;
        return this;
      }
      generatedAlwaysAs(as) {
        this.config.generated = {
          as,
          type: "always",
          mode: "stored"
        };
        return this;
      }
      /** @internal */
      buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
          return iife(
            (ref2, actions2) => {
              const builder = new ForeignKeyBuilder(() => {
                const foreignColumn = ref2();
                return { columns: [column], foreignColumns: [foreignColumn] };
              });
              if (actions2.onUpdate) {
                builder.onUpdate(actions2.onUpdate);
              }
              if (actions2.onDelete) {
                builder.onDelete(actions2.onDelete);
              }
              return builder.build(table);
            },
            ref,
            actions
          );
        });
      }
      /** @internal */
      buildExtraConfigColumn(table) {
        return new ExtraConfigColumn(table, this.config);
      }
    };
    PgColumn = class extends Column {
      static {
        __name(this, "PgColumn");
      }
      constructor(table, config) {
        if (!config.uniqueName) {
          config.uniqueName = uniqueKeyName(table, [config.name]);
        }
        super(table, config);
        this.table = table;
      }
      static [entityKind] = "PgColumn";
    };
    ExtraConfigColumn = class extends PgColumn {
      static {
        __name(this, "ExtraConfigColumn");
      }
      static [entityKind] = "ExtraConfigColumn";
      getSQLType() {
        return this.getSQLType();
      }
      indexConfig = {
        order: this.config.order ?? "asc",
        nulls: this.config.nulls ?? "last",
        opClass: this.config.opClass
      };
      defaultConfig = {
        order: "asc",
        nulls: "last",
        opClass: void 0
      };
      asc() {
        this.indexConfig.order = "asc";
        return this;
      }
      desc() {
        this.indexConfig.order = "desc";
        return this;
      }
      nullsFirst() {
        this.indexConfig.nulls = "first";
        return this;
      }
      nullsLast() {
        this.indexConfig.nulls = "last";
        return this;
      }
      /**
       * ### PostgreSQL documentation quote
       *
       * > An operator class with optional parameters can be specified for each column of an index.
       * The operator class identifies the operators to be used by the index for that column.
       * For example, a B-tree index on four-byte integers would use the int4_ops class;
       * this operator class includes comparison functions for four-byte integers.
       * In practice the default operator class for the column's data type is usually sufficient.
       * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.
       * For example, we might want to sort a complex-number data type either by absolute value or by real part.
       * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.
       * More information about operator classes check:
       *
       * ### Useful links
       * https://www.postgresql.org/docs/current/sql-createindex.html
       *
       * https://www.postgresql.org/docs/current/indexes-opclass.html
       *
       * https://www.postgresql.org/docs/current/xindex.html
       *
       * ### Additional types
       * If you have the `pg_vector` extension installed in your database, you can use the
       * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.
       *
       * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**
       *
       * @param opClass
       * @returns
       */
      op(opClass) {
        this.indexConfig.opClass = opClass;
        return this;
      }
    };
    IndexedColumn = class {
      static {
        __name(this, "IndexedColumn");
      }
      static [entityKind] = "IndexedColumn";
      constructor(name, keyAsName, type, indexConfig) {
        this.name = name;
        this.keyAsName = keyAsName;
        this.type = type;
        this.indexConfig = indexConfig;
      }
      name;
      keyAsName;
      type;
      indexConfig;
    };
    PgArrayBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgArrayBuilder");
      }
      static [entityKind] = "PgArrayBuilder";
      constructor(name, baseBuilder, size) {
        super(name, "array", "PgArray");
        this.config.baseBuilder = baseBuilder;
        this.config.size = size;
      }
      /** @internal */
      build(table) {
        const baseColumn = this.config.baseBuilder.build(table);
        return new PgArray(
          table,
          this.config,
          baseColumn
        );
      }
    };
    PgArray = class _PgArray extends PgColumn {
      static {
        __name(this, "PgArray");
      }
      constructor(table, config, baseColumn, range) {
        super(table, config);
        this.baseColumn = baseColumn;
        this.range = range;
        this.size = config.size;
      }
      size;
      static [entityKind] = "PgArray";
      getSQLType() {
        return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          value = parsePgArray(value);
        }
        return value.map((v) => this.baseColumn.mapFromDriverValue(v));
      }
      mapToDriverValue(value, isNestedArray = false) {
        const a = value.map(
          (v) => v === null ? null : is(this.baseColumn, _PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v)
        );
        if (isNestedArray)
          return a;
        return makePgArray(a);
      }
    };
  }
});

// ../node_modules/drizzle-orm/pg-core/columns/enum.js
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
var isPgEnumSym, PgEnumColumnBuilder, PgEnumColumn;
var init_enum = __esm({
  "../node_modules/drizzle-orm/pg-core/columns/enum.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_common();
    isPgEnumSym = Symbol.for("drizzle:isPgEnum");
    __name(isPgEnum, "isPgEnum");
    PgEnumColumnBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgEnumColumnBuilder");
      }
      static [entityKind] = "PgEnumColumnBuilder";
      constructor(name, enumInstance) {
        super(name, "string", "PgEnumColumn");
        this.config.enum = enumInstance;
      }
      /** @internal */
      build(table) {
        return new PgEnumColumn(
          table,
          this.config
        );
      }
    };
    PgEnumColumn = class extends PgColumn {
      static {
        __name(this, "PgEnumColumn");
      }
      static [entityKind] = "PgEnumColumn";
      enum = this.config.enum;
      enumValues = this.config.enum.enumValues;
      constructor(table, config) {
        super(table, config);
        this.enum = config.enum;
      }
      getSQLType() {
        return this.enum.enumName;
      }
    };
  }
});

// ../node_modules/drizzle-orm/subquery.js
var Subquery, WithSubquery;
var init_subquery = __esm({
  "../node_modules/drizzle-orm/subquery.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    Subquery = class {
      static {
        __name(this, "Subquery");
      }
      static [entityKind] = "Subquery";
      constructor(sql2, selection, alias, isWith = false) {
        this._ = {
          brand: "Subquery",
          sql: sql2,
          selectedFields: selection,
          alias,
          isWith
        };
      }
      // getSQL(): SQL<unknown> {
      // 	return new SQL([this]);
      // }
    };
    WithSubquery = class extends Subquery {
      static {
        __name(this, "WithSubquery");
      }
      static [entityKind] = "WithSubquery";
    };
  }
});

// ../node_modules/drizzle-orm/version.js
var version;
var init_version = __esm({
  "../node_modules/drizzle-orm/version.js"() {
    init_functionsRoutes_0_8044054200943971();
    version = "0.39.1";
  }
});

// ../node_modules/drizzle-orm/tracing.js
var otel, rawTracer, tracer;
var init_tracing = __esm({
  "../node_modules/drizzle-orm/tracing.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_tracing_utils();
    init_version();
    tracer = {
      startActiveSpan(name, fn) {
        if (!otel) {
          return fn();
        }
        if (!rawTracer) {
          rawTracer = otel.trace.getTracer("drizzle-orm", version);
        }
        return iife(
          (otel2, rawTracer2) => rawTracer2.startActiveSpan(
            name,
            (span) => {
              try {
                return fn(span);
              } catch (e) {
                span.setStatus({
                  code: otel2.SpanStatusCode.ERROR,
                  message: e instanceof Error ? e.message : "Unknown error"
                  // eslint-disable-line no-instanceof/no-instanceof
                });
                throw e;
              } finally {
                span.end();
              }
            }
          ),
          otel,
          rawTracer
        );
      }
    };
  }
});

// ../node_modules/drizzle-orm/view-common.js
var ViewBaseConfig;
var init_view_common = __esm({
  "../node_modules/drizzle-orm/view-common.js"() {
    init_functionsRoutes_0_8044054200943971();
    ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");
  }
});

// ../node_modules/drizzle-orm/table.js
function isTable(table) {
  return typeof table === "object" && table !== null && IsDrizzleTable in table;
}
function getTableName(table) {
  return table[TableName];
}
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}
var Schema, Columns, ExtraConfigColumns, OriginalName, BaseName, IsAlias, ExtraConfigBuilder, IsDrizzleTable, Table;
var init_table = __esm({
  "../node_modules/drizzle-orm/table.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_table_utils();
    Schema = Symbol.for("drizzle:Schema");
    Columns = Symbol.for("drizzle:Columns");
    ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
    OriginalName = Symbol.for("drizzle:OriginalName");
    BaseName = Symbol.for("drizzle:BaseName");
    IsAlias = Symbol.for("drizzle:IsAlias");
    ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
    IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
    Table = class {
      static {
        __name(this, "Table");
      }
      static [entityKind] = "Table";
      /** @internal */
      static Symbol = {
        Name: TableName,
        Schema,
        OriginalName,
        Columns,
        ExtraConfigColumns,
        BaseName,
        IsAlias,
        ExtraConfigBuilder
      };
      /**
       * @internal
       * Can be changed if the table is aliased.
       */
      [TableName];
      /**
       * @internal
       * Used to store the original name of the table, before any aliasing.
       */
      [OriginalName];
      /** @internal */
      [Schema];
      /** @internal */
      [Columns];
      /** @internal */
      [ExtraConfigColumns];
      /**
       *  @internal
       * Used to store the table name before the transformation via the `tableCreator` functions.
       */
      [BaseName];
      /** @internal */
      [IsAlias] = false;
      /** @internal */
      [IsDrizzleTable] = true;
      /** @internal */
      [ExtraConfigBuilder] = void 0;
      constructor(name, schema, baseName) {
        this[TableName] = this[OriginalName] = name;
        this[Schema] = schema;
        this[BaseName] = baseName;
      }
    };
    __name(isTable, "isTable");
    __name(getTableName, "getTableName");
    __name(getTableUniqueName, "getTableUniqueName");
  }
});

// ../node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return value !== null && value !== void 0 && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
function fillPlaceholders(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    if (is(p, Param) && is(p.value, Placeholder)) {
      if (!(p.value.name in values)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values[p.value.name]);
    }
    return p;
  });
}
function isView(view) {
  return typeof view === "object" && view !== null && IsDrizzleView in view;
}
var FakePrimitiveParam, StringChunk, SQL, Name, noopDecoder, noopEncoder, noopMapper, Param, Placeholder, IsDrizzleView, View;
var init_sql = __esm({
  "../node_modules/drizzle-orm/sql/sql.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_enum();
    init_subquery();
    init_tracing();
    init_view_common();
    init_column();
    init_table();
    FakePrimitiveParam = class {
      static {
        __name(this, "FakePrimitiveParam");
      }
      static [entityKind] = "FakePrimitiveParam";
    };
    __name(isSQLWrapper, "isSQLWrapper");
    __name(mergeQueries, "mergeQueries");
    StringChunk = class {
      static {
        __name(this, "StringChunk");
      }
      static [entityKind] = "StringChunk";
      value;
      constructor(value) {
        this.value = Array.isArray(value) ? value : [value];
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    SQL = class _SQL {
      static {
        __name(this, "SQL");
      }
      constructor(queryChunks) {
        this.queryChunks = queryChunks;
      }
      static [entityKind] = "SQL";
      /** @internal */
      decoder = noopDecoder;
      shouldInlineParams = false;
      append(query) {
        this.queryChunks.push(...query.queryChunks);
        return this;
      }
      toQuery(config) {
        return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
          const query = this.buildQueryFromSourceParams(this.queryChunks, config);
          span?.setAttributes({
            "drizzle.query.text": query.sql,
            "drizzle.query.params": JSON.stringify(query.params)
          });
          return query;
        });
      }
      buildQueryFromSourceParams(chunks, _config) {
        const config = Object.assign({}, _config, {
          inlineParams: _config.inlineParams || this.shouldInlineParams,
          paramStartIndex: _config.paramStartIndex || { value: 0 }
        });
        const {
          casing,
          escapeName,
          escapeParam,
          prepareTyping,
          inlineParams,
          paramStartIndex
        } = config;
        return mergeQueries(chunks.map((chunk) => {
          if (is(chunk, StringChunk)) {
            return { sql: chunk.value.join(""), params: [] };
          }
          if (is(chunk, Name)) {
            return { sql: escapeName(chunk.value), params: [] };
          }
          if (chunk === void 0) {
            return { sql: "", params: [] };
          }
          if (Array.isArray(chunk)) {
            const result = [new StringChunk("(")];
            for (const [i, p] of chunk.entries()) {
              result.push(p);
              if (i < chunk.length - 1) {
                result.push(new StringChunk(", "));
              }
            }
            result.push(new StringChunk(")"));
            return this.buildQueryFromSourceParams(result, config);
          }
          if (is(chunk, _SQL)) {
            return this.buildQueryFromSourceParams(chunk.queryChunks, {
              ...config,
              inlineParams: inlineParams || chunk.shouldInlineParams
            });
          }
          if (is(chunk, Table)) {
            const schemaName = chunk[Table.Symbol.Schema];
            const tableName = chunk[Table.Symbol.Name];
            return {
              sql: schemaName === void 0 || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
              params: []
            };
          }
          if (is(chunk, Column)) {
            const columnName = casing.getColumnCasing(chunk);
            if (_config.invokeSource === "indexes") {
              return { sql: escapeName(columnName), params: [] };
            }
            const schemaName = chunk.table[Table.Symbol.Schema];
            return {
              sql: chunk.table[IsAlias] || schemaName === void 0 ? escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName),
              params: []
            };
          }
          if (is(chunk, View)) {
            const schemaName = chunk[ViewBaseConfig].schema;
            const viewName = chunk[ViewBaseConfig].name;
            return {
              sql: schemaName === void 0 || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
              params: []
            };
          }
          if (is(chunk, Param)) {
            if (is(chunk.value, Placeholder)) {
              return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
            }
            const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
            if (is(mappedValue, _SQL)) {
              return this.buildQueryFromSourceParams([mappedValue], config);
            }
            if (inlineParams) {
              return { sql: this.mapInlineParam(mappedValue, config), params: [] };
            }
            let typings = ["none"];
            if (prepareTyping) {
              typings = [prepareTyping(chunk.encoder)];
            }
            return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
          }
          if (is(chunk, Placeholder)) {
            return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
          }
          if (is(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
            return { sql: escapeName(chunk.fieldAlias), params: [] };
          }
          if (is(chunk, Subquery)) {
            if (chunk._.isWith) {
              return { sql: escapeName(chunk._.alias), params: [] };
            }
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk._.sql,
              new StringChunk(") "),
              new Name(chunk._.alias)
            ], config);
          }
          if (isPgEnum(chunk)) {
            if (chunk.schema) {
              return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
            }
            return { sql: escapeName(chunk.enumName), params: [] };
          }
          if (isSQLWrapper(chunk)) {
            if (chunk.shouldOmitSQLParens?.()) {
              return this.buildQueryFromSourceParams([chunk.getSQL()], config);
            }
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk.getSQL(),
              new StringChunk(")")
            ], config);
          }
          if (inlineParams) {
            return { sql: this.mapInlineParam(chunk, config), params: [] };
          }
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }));
      }
      mapInlineParam(chunk, { escapeString: escapeString2 }) {
        if (chunk === null) {
          return "null";
        }
        if (typeof chunk === "number" || typeof chunk === "boolean") {
          return chunk.toString();
        }
        if (typeof chunk === "string") {
          return escapeString2(chunk);
        }
        if (typeof chunk === "object") {
          const mappedValueAsString = chunk.toString();
          if (mappedValueAsString === "[object Object]") {
            return escapeString2(JSON.stringify(chunk));
          }
          return escapeString2(mappedValueAsString);
        }
        throw new Error("Unexpected param value: " + chunk);
      }
      getSQL() {
        return this;
      }
      as(alias) {
        if (alias === void 0) {
          return this;
        }
        return new _SQL.Aliased(this, alias);
      }
      mapWith(decoder) {
        this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
        return this;
      }
      inlineParams() {
        this.shouldInlineParams = true;
        return this;
      }
      /**
       * This method is used to conditionally include a part of the query.
       *
       * @param condition - Condition to check
       * @returns itself if the condition is `true`, otherwise `undefined`
       */
      if(condition) {
        return condition ? this : void 0;
      }
    };
    Name = class {
      static {
        __name(this, "Name");
      }
      constructor(value) {
        this.value = value;
      }
      static [entityKind] = "Name";
      brand;
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(isDriverValueEncoder, "isDriverValueEncoder");
    noopDecoder = {
      mapFromDriverValue: /* @__PURE__ */ __name((value) => value, "mapFromDriverValue")
    };
    noopEncoder = {
      mapToDriverValue: /* @__PURE__ */ __name((value) => value, "mapToDriverValue")
    };
    noopMapper = {
      ...noopDecoder,
      ...noopEncoder
    };
    Param = class {
      static {
        __name(this, "Param");
      }
      /**
       * @param value - Parameter value
       * @param encoder - Encoder to convert the value to a driver parameter
       */
      constructor(value, encoder = noopEncoder) {
        this.value = value;
        this.encoder = encoder;
      }
      static [entityKind] = "Param";
      brand;
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(sql, "sql");
    ((sql2) => {
      function empty() {
        return new SQL([]);
      }
      __name(empty, "empty");
      sql2.empty = empty;
      function fromList(list) {
        return new SQL(list);
      }
      __name(fromList, "fromList");
      sql2.fromList = fromList;
      function raw(str) {
        return new SQL([new StringChunk(str)]);
      }
      __name(raw, "raw");
      sql2.raw = raw;
      function join(chunks, separator) {
        const result = [];
        for (const [i, chunk] of chunks.entries()) {
          if (i > 0 && separator !== void 0) {
            result.push(separator);
          }
          result.push(chunk);
        }
        return new SQL(result);
      }
      __name(join, "join");
      sql2.join = join;
      function identifier(value) {
        return new Name(value);
      }
      __name(identifier, "identifier");
      sql2.identifier = identifier;
      function placeholder2(name2) {
        return new Placeholder(name2);
      }
      __name(placeholder2, "placeholder2");
      sql2.placeholder = placeholder2;
      function param2(value, encoder) {
        return new Param(value, encoder);
      }
      __name(param2, "param2");
      sql2.param = param2;
    })(sql || (sql = {}));
    ((SQL2) => {
      class Aliased {
        static {
          __name(this, "Aliased");
        }
        constructor(sql2, fieldAlias) {
          this.sql = sql2;
          this.fieldAlias = fieldAlias;
        }
        static [entityKind] = "SQL.Aliased";
        /** @internal */
        isSelectionField = false;
        getSQL() {
          return this.sql;
        }
        /** @internal */
        clone() {
          return new Aliased(this.sql, this.fieldAlias);
        }
      }
      SQL2.Aliased = Aliased;
    })(SQL || (SQL = {}));
    Placeholder = class {
      static {
        __name(this, "Placeholder");
      }
      constructor(name2) {
        this.name = name2;
      }
      static [entityKind] = "Placeholder";
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(fillPlaceholders, "fillPlaceholders");
    IsDrizzleView = Symbol.for("drizzle:IsDrizzleView");
    View = class {
      static {
        __name(this, "View");
      }
      static [entityKind] = "View";
      /** @internal */
      [ViewBaseConfig];
      /** @internal */
      [IsDrizzleView] = true;
      constructor({ name: name2, schema, selectedFields, query }) {
        this[ViewBaseConfig] = {
          name: name2,
          originalName: name2,
          schema,
          selectedFields,
          query,
          isExisting: !query,
          isAlias: false
        };
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(isView, "isView");
    Column.prototype.getSQL = function() {
      return new SQL([this]);
    };
    Table.prototype.getSQL = function() {
      return new SQL([this]);
    };
    Subquery.prototype.getSQL = function() {
      return new SQL([this]);
    };
  }
});

// ../node_modules/drizzle-orm/alias.js
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(
    column,
    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))
  );
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}
var ColumnAliasProxyHandler, TableAliasProxyHandler, RelationTableAliasProxyHandler;
var init_alias = __esm({
  "../node_modules/drizzle-orm/alias.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_column();
    init_entity();
    init_sql();
    init_table();
    init_view_common();
    ColumnAliasProxyHandler = class {
      static {
        __name(this, "ColumnAliasProxyHandler");
      }
      constructor(table) {
        this.table = table;
      }
      static [entityKind] = "ColumnAliasProxyHandler";
      get(columnObj, prop) {
        if (prop === "table") {
          return this.table;
        }
        return columnObj[prop];
      }
    };
    TableAliasProxyHandler = class {
      static {
        __name(this, "TableAliasProxyHandler");
      }
      constructor(alias, replaceOriginalName) {
        this.alias = alias;
        this.replaceOriginalName = replaceOriginalName;
      }
      static [entityKind] = "TableAliasProxyHandler";
      get(target, prop) {
        if (prop === Table.Symbol.IsAlias) {
          return true;
        }
        if (prop === Table.Symbol.Name) {
          return this.alias;
        }
        if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
          return this.alias;
        }
        if (prop === ViewBaseConfig) {
          return {
            ...target[ViewBaseConfig],
            name: this.alias,
            isAlias: true
          };
        }
        if (prop === Table.Symbol.Columns) {
          const columns = target[Table.Symbol.Columns];
          if (!columns) {
            return columns;
          }
          const proxiedColumns = {};
          Object.keys(columns).map((key) => {
            proxiedColumns[key] = new Proxy(
              columns[key],
              new ColumnAliasProxyHandler(new Proxy(target, this))
            );
          });
          return proxiedColumns;
        }
        const value = target[prop];
        if (is(value, Column)) {
          return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
        }
        return value;
      }
    };
    RelationTableAliasProxyHandler = class {
      static {
        __name(this, "RelationTableAliasProxyHandler");
      }
      constructor(alias) {
        this.alias = alias;
      }
      static [entityKind] = "RelationTableAliasProxyHandler";
      get(target, prop) {
        if (prop === "sourceTable") {
          return aliasedTable(target.sourceTable, this.alias);
        }
        return target[prop];
      }
    };
    __name(aliasedTable, "aliasedTable");
    __name(aliasedTableColumn, "aliasedTableColumn");
    __name(mapColumnsInAliasedSQLToAlias, "mapColumnsInAliasedSQLToAlias");
    __name(mapColumnsInSQLToAlias, "mapColumnsInSQLToAlias");
  }
});

// ../node_modules/drizzle-orm/sqlite-core/alias.js
var init_alias2 = __esm({
  "../node_modules/drizzle-orm/sqlite-core/alias.js"() {
    init_functionsRoutes_0_8044054200943971();
  }
});

// ../node_modules/drizzle-orm/sqlite-core/checks.js
var CheckBuilder, Check;
var init_checks = __esm({
  "../node_modules/drizzle-orm/sqlite-core/checks.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    CheckBuilder = class {
      static {
        __name(this, "CheckBuilder");
      }
      constructor(name, value) {
        this.name = name;
        this.value = value;
      }
      static [entityKind] = "SQLiteCheckBuilder";
      brand;
      build(table) {
        return new Check(table, this);
      }
    };
    Check = class {
      static {
        __name(this, "Check");
      }
      constructor(table, builder) {
        this.table = table;
        this.name = builder.name;
        this.value = builder.value;
      }
      static [entityKind] = "SQLiteCheck";
      name;
      value;
    };
  }
});

// ../node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce(
    (result2, { path, field }, columnIndex) => {
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      let node = result2;
      for (const [pathChunkIndex, pathChunk] of path.entries()) {
        if (pathChunkIndex < path.length - 1) {
          if (!(pathChunk in node)) {
            node[pathChunk] = {};
          }
          node = node[pathChunk];
        } else {
          const rawValue = row[columnIndex];
          const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
          if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
            const objectName = path[0];
            if (!(objectName in nullifyMap)) {
              nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
            } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
              nullifyMap[objectName] = false;
            }
          }
        }
      }
      return result2;
    },
    {}
  );
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key, value]) => {
    if (is(value, SQL) || is(value, Column)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(
        baseClass.prototype,
        name,
        Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null)
      );
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getViewSelectedFields(view) {
  return view[ViewBaseConfig].selectedFields;
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a, b) {
  return {
    name: typeof a === "string" && a.length > 0 ? a : "",
    config: typeof a === "object" ? a : b
  };
}
var init_utils = __esm({
  "../node_modules/drizzle-orm/utils.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_column();
    init_entity();
    init_sql();
    init_subquery();
    init_table();
    init_view_common();
    __name(mapResultRow, "mapResultRow");
    __name(orderSelectedFields, "orderSelectedFields");
    __name(haveSameKeys, "haveSameKeys");
    __name(mapUpdateSet, "mapUpdateSet");
    __name(applyMixins, "applyMixins");
    __name(getTableColumns, "getTableColumns");
    __name(getViewSelectedFields, "getViewSelectedFields");
    __name(getTableLikeName, "getTableLikeName");
    __name(getColumnNameAndConfig, "getColumnNameAndConfig");
  }
});

// ../node_modules/drizzle-orm/sqlite-core/foreign-keys.js
var ForeignKeyBuilder2, ForeignKey2;
var init_foreign_keys2 = __esm({
  "../node_modules/drizzle-orm/sqlite-core/foreign-keys.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_table_utils();
    ForeignKeyBuilder2 = class {
      static {
        __name(this, "ForeignKeyBuilder");
      }
      static [entityKind] = "SQLiteForeignKeyBuilder";
      /** @internal */
      reference;
      /** @internal */
      _onUpdate;
      /** @internal */
      _onDelete;
      constructor(config, actions) {
        this.reference = () => {
          const { name, columns, foreignColumns } = config();
          return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
          this._onUpdate = actions.onUpdate;
          this._onDelete = actions.onDelete;
        }
      }
      onUpdate(action) {
        this._onUpdate = action;
        return this;
      }
      onDelete(action) {
        this._onDelete = action;
        return this;
      }
      /** @internal */
      build(table) {
        return new ForeignKey2(table, this);
      }
    };
    ForeignKey2 = class {
      static {
        __name(this, "ForeignKey");
      }
      constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
      }
      static [entityKind] = "SQLiteForeignKey";
      reference;
      onUpdate;
      onDelete;
      getName() {
        const { name, columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
          this.table[TableName],
          ...columnNames,
          foreignColumns[0].table[TableName],
          ...foreignColumnNames
        ];
        return name ?? `${chunks.join("_")}_fk`;
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/unique-constraint.js
function uniqueKeyName2(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}
var UniqueConstraintBuilder2, UniqueOnConstraintBuilder2, UniqueConstraint2;
var init_unique_constraint2 = __esm({
  "../node_modules/drizzle-orm/sqlite-core/unique-constraint.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_table_utils();
    __name(uniqueKeyName2, "uniqueKeyName");
    UniqueConstraintBuilder2 = class {
      static {
        __name(this, "UniqueConstraintBuilder");
      }
      constructor(columns, name) {
        this.name = name;
        this.columns = columns;
      }
      static [entityKind] = "SQLiteUniqueConstraintBuilder";
      /** @internal */
      columns;
      /** @internal */
      build(table) {
        return new UniqueConstraint2(table, this.columns, this.name);
      }
    };
    UniqueOnConstraintBuilder2 = class {
      static {
        __name(this, "UniqueOnConstraintBuilder");
      }
      static [entityKind] = "SQLiteUniqueOnConstraintBuilder";
      /** @internal */
      name;
      constructor(name) {
        this.name = name;
      }
      on(...columns) {
        return new UniqueConstraintBuilder2(columns, this.name);
      }
    };
    UniqueConstraint2 = class {
      static {
        __name(this, "UniqueConstraint");
      }
      constructor(table, columns, name) {
        this.table = table;
        this.columns = columns;
        this.name = name ?? uniqueKeyName2(this.table, this.columns.map((column) => column.name));
      }
      static [entityKind] = "SQLiteUniqueConstraint";
      columns;
      name;
      getName() {
        return this.name;
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/columns/common.js
var SQLiteColumnBuilder, SQLiteColumn;
var init_common2 = __esm({
  "../node_modules/drizzle-orm/sqlite-core/columns/common.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_column_builder();
    init_column();
    init_entity();
    init_foreign_keys2();
    init_unique_constraint2();
    SQLiteColumnBuilder = class extends ColumnBuilder {
      static {
        __name(this, "SQLiteColumnBuilder");
      }
      static [entityKind] = "SQLiteColumnBuilder";
      foreignKeyConfigs = [];
      references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
      }
      unique(name) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        return this;
      }
      generatedAlwaysAs(as, config) {
        this.config.generated = {
          as,
          type: "always",
          mode: config?.mode ?? "virtual"
        };
        return this;
      }
      /** @internal */
      buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
          return ((ref2, actions2) => {
            const builder = new ForeignKeyBuilder2(() => {
              const foreignColumn = ref2();
              return { columns: [column], foreignColumns: [foreignColumn] };
            });
            if (actions2.onUpdate) {
              builder.onUpdate(actions2.onUpdate);
            }
            if (actions2.onDelete) {
              builder.onDelete(actions2.onDelete);
            }
            return builder.build(table);
          })(ref, actions);
        });
      }
    };
    SQLiteColumn = class extends Column {
      static {
        __name(this, "SQLiteColumn");
      }
      constructor(table, config) {
        if (!config.uniqueName) {
          config.uniqueName = uniqueKeyName2(table, [config.name]);
        }
        super(table, config);
        this.table = table;
      }
      static [entityKind] = "SQLiteColumn";
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/columns/blob.js
function blob(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "json") {
    return new SQLiteBlobJsonBuilder(name);
  }
  if (config?.mode === "bigint") {
    return new SQLiteBigIntBuilder(name);
  }
  return new SQLiteBlobBufferBuilder(name);
}
var SQLiteBigIntBuilder, SQLiteBigInt, SQLiteBlobJsonBuilder, SQLiteBlobJson, SQLiteBlobBufferBuilder, SQLiteBlobBuffer;
var init_blob = __esm({
  "../node_modules/drizzle-orm/sqlite-core/columns/blob.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_utils();
    init_common2();
    SQLiteBigIntBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteBigIntBuilder");
      }
      static [entityKind] = "SQLiteBigIntBuilder";
      constructor(name) {
        super(name, "bigint", "SQLiteBigInt");
      }
      /** @internal */
      build(table) {
        return new SQLiteBigInt(table, this.config);
      }
    };
    SQLiteBigInt = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteBigInt");
      }
      static [entityKind] = "SQLiteBigInt";
      getSQLType() {
        return "blob";
      }
      mapFromDriverValue(value) {
        if (Buffer.isBuffer(value)) {
          return BigInt(value.toString());
        }
        if (value instanceof ArrayBuffer) {
          const decoder = new TextDecoder();
          return BigInt(decoder.decode(value));
        }
        return BigInt(String.fromCodePoint(...value));
      }
      mapToDriverValue(value) {
        return Buffer.from(value.toString());
      }
    };
    SQLiteBlobJsonBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteBlobJsonBuilder");
      }
      static [entityKind] = "SQLiteBlobJsonBuilder";
      constructor(name) {
        super(name, "json", "SQLiteBlobJson");
      }
      /** @internal */
      build(table) {
        return new SQLiteBlobJson(
          table,
          this.config
        );
      }
    };
    SQLiteBlobJson = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteBlobJson");
      }
      static [entityKind] = "SQLiteBlobJson";
      getSQLType() {
        return "blob";
      }
      mapFromDriverValue(value) {
        if (Buffer.isBuffer(value)) {
          return JSON.parse(value.toString());
        }
        if (value instanceof ArrayBuffer) {
          const decoder = new TextDecoder();
          return JSON.parse(decoder.decode(value));
        }
        return JSON.parse(String.fromCodePoint(...value));
      }
      mapToDriverValue(value) {
        return Buffer.from(JSON.stringify(value));
      }
    };
    SQLiteBlobBufferBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteBlobBufferBuilder");
      }
      static [entityKind] = "SQLiteBlobBufferBuilder";
      constructor(name) {
        super(name, "buffer", "SQLiteBlobBuffer");
      }
      /** @internal */
      build(table) {
        return new SQLiteBlobBuffer(table, this.config);
      }
    };
    SQLiteBlobBuffer = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteBlobBuffer");
      }
      static [entityKind] = "SQLiteBlobBuffer";
      getSQLType() {
        return "blob";
      }
    };
    __name(blob, "blob");
  }
});

// ../node_modules/drizzle-orm/sqlite-core/columns/custom.js
function customType(customTypeParams) {
  return (a, b) => {
    const { name, config } = getColumnNameAndConfig(a, b);
    return new SQLiteCustomColumnBuilder(
      name,
      config,
      customTypeParams
    );
  };
}
var SQLiteCustomColumnBuilder, SQLiteCustomColumn;
var init_custom = __esm({
  "../node_modules/drizzle-orm/sqlite-core/columns/custom.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_utils();
    init_common2();
    SQLiteCustomColumnBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteCustomColumnBuilder");
      }
      static [entityKind] = "SQLiteCustomColumnBuilder";
      constructor(name, fieldConfig, customTypeParams) {
        super(name, "custom", "SQLiteCustomColumn");
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
      }
      /** @internal */
      build(table) {
        return new SQLiteCustomColumn(
          table,
          this.config
        );
      }
    };
    SQLiteCustomColumn = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteCustomColumn");
      }
      static [entityKind] = "SQLiteCustomColumn";
      sqlName;
      mapTo;
      mapFrom;
      constructor(table, config) {
        super(table, config);
        this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
        this.mapTo = config.customTypeParams.toDriver;
        this.mapFrom = config.customTypeParams.fromDriver;
      }
      getSQLType() {
        return this.sqlName;
      }
      mapFromDriverValue(value) {
        return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
      }
      mapToDriverValue(value) {
        return typeof this.mapTo === "function" ? this.mapTo(value) : value;
      }
    };
    __name(customType, "customType");
  }
});

// ../node_modules/drizzle-orm/sqlite-core/columns/integer.js
function integer(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "timestamp" || config?.mode === "timestamp_ms") {
    return new SQLiteTimestampBuilder(name, config.mode);
  }
  if (config?.mode === "boolean") {
    return new SQLiteBooleanBuilder(name, config.mode);
  }
  return new SQLiteIntegerBuilder(name);
}
var SQLiteBaseIntegerBuilder, SQLiteBaseInteger, SQLiteIntegerBuilder, SQLiteInteger, SQLiteTimestampBuilder, SQLiteTimestamp, SQLiteBooleanBuilder, SQLiteBoolean;
var init_integer = __esm({
  "../node_modules/drizzle-orm/sqlite-core/columns/integer.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_sql();
    init_utils();
    init_common2();
    SQLiteBaseIntegerBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteBaseIntegerBuilder");
      }
      static [entityKind] = "SQLiteBaseIntegerBuilder";
      constructor(name, dataType, columnType) {
        super(name, dataType, columnType);
        this.config.autoIncrement = false;
      }
      primaryKey(config) {
        if (config?.autoIncrement) {
          this.config.autoIncrement = true;
        }
        this.config.hasDefault = true;
        return super.primaryKey();
      }
    };
    SQLiteBaseInteger = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteBaseInteger");
      }
      static [entityKind] = "SQLiteBaseInteger";
      autoIncrement = this.config.autoIncrement;
      getSQLType() {
        return "integer";
      }
    };
    SQLiteIntegerBuilder = class extends SQLiteBaseIntegerBuilder {
      static {
        __name(this, "SQLiteIntegerBuilder");
      }
      static [entityKind] = "SQLiteIntegerBuilder";
      constructor(name) {
        super(name, "number", "SQLiteInteger");
      }
      build(table) {
        return new SQLiteInteger(
          table,
          this.config
        );
      }
    };
    SQLiteInteger = class extends SQLiteBaseInteger {
      static {
        __name(this, "SQLiteInteger");
      }
      static [entityKind] = "SQLiteInteger";
    };
    SQLiteTimestampBuilder = class extends SQLiteBaseIntegerBuilder {
      static {
        __name(this, "SQLiteTimestampBuilder");
      }
      static [entityKind] = "SQLiteTimestampBuilder";
      constructor(name, mode) {
        super(name, "date", "SQLiteTimestamp");
        this.config.mode = mode;
      }
      /**
       * @deprecated Use `default()` with your own expression instead.
       *
       * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.
       */
      defaultNow() {
        return this.default(sql`(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
      }
      build(table) {
        return new SQLiteTimestamp(
          table,
          this.config
        );
      }
    };
    SQLiteTimestamp = class extends SQLiteBaseInteger {
      static {
        __name(this, "SQLiteTimestamp");
      }
      static [entityKind] = "SQLiteTimestamp";
      mode = this.config.mode;
      mapFromDriverValue(value) {
        if (this.config.mode === "timestamp") {
          return new Date(value * 1e3);
        }
        return new Date(value);
      }
      mapToDriverValue(value) {
        const unix = value.getTime();
        if (this.config.mode === "timestamp") {
          return Math.floor(unix / 1e3);
        }
        return unix;
      }
    };
    SQLiteBooleanBuilder = class extends SQLiteBaseIntegerBuilder {
      static {
        __name(this, "SQLiteBooleanBuilder");
      }
      static [entityKind] = "SQLiteBooleanBuilder";
      constructor(name, mode) {
        super(name, "boolean", "SQLiteBoolean");
        this.config.mode = mode;
      }
      build(table) {
        return new SQLiteBoolean(
          table,
          this.config
        );
      }
    };
    SQLiteBoolean = class extends SQLiteBaseInteger {
      static {
        __name(this, "SQLiteBoolean");
      }
      static [entityKind] = "SQLiteBoolean";
      mode = this.config.mode;
      mapFromDriverValue(value) {
        return Number(value) === 1;
      }
      mapToDriverValue(value) {
        return value ? 1 : 0;
      }
    };
    __name(integer, "integer");
  }
});

// ../node_modules/drizzle-orm/sqlite-core/columns/numeric.js
function numeric(name) {
  return new SQLiteNumericBuilder(name ?? "");
}
var SQLiteNumericBuilder, SQLiteNumeric;
var init_numeric = __esm({
  "../node_modules/drizzle-orm/sqlite-core/columns/numeric.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_common2();
    SQLiteNumericBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteNumericBuilder");
      }
      static [entityKind] = "SQLiteNumericBuilder";
      constructor(name) {
        super(name, "string", "SQLiteNumeric");
      }
      /** @internal */
      build(table) {
        return new SQLiteNumeric(
          table,
          this.config
        );
      }
    };
    SQLiteNumeric = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteNumeric");
      }
      static [entityKind] = "SQLiteNumeric";
      getSQLType() {
        return "numeric";
      }
    };
    __name(numeric, "numeric");
  }
});

// ../node_modules/drizzle-orm/sqlite-core/columns/real.js
function real(name) {
  return new SQLiteRealBuilder(name ?? "");
}
var SQLiteRealBuilder, SQLiteReal;
var init_real = __esm({
  "../node_modules/drizzle-orm/sqlite-core/columns/real.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_common2();
    SQLiteRealBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteRealBuilder");
      }
      static [entityKind] = "SQLiteRealBuilder";
      constructor(name) {
        super(name, "number", "SQLiteReal");
      }
      /** @internal */
      build(table) {
        return new SQLiteReal(table, this.config);
      }
    };
    SQLiteReal = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteReal");
      }
      static [entityKind] = "SQLiteReal";
      getSQLType() {
        return "real";
      }
    };
    __name(real, "real");
  }
});

// ../node_modules/drizzle-orm/sqlite-core/columns/text.js
function text(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "json") {
    return new SQLiteTextJsonBuilder(name);
  }
  return new SQLiteTextBuilder(name, config);
}
var SQLiteTextBuilder, SQLiteText, SQLiteTextJsonBuilder, SQLiteTextJson;
var init_text = __esm({
  "../node_modules/drizzle-orm/sqlite-core/columns/text.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_utils();
    init_common2();
    SQLiteTextBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteTextBuilder");
      }
      static [entityKind] = "SQLiteTextBuilder";
      constructor(name, config) {
        super(name, "string", "SQLiteText");
        this.config.enumValues = config.enum;
        this.config.length = config.length;
      }
      /** @internal */
      build(table) {
        return new SQLiteText(
          table,
          this.config
        );
      }
    };
    SQLiteText = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteText");
      }
      static [entityKind] = "SQLiteText";
      enumValues = this.config.enumValues;
      length = this.config.length;
      constructor(table, config) {
        super(table, config);
      }
      getSQLType() {
        return `text${this.config.length ? `(${this.config.length})` : ""}`;
      }
    };
    SQLiteTextJsonBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteTextJsonBuilder");
      }
      static [entityKind] = "SQLiteTextJsonBuilder";
      constructor(name) {
        super(name, "json", "SQLiteTextJson");
      }
      /** @internal */
      build(table) {
        return new SQLiteTextJson(
          table,
          this.config
        );
      }
    };
    SQLiteTextJson = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteTextJson");
      }
      static [entityKind] = "SQLiteTextJson";
      getSQLType() {
        return "text";
      }
      mapFromDriverValue(value) {
        return JSON.parse(value);
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
    };
    __name(text, "text");
  }
});

// ../node_modules/drizzle-orm/sqlite-core/columns/index.js
var init_columns = __esm({
  "../node_modules/drizzle-orm/sqlite-core/columns/index.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_blob();
    init_common2();
    init_custom();
    init_integer();
    init_numeric();
    init_real();
    init_text();
  }
});

// ../node_modules/drizzle-orm/selection-proxy.js
var SelectionProxyHandler;
var init_selection_proxy = __esm({
  "../node_modules/drizzle-orm/selection-proxy.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_alias();
    init_column();
    init_entity();
    init_sql();
    init_subquery();
    init_view_common();
    SelectionProxyHandler = class _SelectionProxyHandler {
      static {
        __name(this, "SelectionProxyHandler");
      }
      static [entityKind] = "SelectionProxyHandler";
      config;
      constructor(config) {
        this.config = { ...config };
      }
      get(subquery, prop) {
        if (prop === "_") {
          return {
            ...subquery["_"],
            selectedFields: new Proxy(
              subquery._.selectedFields,
              this
            )
          };
        }
        if (prop === ViewBaseConfig) {
          return {
            ...subquery[ViewBaseConfig],
            selectedFields: new Proxy(
              subquery[ViewBaseConfig].selectedFields,
              this
            )
          };
        }
        if (typeof prop === "symbol") {
          return subquery[prop];
        }
        const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
        const value = columns[prop];
        if (is(value, SQL.Aliased)) {
          if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
            return value.sql;
          }
          const newValue = value.clone();
          newValue.isSelectionField = true;
          return newValue;
        }
        if (is(value, SQL)) {
          if (this.config.sqlBehavior === "sql") {
            return value;
          }
          throw new Error(
            `You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
          );
        }
        if (is(value, Column)) {
          if (this.config.alias) {
            return new Proxy(
              value,
              new ColumnAliasProxyHandler(
                new Proxy(
                  value.table,
                  new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)
                )
              )
            );
          }
          return value;
        }
        if (typeof value !== "object" || value === null) {
          return value;
        }
        return new Proxy(value, new _SelectionProxyHandler(this.config));
      }
    };
  }
});

// ../node_modules/drizzle-orm/query-promise.js
var QueryPromise;
var init_query_promise = __esm({
  "../node_modules/drizzle-orm/query-promise.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    QueryPromise = class {
      static {
        __name(this, "QueryPromise");
      }
      static [entityKind] = "QueryPromise";
      [Symbol.toStringTag] = "QueryPromise";
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      finally(onFinally) {
        return this.then(
          (value) => {
            onFinally?.();
            return value;
          },
          (reason) => {
            onFinally?.();
            throw reason;
          }
        );
      }
      then(onFulfilled, onRejected) {
        return this.execute().then(onFulfilled, onRejected);
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/columns/all.js
function getSQLiteColumnBuilders() {
  return {
    blob,
    customType,
    integer,
    numeric,
    real,
    text
  };
}
var init_all = __esm({
  "../node_modules/drizzle-orm/sqlite-core/columns/all.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_blob();
    init_custom();
    init_integer();
    init_numeric();
    init_real();
    init_text();
    __name(getSQLiteColumnBuilders, "getSQLiteColumnBuilders");
  }
});

// ../node_modules/drizzle-orm/sqlite-core/table.js
function sqliteTableBase(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new SQLiteTable(name, schema, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getSQLiteColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(
    Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      colBuilder.setName(name2);
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumns;
  if (extraConfig) {
    table[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
}
var InlineForeignKeys, SQLiteTable, sqliteTable;
var init_table2 = __esm({
  "../node_modules/drizzle-orm/sqlite-core/table.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_table();
    init_all();
    InlineForeignKeys = Symbol.for("drizzle:SQLiteInlineForeignKeys");
    SQLiteTable = class extends Table {
      static {
        __name(this, "SQLiteTable");
      }
      static [entityKind] = "SQLiteTable";
      /** @internal */
      static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys
      });
      /** @internal */
      [Table.Symbol.Columns];
      /** @internal */
      [InlineForeignKeys] = [];
      /** @internal */
      [Table.Symbol.ExtraConfigBuilder] = void 0;
    };
    __name(sqliteTableBase, "sqliteTableBase");
    sqliteTable = /* @__PURE__ */ __name((name, columns, extraConfig) => {
      return sqliteTableBase(name, columns, extraConfig);
    }, "sqliteTable");
  }
});

// ../node_modules/drizzle-orm/sqlite-core/query-builders/delete.js
var SQLiteDeleteBase;
var init_delete = __esm({
  "../node_modules/drizzle-orm/sqlite-core/query-builders/delete.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_query_promise();
    init_selection_proxy();
    init_table2();
    init_table();
    init_utils();
    SQLiteDeleteBase = class extends QueryPromise {
      static {
        __name(this, "SQLiteDeleteBase");
      }
      constructor(table, session, dialect, withList) {
        super();
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.config = { table, withList };
      }
      static [entityKind] = "SQLiteDelete";
      /** @internal */
      config;
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will delete only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be deleted.
       *
       * ```ts
       * // Delete all cars with green color
       * db.delete(cars).where(eq(cars.color, 'green'));
       * // or
       * db.delete(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Delete all BMW cars with a green color
       * db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Delete all cars with the green or blue color
       * db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](
            new Proxy(
              this.config.table[Table.Symbol.Columns],
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
          this.config.orderBy = orderByArray;
        } else {
          const orderByArray = columns;
          this.config.orderBy = orderByArray;
        }
        return this;
      }
      limit(limit) {
        this.config.limit = limit;
        return this;
      }
      returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run",
          true
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().run(placeholderValues);
      }, "run");
      all = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().all(placeholderValues);
      }, "all");
      get = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().get(placeholderValues);
      }, "get");
      values = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().values(placeholderValues);
      }, "values");
      async execute(placeholderValues) {
        return this._prepare().execute(placeholderValues);
      }
      $dynamic() {
        return this;
      }
    };
  }
});

// ../node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i) => {
    const formattedWord = i === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}
var CasingCache;
var init_casing = __esm({
  "../node_modules/drizzle-orm/casing.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_table();
    __name(toSnakeCase, "toSnakeCase");
    __name(toCamelCase, "toCamelCase");
    __name(noopCase, "noopCase");
    CasingCache = class {
      static {
        __name(this, "CasingCache");
      }
      static [entityKind] = "CasingCache";
      /** @internal */
      cache = {};
      cachedTables = {};
      convert;
      constructor(casing) {
        this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
      }
      getColumnCasing(column) {
        if (!column.keyAsName)
          return column.name;
        const schema = column.table[Table.Symbol.Schema] ?? "public";
        const tableName = column.table[Table.Symbol.OriginalName];
        const key = `${schema}.${tableName}.${column.name}`;
        if (!this.cache[key]) {
          this.cacheTable(column.table);
        }
        return this.cache[key];
      }
      cacheTable(table) {
        const schema = table[Table.Symbol.Schema] ?? "public";
        const tableName = table[Table.Symbol.OriginalName];
        const tableKey = `${schema}.${tableName}`;
        if (!this.cachedTables[tableKey]) {
          for (const column of Object.values(table[Table.Symbol.Columns])) {
            const columnKey = `${tableKey}.${column.name}`;
            this.cache[columnKey] = this.convert(column.name);
          }
          this.cachedTables[tableKey] = true;
        }
      }
      clearCache() {
        this.cache = {};
        this.cachedTables = {};
      }
    };
  }
});

// ../node_modules/drizzle-orm/errors.js
var DrizzleError, TransactionRollbackError;
var init_errors = __esm({
  "../node_modules/drizzle-orm/errors.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    DrizzleError = class extends Error {
      static {
        __name(this, "DrizzleError");
      }
      static [entityKind] = "DrizzleError";
      constructor({ message, cause }) {
        super(message);
        this.name = "DrizzleError";
        this.cause = cause;
      }
    };
    TransactionRollbackError = class extends DrizzleError {
      static {
        __name(this, "TransactionRollbackError");
      }
      static [entityKind] = "TransactionRollbackError";
      constructor() {
        super({ message: "Rollback" });
      }
    };
  }
});

// ../node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys2, EnableRLS, PgTable;
var init_table3 = __esm({
  "../node_modules/drizzle-orm/pg-core/table.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_table();
    InlineForeignKeys2 = Symbol.for("drizzle:PgInlineForeignKeys");
    EnableRLS = Symbol.for("drizzle:EnableRLS");
    PgTable = class extends Table {
      static {
        __name(this, "PgTable");
      }
      static [entityKind] = "PgTable";
      /** @internal */
      static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys: InlineForeignKeys2,
        EnableRLS
      });
      /**@internal */
      [InlineForeignKeys2] = [];
      /** @internal */
      [EnableRLS] = false;
      /** @internal */
      [Table.Symbol.ExtraConfigBuilder] = void 0;
    };
  }
});

// ../node_modules/drizzle-orm/pg-core/primary-keys.js
var PrimaryKeyBuilder, PrimaryKey;
var init_primary_keys = __esm({
  "../node_modules/drizzle-orm/pg-core/primary-keys.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_table3();
    PrimaryKeyBuilder = class {
      static {
        __name(this, "PrimaryKeyBuilder");
      }
      static [entityKind] = "PgPrimaryKeyBuilder";
      /** @internal */
      columns;
      /** @internal */
      name;
      constructor(columns, name) {
        this.columns = columns;
        this.name = name;
      }
      /** @internal */
      build(table) {
        return new PrimaryKey(table, this.columns, this.name);
      }
    };
    PrimaryKey = class {
      static {
        __name(this, "PrimaryKey");
      }
      constructor(table, columns, name) {
        this.table = table;
        this.columns = columns;
        this.name = name;
      }
      static [entityKind] = "PgPrimaryKey";
      columns;
      name;
      getName() {
        return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
      }
    };
  }
});

// ../node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c) => c !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c) => c !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(
    max,
    column
  )}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(
    min,
    column
  )} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}
var eq, ne, gt, gte, lt, lte;
var init_conditions = __esm({
  "../node_modules/drizzle-orm/sql/expressions/conditions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_column();
    init_entity();
    init_table();
    init_sql();
    __name(bindIfParam, "bindIfParam");
    eq = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} = ${bindIfParam(right, left)}`;
    }, "eq");
    ne = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} <> ${bindIfParam(right, left)}`;
    }, "ne");
    __name(and, "and");
    __name(or, "or");
    __name(not, "not");
    gt = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} > ${bindIfParam(right, left)}`;
    }, "gt");
    gte = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} >= ${bindIfParam(right, left)}`;
    }, "gte");
    lt = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} < ${bindIfParam(right, left)}`;
    }, "lt");
    lte = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} <= ${bindIfParam(right, left)}`;
    }, "lte");
    __name(inArray, "inArray");
    __name(notInArray, "notInArray");
    __name(isNull, "isNull");
    __name(isNotNull, "isNotNull");
    __name(exists, "exists");
    __name(notExists, "notExists");
    __name(between, "between");
    __name(notBetween, "notBetween");
    __name(like, "like");
    __name(notLike, "notLike");
    __name(ilike, "ilike");
    __name(notIlike, "notIlike");
  }
});

// ../node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}
var init_select = __esm({
  "../node_modules/drizzle-orm/sql/expressions/select.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_sql();
    __name(asc, "asc");
    __name(desc, "desc");
  }
});

// ../node_modules/drizzle-orm/sql/expressions/index.js
var init_expressions = __esm({
  "../node_modules/drizzle-orm/sql/expressions/index.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_conditions();
    init_select();
  }
});

// ../node_modules/drizzle-orm/relations.js
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(
        value[Table.Symbol.Columns]
      )) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(
        configHelpers(value.table)
      );
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function relations(table, relations2) {
  return new Relations(
    table,
    (helpers) => Object.fromEntries(
      Object.entries(relations2(helpers)).map(([key, value]) => [
        key,
        value.withFieldName(key)
      ])
    )
  );
}
function createOne(sourceTable) {
  return /* @__PURE__ */ __name(function one(table, config) {
    return new One(
      sourceTable,
      table,
      config,
      config?.fields.reduce((res, f) => res && f.notNull, true) ?? false
    );
  }, "one");
}
function createMany(sourceTable) {
  return /* @__PURE__ */ __name(function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  }, "many");
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(
      `Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(
      `Table "${sourceTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(
    referencedTableConfig.relations
  )) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(
      `There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`
    ) : new Error(
      `There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`
    );
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(
    `There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`
  );
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(
        tablesConfig,
        tablesConfig[selectionItem.relationTableTsKey],
        subRows,
        selectionItem.selection,
        mapColumnValue
      ) : subRows.map(
        (subRow) => mapRelationalRow(
          tablesConfig,
          tablesConfig[selectionItem.relationTableTsKey],
          subRow,
          selectionItem.selection,
          mapColumnValue
        )
      );
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}
var Relation, Relations, One, Many;
var init_relations = __esm({
  "../node_modules/drizzle-orm/relations.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_table();
    init_column();
    init_entity();
    init_primary_keys();
    init_expressions();
    init_sql();
    Relation = class {
      static {
        __name(this, "Relation");
      }
      constructor(sourceTable, referencedTable, relationName) {
        this.sourceTable = sourceTable;
        this.referencedTable = referencedTable;
        this.relationName = relationName;
        this.referencedTableName = referencedTable[Table.Symbol.Name];
      }
      static [entityKind] = "Relation";
      referencedTableName;
      fieldName;
    };
    Relations = class {
      static {
        __name(this, "Relations");
      }
      constructor(table, config) {
        this.table = table;
        this.config = config;
      }
      static [entityKind] = "Relations";
    };
    One = class _One extends Relation {
      static {
        __name(this, "One");
      }
      constructor(sourceTable, referencedTable, config, isNullable) {
        super(sourceTable, referencedTable, config?.relationName);
        this.config = config;
        this.isNullable = isNullable;
      }
      static [entityKind] = "One";
      withFieldName(fieldName) {
        const relation = new _One(
          this.sourceTable,
          this.referencedTable,
          this.config,
          this.isNullable
        );
        relation.fieldName = fieldName;
        return relation;
      }
    };
    Many = class _Many extends Relation {
      static {
        __name(this, "Many");
      }
      constructor(sourceTable, referencedTable, config) {
        super(sourceTable, referencedTable, config?.relationName);
        this.config = config;
      }
      static [entityKind] = "Many";
      withFieldName(fieldName) {
        const relation = new _Many(
          this.sourceTable,
          this.referencedTable,
          this.config
        );
        relation.fieldName = fieldName;
        return relation;
      }
    };
    __name(getOperators, "getOperators");
    __name(getOrderByOperators, "getOrderByOperators");
    __name(extractTablesRelationalConfig, "extractTablesRelationalConfig");
    __name(relations, "relations");
    __name(createOne, "createOne");
    __name(createMany, "createMany");
    __name(normalizeRelation, "normalizeRelation");
    __name(createTableRelationsHelpers, "createTableRelationsHelpers");
    __name(mapRelationalRow, "mapRelationalRow");
  }
});

// ../node_modules/drizzle-orm/sql/functions/aggregate.js
function count(expression) {
  return sql`count(${expression || sql.raw("*")})`.mapWith(Number);
}
var init_aggregate = __esm({
  "../node_modules/drizzle-orm/sql/functions/aggregate.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_sql();
    __name(count, "count");
  }
});

// ../node_modules/drizzle-orm/sql/functions/vector.js
var init_vector = __esm({
  "../node_modules/drizzle-orm/sql/functions/vector.js"() {
    init_functionsRoutes_0_8044054200943971();
  }
});

// ../node_modules/drizzle-orm/sql/functions/index.js
var init_functions = __esm({
  "../node_modules/drizzle-orm/sql/functions/index.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_aggregate();
    init_vector();
  }
});

// ../node_modules/drizzle-orm/sql/index.js
var init_sql2 = __esm({
  "../node_modules/drizzle-orm/sql/index.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_expressions();
    init_functions();
    init_sql();
  }
});

// ../node_modules/drizzle-orm/sqlite-core/view-base.js
var SQLiteViewBase;
var init_view_base = __esm({
  "../node_modules/drizzle-orm/sqlite-core/view-base.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_sql();
    SQLiteViewBase = class extends View {
      static {
        __name(this, "SQLiteViewBase");
      }
      static [entityKind] = "SQLiteViewBase";
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/dialect.js
var SQLiteDialect, SQLiteSyncDialect, SQLiteAsyncDialect;
var init_dialect = __esm({
  "../node_modules/drizzle-orm/sqlite-core/dialect.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_alias();
    init_casing();
    init_column();
    init_entity();
    init_errors();
    init_relations();
    init_sql2();
    init_sql();
    init_columns();
    init_table2();
    init_subquery();
    init_table();
    init_utils();
    init_view_common();
    init_view_base();
    SQLiteDialect = class {
      static {
        __name(this, "SQLiteDialect");
      }
      static [entityKind] = "SQLiteDialect";
      /** @internal */
      casing;
      constructor(config) {
        this.casing = new CasingCache(config?.casing);
      }
      escapeName(name) {
        return `"${name}"`;
      }
      escapeParam(_num) {
        return "?";
      }
      escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
      }
      buildWithCTE(queries) {
        if (!queries?.length)
          return void 0;
        const withSqlChunks = [sql`with `];
        for (const [i, w] of queries.entries()) {
          withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
          if (i < queries.length - 1) {
            withSqlChunks.push(sql`, `);
          }
        }
        withSqlChunks.push(sql` `);
        return sql.join(withSqlChunks);
      }
      buildDeleteQuery({ table, where, returning, withList, limit, orderBy }) {
        const withSql = this.buildWithCTE(withList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        const orderBySql = this.buildOrderBy(orderBy);
        const limitSql = this.buildLimit(limit);
        return sql`${withSql}delete from ${table}${whereSql}${returningSql}${orderBySql}${limitSql}`;
      }
      buildUpdateSet(table, set) {
        const tableColumns = table[Table.Symbol.Columns];
        const columnNames = Object.keys(tableColumns).filter(
          (colName) => set[colName] !== void 0 || tableColumns[colName]?.onUpdateFn !== void 0
        );
        const setSize = columnNames.length;
        return sql.join(columnNames.flatMap((colName, i) => {
          const col = tableColumns[colName];
          const value = set[colName] ?? sql.param(col.onUpdateFn(), col);
          const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
          if (i < setSize - 1) {
            return [res, sql.raw(", ")];
          }
          return [res];
        }));
      }
      buildUpdateQuery({ table, set, where, returning, withList, joins, from, limit, orderBy }) {
        const withSql = this.buildWithCTE(withList);
        const setSql = this.buildUpdateSet(table, set);
        const fromSql = from && sql.join([sql.raw(" from "), this.buildFromTable(from)]);
        const joinsSql = this.buildJoins(joins);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        const orderBySql = this.buildOrderBy(orderBy);
        const limitSql = this.buildLimit(limit);
        return sql`${withSql}update ${table} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}${orderBySql}${limitSql}`;
      }
      /**
       * Builds selection SQL with provided fields/expressions
       *
       * Examples:
       *
       * `select <selection> from`
       *
       * `insert ... returning <selection>`
       *
       * If `isSingleTable` is true, then columns won't be prefixed with table name
       */
      buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields.flatMap(({ field }, i) => {
          const chunk = [];
          if (is(field, SQL.Aliased) && field.isSelectionField) {
            chunk.push(sql.identifier(field.fieldAlias));
          } else if (is(field, SQL.Aliased) || is(field, SQL)) {
            const query = is(field, SQL.Aliased) ? field.sql : field;
            if (isSingleTable) {
              chunk.push(
                new SQL(
                  query.queryChunks.map((c) => {
                    if (is(c, Column)) {
                      return sql.identifier(this.casing.getColumnCasing(c));
                    }
                    return c;
                  })
                )
              );
            } else {
              chunk.push(query);
            }
            if (is(field, SQL.Aliased)) {
              chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
            }
          } else if (is(field, Column)) {
            const tableName = field.table[Table.Symbol.Name];
            if (isSingleTable) {
              chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
            } else {
              chunk.push(sql`${sql.identifier(tableName)}.${sql.identifier(this.casing.getColumnCasing(field))}`);
            }
          }
          if (i < columnsLen - 1) {
            chunk.push(sql`, `);
          }
          return chunk;
        });
        return sql.join(chunks);
      }
      buildJoins(joins) {
        if (!joins || joins.length === 0) {
          return void 0;
        }
        const joinsArray = [];
        if (joins) {
          for (const [index, joinMeta] of joins.entries()) {
            if (index === 0) {
              joinsArray.push(sql` `);
            }
            const table = joinMeta.table;
            if (is(table, SQLiteTable)) {
              const tableName = table[SQLiteTable.Symbol.Name];
              const tableSchema = table[SQLiteTable.Symbol.Schema];
              const origTableName = table[SQLiteTable.Symbol.OriginalName];
              const alias = tableName === origTableName ? void 0 : joinMeta.alias;
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
              );
            } else {
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join ${table} on ${joinMeta.on}`
              );
            }
            if (index < joins.length - 1) {
              joinsArray.push(sql` `);
            }
          }
        }
        return sql.join(joinsArray);
      }
      buildLimit(limit) {
        return typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
      }
      buildOrderBy(orderBy) {
        const orderByList = [];
        if (orderBy) {
          for (const [index, orderByValue] of orderBy.entries()) {
            orderByList.push(orderByValue);
            if (index < orderBy.length - 1) {
              orderByList.push(sql`, `);
            }
          }
        }
        return orderByList.length > 0 ? sql` order by ${sql.join(orderByList)}` : void 0;
      }
      buildFromTable(table) {
        if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
          return sql`${sql.identifier(table[Table.Symbol.OriginalName])} ${sql.identifier(table[Table.Symbol.Name])}`;
        }
        return table;
      }
      buildSelectQuery({
        withList,
        fields,
        fieldsFlat,
        where,
        having,
        table,
        joins,
        orderBy,
        groupBy,
        limit,
        offset,
        distinct,
        setOperators
      }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f of fieldsList) {
          if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table._.alias : is(table, SQLiteViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : getTableName(table)) && !((table2) => joins?.some(
            ({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])
          ))(f.field.table)) {
            const tableName = getTableName(f.field.table);
            throw new Error(
              `Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
            );
          }
        }
        const isSingleTable = !joins || joins.length === 0;
        const withSql = this.buildWithCTE(withList);
        const distinctSql = distinct ? sql` distinct` : void 0;
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = this.buildFromTable(table);
        const joinsSql = this.buildJoins(joins);
        const whereSql = where ? sql` where ${where}` : void 0;
        const havingSql = having ? sql` having ${having}` : void 0;
        const groupByList = [];
        if (groupBy) {
          for (const [index, groupByValue] of groupBy.entries()) {
            groupByList.push(groupByValue);
            if (index < groupBy.length - 1) {
              groupByList.push(sql`, `);
            }
          }
        }
        const groupBySql = groupByList.length > 0 ? sql` group by ${sql.join(groupByList)}` : void 0;
        const orderBySql = this.buildOrderBy(orderBy);
        const limitSql = this.buildLimit(limit);
        const offsetSql = offset ? sql` offset ${offset}` : void 0;
        const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
        if (setOperators.length > 0) {
          return this.buildSetOperations(finalQuery, setOperators);
        }
        return finalQuery;
      }
      buildSetOperations(leftSelect, setOperators) {
        const [setOperator, ...rest] = setOperators;
        if (!setOperator) {
          throw new Error("Cannot pass undefined values to any set operator");
        }
        if (rest.length === 0) {
          return this.buildSetOperationQuery({ leftSelect, setOperator });
        }
        return this.buildSetOperations(
          this.buildSetOperationQuery({ leftSelect, setOperator }),
          rest
        );
      }
      buildSetOperationQuery({
        leftSelect,
        setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
      }) {
        const leftChunk = sql`${leftSelect.getSQL()} `;
        const rightChunk = sql`${rightSelect.getSQL()}`;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          const orderByValues = [];
          for (const singleOrderBy of orderBy) {
            if (is(singleOrderBy, SQLiteColumn)) {
              orderByValues.push(sql.identifier(singleOrderBy.name));
            } else if (is(singleOrderBy, SQL)) {
              for (let i = 0; i < singleOrderBy.queryChunks.length; i++) {
                const chunk = singleOrderBy.queryChunks[i];
                if (is(chunk, SQLiteColumn)) {
                  singleOrderBy.queryChunks[i] = sql.identifier(this.casing.getColumnCasing(chunk));
                }
              }
              orderByValues.push(sql`${singleOrderBy}`);
            } else {
              orderByValues.push(sql`${singleOrderBy}`);
            }
          }
          orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)}`;
        }
        const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
        const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
        const offsetSql = offset ? sql` offset ${offset}` : void 0;
        return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
      }
      buildInsertQuery({ table, values: valuesOrSelect, onConflict, returning, withList, select }) {
        const valuesSqlList = [];
        const columns = table[Table.Symbol.Columns];
        const colEntries = Object.entries(columns).filter(
          ([_, col]) => !col.shouldDisableInsert()
        );
        const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
        if (select) {
          const select2 = valuesOrSelect;
          if (is(select2, SQL)) {
            valuesSqlList.push(select2);
          } else {
            valuesSqlList.push(select2.getSQL());
          }
        } else {
          const values = valuesOrSelect;
          valuesSqlList.push(sql.raw("values "));
          for (const [valueIndex, value] of values.entries()) {
            const valueList = [];
            for (const [fieldName, col] of colEntries) {
              const colValue = value[fieldName];
              if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
                let defaultValue;
                if (col.default !== null && col.default !== void 0) {
                  defaultValue = is(col.default, SQL) ? col.default : sql.param(col.default, col);
                } else if (col.defaultFn !== void 0) {
                  const defaultFnResult = col.defaultFn();
                  defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
                } else if (!col.default && col.onUpdateFn !== void 0) {
                  const onUpdateFnResult = col.onUpdateFn();
                  defaultValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
                } else {
                  defaultValue = sql`null`;
                }
                valueList.push(defaultValue);
              } else {
                valueList.push(colValue);
              }
            }
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
              valuesSqlList.push(sql`, `);
            }
          }
        }
        const withSql = this.buildWithCTE(withList);
        const valuesSql = sql.join(valuesSqlList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const onConflictSql = onConflict?.length ? sql.join(onConflict) : void 0;
        return sql`${withSql}insert into ${table} ${insertOrder} ${valuesSql}${onConflictSql}${returningSql}`;
      }
      sqlToQuery(sql2, invokeSource) {
        return sql2.toQuery({
          casing: this.casing,
          escapeName: this.escapeName,
          escapeParam: this.escapeParam,
          escapeString: this.escapeString,
          invokeSource
        });
      }
      buildRelationalQuery({
        fullSchema,
        schema,
        tableNamesMap,
        table,
        tableConfig,
        queryConfig: config,
        tableAlias,
        nestedQueryRelation,
        joinOn
      }) {
        let selection = [];
        let limit, offset, orderBy = [], where;
        const joins = [];
        if (config === true) {
          const selectionEntries = Object.entries(tableConfig.columns);
          selection = selectionEntries.map(([key, value]) => ({
            dbKey: value.name,
            tsKey: key,
            field: aliasedTableColumn(value, tableAlias),
            relationTableTsKey: void 0,
            isJson: false,
            selection: []
          }));
        } else {
          const aliasedColumns = Object.fromEntries(
            Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)])
          );
          if (config.where) {
            const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
          }
          const fieldsSelection = [];
          let selectedColumns = [];
          if (config.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config.columns)) {
              if (value === void 0) {
                continue;
              }
              if (field in tableConfig.columns) {
                if (!isIncludeMode && value === true) {
                  isIncludeMode = true;
                }
                selectedColumns.push(field);
              }
            }
            if (selectedColumns.length > 0) {
              selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
            }
          } else {
            selectedColumns = Object.keys(tableConfig.columns);
          }
          for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection.push({ tsKey: field, value: column });
          }
          let selectedRelations = [];
          if (config.with) {
            selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
          }
          let extras;
          if (config.extras) {
            extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
            for (const [tsKey, value] of Object.entries(extras)) {
              fieldsSelection.push({
                tsKey,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
              });
            }
          }
          for (const { tsKey, value } of fieldsSelection) {
            selection.push({
              dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
              tsKey,
              field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
              relationTableTsKey: void 0,
              isJson: false,
              selection: []
            });
          }
          let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
          if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
          }
          orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
              return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
          });
          limit = config.limit;
          offset = config.offset;
          for (const {
            tsKey: selectedRelationTsKey,
            queryConfig: selectedRelationConfigValue,
            relation
          } of selectedRelations) {
            const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
            const relationTableName = getTableUniqueName(relation.referencedTable);
            const relationTableTsName = tableNamesMap[relationTableName];
            const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
            const joinOn2 = and(
              ...normalizedRelation.fields.map(
                (field2, i) => eq(
                  aliasedTableColumn(normalizedRelation.references[i], relationTableAlias),
                  aliasedTableColumn(field2, tableAlias)
                )
              )
            );
            const builtRelation = this.buildRelationalQuery({
              fullSchema,
              schema,
              tableNamesMap,
              table: fullSchema[relationTableTsName],
              tableConfig: schema[relationTableTsName],
              queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
              tableAlias: relationTableAlias,
              joinOn: joinOn2,
              nestedQueryRelation: relation
            });
            const field = sql`(${builtRelation.sql})`.as(selectedRelationTsKey);
            selection.push({
              dbKey: selectedRelationTsKey,
              tsKey: selectedRelationTsKey,
              field,
              relationTableTsKey: relationTableTsName,
              isJson: true,
              selection: builtRelation.selection
            });
          }
        }
        if (selection.length === 0) {
          throw new DrizzleError({
            message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`
          });
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
          let field = sql`json_array(${sql.join(
            selection.map(
              ({ field: field2 }) => is(field2, SQLiteColumn) ? sql.identifier(this.casing.getColumnCasing(field2)) : is(field2, SQL.Aliased) ? field2.sql : field2
            ),
            sql`, `
          )})`;
          if (is(nestedQueryRelation, Many)) {
            field = sql`coalesce(json_group_array(${field}), json_array())`;
          }
          const nestedSelection = [{
            dbKey: "data",
            tsKey: "data",
            field: field.as("data"),
            isJson: true,
            relationTableTsKey: tableConfig.tsName,
            selection
          }];
          const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
          if (needsSubquery) {
            result = this.buildSelectQuery({
              table: aliasedTable(table, tableAlias),
              fields: {},
              fieldsFlat: [
                {
                  path: [],
                  field: sql.raw("*")
                }
              ],
              where,
              limit,
              offset,
              orderBy,
              setOperators: []
            });
            where = void 0;
            limit = void 0;
            offset = void 0;
            orderBy = void 0;
          } else {
            result = aliasedTable(table, tableAlias);
          }
          result = this.buildSelectQuery({
            table: is(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),
            fields: {},
            fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
              path: [],
              field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
            })),
            joins,
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        } else {
          result = this.buildSelectQuery({
            table: aliasedTable(table, tableAlias),
            fields: {},
            fieldsFlat: selection.map(({ field }) => ({
              path: [],
              field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
            })),
            joins,
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        }
        return {
          tableTsKey: tableConfig.tsName,
          sql: result,
          selection
        };
      }
    };
    SQLiteSyncDialect = class extends SQLiteDialect {
      static {
        __name(this, "SQLiteSyncDialect");
      }
      static [entityKind] = "SQLiteSyncDialect";
      migrate(migrations, session, config) {
        const migrationsTable = config === void 0 ? "__drizzle_migrations" : typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        session.run(migrationTableCreate);
        const dbMigrations = session.values(
          sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
        );
        const lastDbMigration = dbMigrations[0] ?? void 0;
        session.run(sql`BEGIN`);
        try {
          for (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                session.run(sql.raw(stmt));
              }
              session.run(
                sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
          session.run(sql`COMMIT`);
        } catch (e) {
          session.run(sql`ROLLBACK`);
          throw e;
        }
      }
    };
    SQLiteAsyncDialect = class extends SQLiteDialect {
      static {
        __name(this, "SQLiteAsyncDialect");
      }
      static [entityKind] = "SQLiteAsyncDialect";
      async migrate(migrations, session, config) {
        const migrationsTable = config === void 0 ? "__drizzle_migrations" : typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        await session.run(migrationTableCreate);
        const dbMigrations = await session.values(
          sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
        );
        const lastDbMigration = dbMigrations[0] ?? void 0;
        await session.transaction(async (tx) => {
          for (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                await tx.run(sql.raw(stmt));
              }
              await tx.run(
                sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
        });
      }
    };
  }
});

// ../node_modules/drizzle-orm/query-builders/query-builder.js
var TypedQueryBuilder;
var init_query_builder = __esm({
  "../node_modules/drizzle-orm/query-builders/query-builder.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    TypedQueryBuilder = class {
      static {
        __name(this, "TypedQueryBuilder");
      }
      static [entityKind] = "TypedQueryBuilder";
      /** @internal */
      getSelectedFields() {
        return this._.selectedFields;
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/query-builders/select.js
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var SQLiteSelectBuilder, SQLiteSelectQueryBuilderBase, SQLiteSelectBase, getSQLiteSetOperators, union, unionAll, intersect, except;
var init_select2 = __esm({
  "../node_modules/drizzle-orm/sqlite-core/query-builders/select.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_query_builder();
    init_query_promise();
    init_selection_proxy();
    init_sql();
    init_subquery();
    init_table();
    init_utils();
    init_view_common();
    init_view_base();
    SQLiteSelectBuilder = class {
      static {
        __name(this, "SQLiteSelectBuilder");
      }
      static [entityKind] = "SQLiteSelectBuilder";
      fields;
      session;
      dialect;
      withList;
      distinct;
      constructor(config) {
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        this.withList = config.withList;
        this.distinct = config.distinct;
      }
      from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
          fields = this.fields;
        } else if (is(source, Subquery)) {
          fields = Object.fromEntries(
            Object.keys(source._.selectedFields).map((key) => [key, source[key]])
          );
        } else if (is(source, SQLiteViewBase)) {
          fields = source[ViewBaseConfig].selectedFields;
        } else if (is(source, SQL)) {
          fields = {};
        } else {
          fields = getTableColumns(source);
        }
        return new SQLiteSelectBase({
          table: source,
          fields,
          isPartialSelect,
          session: this.session,
          dialect: this.dialect,
          withList: this.withList,
          distinct: this.distinct
        });
      }
    };
    SQLiteSelectQueryBuilderBase = class extends TypedQueryBuilder {
      static {
        __name(this, "SQLiteSelectQueryBuilderBase");
      }
      static [entityKind] = "SQLiteSelectQueryBuilder";
      _;
      /** @internal */
      config;
      joinsNotNullableMap;
      tableName;
      isPartialSelect;
      session;
      dialect;
      constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.config = {
          withList,
          table,
          fields: { ...fields },
          distinct,
          setOperators: []
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
          selectedFields: fields
        };
        this.tableName = getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
      }
      createJoin(joinType) {
        return (table, on) => {
          const baseTableName = this.tableName;
          const tableName = getTableLikeName(table);
          if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (!this.isPartialSelect) {
            if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
              this.config.fields = {
                [baseTableName]: this.config.fields
              };
            }
            if (typeof tableName === "string" && !is(table, SQL)) {
              const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
              this.config.fields[tableName] = selection;
            }
          }
          if (typeof on === "function") {
            on = on(
              new Proxy(
                this.config.fields,
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              )
            );
          }
          if (!this.config.joins) {
            this.config.joins = [];
          }
          this.config.joins.push({ on, table, joinType, alias: tableName });
          if (typeof tableName === "string") {
            switch (joinType) {
              case "left": {
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
              case "right": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
                );
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "inner": {
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "full": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
                );
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
            }
          }
          return this;
        };
      }
      /**
       * Executes a `left join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      leftJoin = this.createJoin("left");
      /**
       * Executes a `right join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      rightJoin = this.createJoin("right");
      /**
       * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
       *
       * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      innerJoin = this.createJoin("inner");
      /**
       * Executes a `full join` operation by combining rows from two tables into a new table.
       *
       * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      fullJoin = this.createJoin("full");
      createSetOperator(type, isAll) {
        return (rightSelection) => {
          const rightSelect = typeof rightSelection === "function" ? rightSelection(getSQLiteSetOperators()) : rightSelection;
          if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
            throw new Error(
              "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
            );
          }
          this.config.setOperators.push({ type, isAll, rightSelect });
          return this;
        };
      }
      /**
       * Adds `union` set operator to the query.
       *
       * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
       *
       * @example
       *
       * ```ts
       * // Select all unique names from customers and users tables
       * await db.select({ name: users.name })
       *   .from(users)
       *   .union(
       *     db.select({ name: customers.name }).from(customers)
       *   );
       * // or
       * import { union } from 'drizzle-orm/sqlite-core'
       *
       * await union(
       *   db.select({ name: users.name }).from(users),
       *   db.select({ name: customers.name }).from(customers)
       * );
       * ```
       */
      union = this.createSetOperator("union", false);
      /**
       * Adds `union all` set operator to the query.
       *
       * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
       *
       * @example
       *
       * ```ts
       * // Select all transaction ids from both online and in-store sales
       * await db.select({ transaction: onlineSales.transactionId })
       *   .from(onlineSales)
       *   .unionAll(
       *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       *   );
       * // or
       * import { unionAll } from 'drizzle-orm/sqlite-core'
       *
       * await unionAll(
       *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
       *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       * );
       * ```
       */
      unionAll = this.createSetOperator("union", true);
      /**
       * Adds `intersect` set operator to the query.
       *
       * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
       *
       * @example
       *
       * ```ts
       * // Select course names that are offered in both departments A and B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .intersect(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { intersect } from 'drizzle-orm/sqlite-core'
       *
       * await intersect(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      intersect = this.createSetOperator("intersect", false);
      /**
       * Adds `except` set operator to the query.
       *
       * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
       *
       * @example
       *
       * ```ts
       * // Select all courses offered in department A but not in department B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .except(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { except } from 'drizzle-orm/sqlite-core'
       *
       * await except(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      except = this.createSetOperator("except", false);
      /** @internal */
      addSetOperators(setOperators) {
        this.config.setOperators.push(...setOperators);
        return this;
      }
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be selected.
       *
       * ```ts
       * // Select all cars with green color
       * await db.select().from(cars).where(eq(cars.color, 'green'));
       * // or
       * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Select all BMW cars with a green color
       * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Select all cars with the green or blue color
       * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        if (typeof where === "function") {
          where = where(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.where = where;
        return this;
      }
      /**
       * Adds a `having` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
       *
       * @param having the `having` clause.
       *
       * @example
       *
       * ```ts
       * // Select all brands with more than one car
       * await db.select({
       * 	brand: cars.brand,
       * 	count: sql<number>`cast(count(${cars.id}) as int)`,
       * })
       *   .from(cars)
       *   .groupBy(cars.brand)
       *   .having(({ count }) => gt(count, 1));
       * ```
       */
      having(having) {
        if (typeof having === "function") {
          having = having(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.having = having;
        return this;
      }
      groupBy(...columns) {
        if (typeof columns[0] === "function") {
          const groupBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        } else {
          this.config.groupBy = columns;
        }
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        } else {
          const orderByArray = columns;
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        }
        return this;
      }
      /**
       * Adds a `limit` clause to the query.
       *
       * Calling this method will set the maximum number of rows that will be returned by this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param limit the `limit` clause.
       *
       * @example
       *
       * ```ts
       * // Get the first 10 people from this query.
       * await db.select().from(people).limit(10);
       * ```
       */
      limit(limit) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).limit = limit;
        } else {
          this.config.limit = limit;
        }
        return this;
      }
      /**
       * Adds an `offset` clause to the query.
       *
       * Calling this method will skip a number of rows when returning results from this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param offset the `offset` clause.
       *
       * @example
       *
       * ```ts
       * // Get the 10th-20th people from this query.
       * await db.select().from(people).offset(10).limit(10);
       * ```
       */
      offset(offset) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).offset = offset;
        } else {
          this.config.offset = offset;
        }
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildSelectQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      as(alias) {
        return new Proxy(
          new Subquery(this.getSQL(), this.config.fields, alias),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      /** @internal */
      getSelectedFields() {
        return new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      $dynamic() {
        return this;
      }
    };
    SQLiteSelectBase = class extends SQLiteSelectQueryBuilderBase {
      static {
        __name(this, "SQLiteSelectBase");
      }
      static [entityKind] = "SQLiteSelect";
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        if (!this.session) {
          throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
        }
        const fieldsList = orderSelectedFields(this.config.fields);
        const query = this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          fieldsList,
          "all",
          true
        );
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
      }
      prepare() {
        return this._prepare(false);
      }
      run = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().run(placeholderValues);
      }, "run");
      all = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().all(placeholderValues);
      }, "all");
      get = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().get(placeholderValues);
      }, "get");
      values = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().values(placeholderValues);
      }, "values");
      async execute() {
        return this.all();
      }
    };
    applyMixins(SQLiteSelectBase, [QueryPromise]);
    __name(createSetOperator, "createSetOperator");
    getSQLiteSetOperators = /* @__PURE__ */ __name(() => ({
      union,
      unionAll,
      intersect,
      except
    }), "getSQLiteSetOperators");
    union = createSetOperator("union", false);
    unionAll = createSetOperator("union", true);
    intersect = createSetOperator("intersect", false);
    except = createSetOperator("except", false);
  }
});

// ../node_modules/drizzle-orm/sqlite-core/query-builders/query-builder.js
var QueryBuilder;
var init_query_builder2 = __esm({
  "../node_modules/drizzle-orm/sqlite-core/query-builders/query-builder.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_selection_proxy();
    init_dialect();
    init_subquery();
    init_select2();
    QueryBuilder = class {
      static {
        __name(this, "QueryBuilder");
      }
      static [entityKind] = "SQLiteQueryBuilder";
      dialect;
      dialectConfig;
      constructor(dialect) {
        this.dialect = is(dialect, SQLiteDialect) ? dialect : void 0;
        this.dialectConfig = is(dialect, SQLiteDialect) ? void 0 : dialect;
      }
      $with = /* @__PURE__ */ __name((alias, selection) => {
        const queryBuilder = this;
        const as = /* @__PURE__ */ __name((qb) => {
          if (typeof qb === "function") {
            qb = qb(queryBuilder);
          }
          return new Proxy(
            new WithSubquery(
              qb.getSQL(),
              selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}),
              alias,
              true
            ),
            new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
          );
        }, "as");
        return { as };
      }, "$with");
      with(...queries) {
        const self = this;
        function select(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries
          });
        }
        __name(select, "select");
        function selectDistinct(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries,
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        return { select, selectDistinct };
      }
      select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: void 0, dialect: this.getDialect() });
      }
      selectDistinct(fields) {
        return new SQLiteSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: true
        });
      }
      // Lazy load dialect to avoid circular dependency
      getDialect() {
        if (!this.dialect) {
          this.dialect = new SQLiteSyncDialect(this.dialectConfig);
        }
        return this.dialect;
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/query-builders/insert.js
var SQLiteInsertBuilder, SQLiteInsertBase;
var init_insert = __esm({
  "../node_modules/drizzle-orm/sqlite-core/query-builders/insert.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_query_promise();
    init_sql();
    init_table2();
    init_table();
    init_utils();
    init_query_builder2();
    SQLiteInsertBuilder = class {
      static {
        __name(this, "SQLiteInsertBuilder");
      }
      constructor(table, session, dialect, withList) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      static [entityKind] = "SQLiteInsertBuilder";
      values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
          throw new Error("values() must be called with at least one value");
        }
        const mappedValues = values.map((entry) => {
          const result = {};
          const cols = this.table[Table.Symbol.Columns];
          for (const colKey of Object.keys(entry)) {
            const colValue = entry[colKey];
            result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
          }
          return result;
        });
        return new SQLiteInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
      }
      select(selectQuery) {
        const select = typeof selectQuery === "function" ? selectQuery(new QueryBuilder()) : selectQuery;
        if (!is(select, SQL) && !haveSameKeys(this.table[Columns], select._.selectedFields)) {
          throw new Error(
            "Insert select error: selected fields are not the same or are in a different order compared to the table definition"
          );
        }
        return new SQLiteInsertBase(this.table, select, this.session, this.dialect, this.withList, true);
      }
    };
    SQLiteInsertBase = class extends QueryPromise {
      static {
        __name(this, "SQLiteInsertBase");
      }
      constructor(table, values, session, dialect, withList, select) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { table, values, withList, select };
      }
      static [entityKind] = "SQLiteInsert";
      /** @internal */
      config;
      returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /**
       * Adds an `on conflict do nothing` clause to the query.
       *
       * Calling this method simply avoids inserting a row as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
       *
       * @param config The `target` and `where` clauses.
       *
       * @example
       * ```ts
       * // Insert one row and cancel the insert if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing();
       *
       * // Explicitly specify conflict target
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing({ target: cars.id });
       * ```
       */
      onConflictDoNothing(config = {}) {
        if (!this.config.onConflict)
          this.config.onConflict = [];
        if (config.target === void 0) {
          this.config.onConflict.push(sql` on conflict do nothing`);
        } else {
          const targetSql = Array.isArray(config.target) ? sql`${config.target}` : sql`${[config.target]}`;
          const whereSql = config.where ? sql` where ${config.where}` : sql``;
          this.config.onConflict.push(sql` on conflict ${targetSql} do nothing${whereSql}`);
        }
        return this;
      }
      /**
       * Adds an `on conflict do update` clause to the query.
       *
       * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}
       *
       * @param config The `target`, `set` and `where` clauses.
       *
       * @example
       * ```ts
       * // Update the row if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'Porsche' }
       *   });
       *
       * // Upsert with 'where' clause
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'newBMW' },
       *     where: sql`${cars.createdAt} > '2023-01-01'::date`,
       *   });
       * ```
       */
      onConflictDoUpdate(config) {
        if (config.where && (config.targetWhere || config.setWhere)) {
          throw new Error(
            'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.'
          );
        }
        if (!this.config.onConflict)
          this.config.onConflict = [];
        const whereSql = config.where ? sql` where ${config.where}` : void 0;
        const targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : void 0;
        const setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : void 0;
        const targetSql = Array.isArray(config.target) ? sql`${config.target}` : sql`${[config.target]}`;
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
        this.config.onConflict.push(
          sql` on conflict ${targetSql}${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`
        );
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildInsertQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run",
          true
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().run(placeholderValues);
      }, "run");
      all = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().all(placeholderValues);
      }, "all");
      get = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().get(placeholderValues);
      }, "get");
      values = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().values(placeholderValues);
      }, "values");
      async execute() {
        return this.config.returning ? this.all() : this.run();
      }
      $dynamic() {
        return this;
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/query-builders/select.types.js
var init_select_types = __esm({
  "../node_modules/drizzle-orm/sqlite-core/query-builders/select.types.js"() {
    init_functionsRoutes_0_8044054200943971();
  }
});

// ../node_modules/drizzle-orm/sqlite-core/query-builders/update.js
var SQLiteUpdateBuilder, SQLiteUpdateBase;
var init_update = __esm({
  "../node_modules/drizzle-orm/sqlite-core/query-builders/update.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_query_promise();
    init_selection_proxy();
    init_table2();
    init_subquery();
    init_table();
    init_utils();
    init_view_common();
    init_view_base();
    SQLiteUpdateBuilder = class {
      static {
        __name(this, "SQLiteUpdateBuilder");
      }
      constructor(table, session, dialect, withList) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      static [entityKind] = "SQLiteUpdateBuilder";
      set(values) {
        return new SQLiteUpdateBase(
          this.table,
          mapUpdateSet(this.table, values),
          this.session,
          this.dialect,
          this.withList
        );
      }
    };
    SQLiteUpdateBase = class extends QueryPromise {
      static {
        __name(this, "SQLiteUpdateBase");
      }
      constructor(table, set, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { set, table, withList, joins: [] };
      }
      static [entityKind] = "SQLiteUpdate";
      /** @internal */
      config;
      from(source) {
        this.config.from = source;
        return this;
      }
      createJoin(joinType) {
        return (table, on) => {
          const tableName = getTableLikeName(table);
          if (typeof tableName === "string" && this.config.joins.some((join) => join.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (typeof on === "function") {
            const from = this.config.from ? is(table, SQLiteTable) ? table[Table.Symbol.Columns] : is(table, Subquery) ? table._.selectedFields : is(table, SQLiteViewBase) ? table[ViewBaseConfig].selectedFields : void 0 : void 0;
            on = on(
              new Proxy(
                this.config.table[Table.Symbol.Columns],
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              ),
              from && new Proxy(
                from,
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              )
            );
          }
          this.config.joins.push({ on, table, joinType, alias: tableName });
          return this;
        };
      }
      leftJoin = this.createJoin("left");
      rightJoin = this.createJoin("right");
      innerJoin = this.createJoin("inner");
      fullJoin = this.createJoin("full");
      /**
       * Adds a 'where' clause to the query.
       *
       * Calling this method will update only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param where the 'where' clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be updated.
       *
       * ```ts
       * // Update all cars with green color
       * db.update(cars).set({ color: 'red' })
       *   .where(eq(cars.color, 'green'));
       * // or
       * db.update(cars).set({ color: 'red' })
       *   .where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Update all BMW cars with a green color
       * db.update(cars).set({ color: 'red' })
       *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Update all cars with the green or blue color
       * db.update(cars).set({ color: 'red' })
       *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](
            new Proxy(
              this.config.table[Table.Symbol.Columns],
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
          this.config.orderBy = orderByArray;
        } else {
          const orderByArray = columns;
          this.config.orderBy = orderByArray;
        }
        return this;
      }
      limit(limit) {
        this.config.limit = limit;
        return this;
      }
      returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run",
          true
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().run(placeholderValues);
      }, "run");
      all = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().all(placeholderValues);
      }, "all");
      get = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().get(placeholderValues);
      }, "get");
      values = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().values(placeholderValues);
      }, "values");
      async execute() {
        return this.config.returning ? this.all() : this.run();
      }
      $dynamic() {
        return this;
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/query-builders/index.js
var init_query_builders = __esm({
  "../node_modules/drizzle-orm/sqlite-core/query-builders/index.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_delete();
    init_insert();
    init_query_builder2();
    init_select2();
    init_select_types();
    init_update();
  }
});

// ../node_modules/drizzle-orm/sqlite-core/query-builders/count.js
var SQLiteCountBuilder;
var init_count = __esm({
  "../node_modules/drizzle-orm/sqlite-core/query-builders/count.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_sql();
    SQLiteCountBuilder = class _SQLiteCountBuilder extends SQL {
      static {
        __name(this, "SQLiteCountBuilder");
      }
      constructor(params) {
        super(_SQLiteCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
        this.params = params;
        this.session = params.session;
        this.sql = _SQLiteCountBuilder.buildCount(
          params.source,
          params.filters
        );
      }
      sql;
      static [entityKind] = "SQLiteCountBuilderAsync";
      [Symbol.toStringTag] = "SQLiteCountBuilderAsync";
      session;
      static buildEmbeddedCount(source, filters) {
        return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
      }
      static buildCount(source, filters) {
        return sql`select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters}`;
      }
      then(onfulfilled, onrejected) {
        return Promise.resolve(this.session.count(this.sql)).then(
          onfulfilled,
          onrejected
        );
      }
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      finally(onFinally) {
        return this.then(
          (value) => {
            onFinally?.();
            return value;
          },
          (reason) => {
            onFinally?.();
            throw reason;
          }
        );
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/query-builders/query.js
var RelationalQueryBuilder, SQLiteRelationalQuery, SQLiteSyncRelationalQuery;
var init_query = __esm({
  "../node_modules/drizzle-orm/sqlite-core/query-builders/query.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_query_promise();
    init_relations();
    RelationalQueryBuilder = class {
      static {
        __name(this, "RelationalQueryBuilder");
      }
      constructor(mode, fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
        this.mode = mode;
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
      }
      static [entityKind] = "SQLiteAsyncRelationalQueryBuilder";
      findMany(config) {
        return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config ? config : {},
          "many"
        ) : new SQLiteRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config ? config : {},
          "many"
        );
      }
      findFirst(config) {
        return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config ? { ...config, limit: 1 } : { limit: 1 },
          "first"
        ) : new SQLiteRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config ? { ...config, limit: 1 } : { limit: 1 },
          "first"
        );
      }
    };
    SQLiteRelationalQuery = class extends QueryPromise {
      static {
        __name(this, "SQLiteRelationalQuery");
      }
      constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config;
        this.mode = mode;
      }
      static [entityKind] = "SQLiteAsyncRelationalQuery";
      /** @internal */
      mode;
      /** @internal */
      getSQL() {
        return this.dialect.buildRelationalQuery({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        }).sql;
      }
      /** @internal */
      _prepare(isOneTimeQuery = false) {
        const { query, builtQuery } = this._toSQL();
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          builtQuery,
          void 0,
          this.mode === "first" ? "get" : "all",
          true,
          (rawRows, mapColumnValue) => {
            const rows = rawRows.map(
              (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
            );
            if (this.mode === "first") {
              return rows[0];
            }
            return rows;
          }
        );
      }
      prepare() {
        return this._prepare(false);
      }
      _toSQL() {
        const query = this.dialect.buildRelationalQuery({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        });
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return { query, builtQuery };
      }
      toSQL() {
        return this._toSQL().builtQuery;
      }
      /** @internal */
      executeRaw() {
        if (this.mode === "first") {
          return this._prepare(false).get();
        }
        return this._prepare(false).all();
      }
      async execute() {
        return this.executeRaw();
      }
    };
    SQLiteSyncRelationalQuery = class extends SQLiteRelationalQuery {
      static {
        __name(this, "SQLiteSyncRelationalQuery");
      }
      static [entityKind] = "SQLiteSyncRelationalQuery";
      sync() {
        return this.executeRaw();
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/query-builders/raw.js
var SQLiteRaw;
var init_raw = __esm({
  "../node_modules/drizzle-orm/sqlite-core/query-builders/raw.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_query_promise();
    SQLiteRaw = class extends QueryPromise {
      static {
        __name(this, "SQLiteRaw");
      }
      constructor(execute, getSQL, action, dialect, mapBatchResult) {
        super();
        this.execute = execute;
        this.getSQL = getSQL;
        this.dialect = dialect;
        this.mapBatchResult = mapBatchResult;
        this.config = { action };
      }
      static [entityKind] = "SQLiteRaw";
      /** @internal */
      config;
      getQuery() {
        return { ...this.dialect.sqlToQuery(this.getSQL()), method: this.config.action };
      }
      mapResult(result, isFromBatch) {
        return isFromBatch ? this.mapBatchResult(result) : result;
      }
      _prepare() {
        return this;
      }
      /** @internal */
      isResponseInArrayMode() {
        return false;
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/db.js
var BaseSQLiteDatabase;
var init_db2 = __esm({
  "../node_modules/drizzle-orm/sqlite-core/db.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_selection_proxy();
    init_sql();
    init_query_builders();
    init_subquery();
    init_count();
    init_query();
    init_raw();
    BaseSQLiteDatabase = class {
      static {
        __name(this, "BaseSQLiteDatabase");
      }
      constructor(resultKind, dialect, session, schema) {
        this.resultKind = resultKind;
        this.dialect = dialect;
        this.session = session;
        this._ = schema ? {
          schema: schema.schema,
          fullSchema: schema.fullSchema,
          tableNamesMap: schema.tableNamesMap
        } : {
          schema: void 0,
          fullSchema: {},
          tableNamesMap: {}
        };
        this.query = {};
        const query = this.query;
        if (this._.schema) {
          for (const [tableName, columns] of Object.entries(this._.schema)) {
            query[tableName] = new RelationalQueryBuilder(
              resultKind,
              schema.fullSchema,
              this._.schema,
              this._.tableNamesMap,
              schema.fullSchema[tableName],
              columns,
              dialect,
              session
            );
          }
        }
      }
      static [entityKind] = "BaseSQLiteDatabase";
      query;
      /**
       * Creates a subquery that defines a temporary named result set as a CTE.
       *
       * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param alias The alias for the subquery.
       *
       * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
       *
       * @example
       *
       * ```ts
       * // Create a subquery with alias 'sq' and use it in the select query
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * const result = await db.with(sq).select().from(sq);
       * ```
       *
       * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
       *
       * ```ts
       * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
       * const sq = db.$with('sq').as(db.select({
       *   name: sql<string>`upper(${users.name})`.as('name'),
       * })
       * .from(users));
       *
       * const result = await db.with(sq).select({ name: sq.name }).from(sq);
       * ```
       */
      $with = /* @__PURE__ */ __name((alias, selection) => {
        const self = this;
        const as = /* @__PURE__ */ __name((qb) => {
          if (typeof qb === "function") {
            qb = qb(new QueryBuilder(self.dialect));
          }
          return new Proxy(
            new WithSubquery(
              qb.getSQL(),
              selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}),
              alias,
              true
            ),
            new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
          );
        }, "as");
        return { as };
      }, "$with");
      $count(source, filters) {
        return new SQLiteCountBuilder({ source, filters, session: this.session });
      }
      /**
       * Incorporates a previously defined CTE (using `$with`) into the main query.
       *
       * This method allows the main query to reference a temporary named result set.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param queries The CTEs to incorporate into the main query.
       *
       * @example
       *
       * ```ts
       * // Define a subquery 'sq' as a CTE using $with
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * // Incorporate the CTE 'sq' into the main query and select from it
       * const result = await db.with(sq).select().from(sq);
       * ```
       */
      with(...queries) {
        const self = this;
        function select(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries
          });
        }
        __name(select, "select");
        function selectDistinct(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries,
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        function update(table) {
          return new SQLiteUpdateBuilder(table, self.session, self.dialect, queries);
        }
        __name(update, "update");
        function insert(into) {
          return new SQLiteInsertBuilder(into, self.session, self.dialect, queries);
        }
        __name(insert, "insert");
        function delete_(from) {
          return new SQLiteDeleteBase(from, self.session, self.dialect, queries);
        }
        __name(delete_, "delete_");
        return { select, selectDistinct, update, insert, delete: delete_ };
      }
      select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
      }
      selectDistinct(fields) {
        return new SQLiteSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect,
          distinct: true
        });
      }
      /**
       * Creates an update query.
       *
       * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
       *
       * Use `.set()` method to specify which values to update.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param table The table to update.
       *
       * @example
       *
       * ```ts
       * // Update all rows in the 'cars' table
       * await db.update(cars).set({ color: 'red' });
       *
       * // Update rows with filters and conditions
       * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
       *
       * // Update with returning clause
       * const updatedCar: Car[] = await db.update(cars)
       *   .set({ color: 'red' })
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      update(table) {
        return new SQLiteUpdateBuilder(table, this.session, this.dialect);
      }
      /**
       * Creates an insert query.
       *
       * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert}
       *
       * @param table The table to insert into.
       *
       * @example
       *
       * ```ts
       * // Insert one row
       * await db.insert(cars).values({ brand: 'BMW' });
       *
       * // Insert multiple rows
       * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
       *
       * // Insert with returning clause
       * const insertedCar: Car[] = await db.insert(cars)
       *   .values({ brand: 'BMW' })
       *   .returning();
       * ```
       */
      insert(into) {
        return new SQLiteInsertBuilder(into, this.session, this.dialect);
      }
      /**
       * Creates a delete query.
       *
       * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param table The table to delete from.
       *
       * @example
       *
       * ```ts
       * // Delete all rows in the 'cars' table
       * await db.delete(cars);
       *
       * // Delete rows with filters and conditions
       * await db.delete(cars).where(eq(cars.color, 'green'));
       *
       * // Delete with returning clause
       * const deletedCar: Car[] = await db.delete(cars)
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      delete(from) {
        return new SQLiteDeleteBase(from, this.session, this.dialect);
      }
      run(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.run(sequel),
            () => sequel,
            "run",
            this.dialect,
            this.session.extractRawRunValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.run(sequel);
      }
      all(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.all(sequel),
            () => sequel,
            "all",
            this.dialect,
            this.session.extractRawAllValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.all(sequel);
      }
      get(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.get(sequel),
            () => sequel,
            "get",
            this.dialect,
            this.session.extractRawGetValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.get(sequel);
      }
      values(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.values(sequel),
            () => sequel,
            "values",
            this.dialect,
            this.session.extractRawValuesValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.values(sequel);
      }
      transaction(transaction, config) {
        return this.session.transaction(transaction, config);
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/indexes.js
var IndexBuilderOn, IndexBuilder, Index;
var init_indexes = __esm({
  "../node_modules/drizzle-orm/sqlite-core/indexes.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    IndexBuilderOn = class {
      static {
        __name(this, "IndexBuilderOn");
      }
      constructor(name, unique) {
        this.name = name;
        this.unique = unique;
      }
      static [entityKind] = "SQLiteIndexBuilderOn";
      on(...columns) {
        return new IndexBuilder(this.name, columns, this.unique);
      }
    };
    IndexBuilder = class {
      static {
        __name(this, "IndexBuilder");
      }
      static [entityKind] = "SQLiteIndexBuilder";
      /** @internal */
      config;
      constructor(name, columns, unique) {
        this.config = {
          name,
          columns,
          unique,
          where: void 0
        };
      }
      /**
       * Condition for partial index.
       */
      where(condition) {
        this.config.where = condition;
        return this;
      }
      /** @internal */
      build(table) {
        return new Index(this.config, table);
      }
    };
    Index = class {
      static {
        __name(this, "Index");
      }
      static [entityKind] = "SQLiteIndex";
      config;
      constructor(config, table) {
        this.config = { ...config, table };
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/primary-keys.js
var PrimaryKeyBuilder2, PrimaryKey2;
var init_primary_keys2 = __esm({
  "../node_modules/drizzle-orm/sqlite-core/primary-keys.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_table2();
    PrimaryKeyBuilder2 = class {
      static {
        __name(this, "PrimaryKeyBuilder");
      }
      static [entityKind] = "SQLitePrimaryKeyBuilder";
      /** @internal */
      columns;
      /** @internal */
      name;
      constructor(columns, name) {
        this.columns = columns;
        this.name = name;
      }
      /** @internal */
      build(table) {
        return new PrimaryKey2(table, this.columns, this.name);
      }
    };
    PrimaryKey2 = class {
      static {
        __name(this, "PrimaryKey");
      }
      constructor(table, columns, name) {
        this.table = table;
        this.columns = columns;
        this.name = name;
      }
      static [entityKind] = "SQLitePrimaryKey";
      columns;
      name;
      getName() {
        return this.name ?? `${this.table[SQLiteTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/session.js
var ExecuteResultSync, SQLitePreparedQuery, SQLiteSession, SQLiteTransaction;
var init_session = __esm({
  "../node_modules/drizzle-orm/sqlite-core/session.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_errors();
    init_query_promise();
    init_db2();
    ExecuteResultSync = class extends QueryPromise {
      static {
        __name(this, "ExecuteResultSync");
      }
      constructor(resultCb) {
        super();
        this.resultCb = resultCb;
      }
      static [entityKind] = "ExecuteResultSync";
      async execute() {
        return this.resultCb();
      }
      sync() {
        return this.resultCb();
      }
    };
    SQLitePreparedQuery = class {
      static {
        __name(this, "SQLitePreparedQuery");
      }
      constructor(mode, executeMethod, query) {
        this.mode = mode;
        this.executeMethod = executeMethod;
        this.query = query;
      }
      static [entityKind] = "PreparedQuery";
      /** @internal */
      joinsNotNullableMap;
      getQuery() {
        return this.query;
      }
      mapRunResult(result, _isFromBatch) {
        return result;
      }
      mapAllResult(_result, _isFromBatch) {
        throw new Error("Not implemented");
      }
      mapGetResult(_result, _isFromBatch) {
        throw new Error("Not implemented");
      }
      execute(placeholderValues) {
        if (this.mode === "async") {
          return this[this.executeMethod](placeholderValues);
        }
        return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
      }
      mapResult(response, isFromBatch) {
        switch (this.executeMethod) {
          case "run": {
            return this.mapRunResult(response, isFromBatch);
          }
          case "all": {
            return this.mapAllResult(response, isFromBatch);
          }
          case "get": {
            return this.mapGetResult(response, isFromBatch);
          }
        }
      }
    };
    SQLiteSession = class {
      static {
        __name(this, "SQLiteSession");
      }
      constructor(dialect) {
        this.dialect = dialect;
      }
      static [entityKind] = "SQLiteSession";
      prepareOneTimeQuery(query, fields, executeMethod, isResponseInArrayMode) {
        return this.prepareQuery(query, fields, executeMethod, isResponseInArrayMode);
      }
      run(query) {
        const staticQuery = this.dialect.sqlToQuery(query);
        try {
          return this.prepareOneTimeQuery(staticQuery, void 0, "run", false).run();
        } catch (err) {
          throw new DrizzleError({ cause: err, message: `Failed to run the query '${staticQuery.sql}'` });
        }
      }
      /** @internal */
      extractRawRunValueFromBatchResult(result) {
        return result;
      }
      all(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).all();
      }
      /** @internal */
      extractRawAllValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
      get(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).get();
      }
      /** @internal */
      extractRawGetValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
      values(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).values();
      }
      async count(sql2) {
        const result = await this.values(sql2);
        return result[0][0];
      }
      /** @internal */
      extractRawValuesValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
    };
    SQLiteTransaction = class extends BaseSQLiteDatabase {
      static {
        __name(this, "SQLiteTransaction");
      }
      constructor(resultType, dialect, session, schema, nestedIndex = 0) {
        super(resultType, dialect, session, schema);
        this.schema = schema;
        this.nestedIndex = nestedIndex;
      }
      static [entityKind] = "SQLiteTransaction";
      rollback() {
        throw new TransactionRollbackError();
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/subquery.js
var init_subquery2 = __esm({
  "../node_modules/drizzle-orm/sqlite-core/subquery.js"() {
    init_functionsRoutes_0_8044054200943971();
  }
});

// ../node_modules/drizzle-orm/sqlite-core/utils.js
var init_utils2 = __esm({
  "../node_modules/drizzle-orm/sqlite-core/utils.js"() {
    init_functionsRoutes_0_8044054200943971();
  }
});

// ../node_modules/drizzle-orm/sqlite-core/view.js
var ViewBuilderCore, ViewBuilder, ManualViewBuilder, SQLiteView;
var init_view = __esm({
  "../node_modules/drizzle-orm/sqlite-core/view.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_selection_proxy();
    init_utils();
    init_query_builder2();
    init_table2();
    init_view_base();
    ViewBuilderCore = class {
      static {
        __name(this, "ViewBuilderCore");
      }
      constructor(name) {
        this.name = name;
      }
      static [entityKind] = "SQLiteViewBuilderCore";
      config = {};
    };
    ViewBuilder = class extends ViewBuilderCore {
      static {
        __name(this, "ViewBuilder");
      }
      static [entityKind] = "SQLiteViewBuilder";
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        });
        const aliasedSelectedFields = qb.getSelectedFields();
        return new Proxy(
          new SQLiteView({
            // sqliteConfig: this.config,
            config: {
              name: this.name,
              schema: void 0,
              selectedFields: aliasedSelectedFields,
              query: qb.getSQL().inlineParams()
            }
          }),
          selectionProxy
        );
      }
    };
    ManualViewBuilder = class extends ViewBuilderCore {
      static {
        __name(this, "ManualViewBuilder");
      }
      static [entityKind] = "SQLiteManualViewBuilder";
      columns;
      constructor(name, columns) {
        super(name);
        this.columns = getTableColumns(sqliteTable(name, columns));
      }
      existing() {
        return new Proxy(
          new SQLiteView({
            config: {
              name: this.name,
              schema: void 0,
              selectedFields: this.columns,
              query: void 0
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
      as(query) {
        return new Proxy(
          new SQLiteView({
            config: {
              name: this.name,
              schema: void 0,
              selectedFields: this.columns,
              query: query.inlineParams()
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
    };
    SQLiteView = class extends SQLiteViewBase {
      static {
        __name(this, "SQLiteView");
      }
      static [entityKind] = "SQLiteView";
      constructor({ config }) {
        super(config);
      }
    };
  }
});

// ../node_modules/drizzle-orm/sqlite-core/index.js
var init_sqlite_core = __esm({
  "../node_modules/drizzle-orm/sqlite-core/index.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_alias2();
    init_checks();
    init_columns();
    init_db2();
    init_dialect();
    init_foreign_keys2();
    init_indexes();
    init_primary_keys2();
    init_query_builders();
    init_session();
    init_subquery2();
    init_table2();
    init_unique_constraint2();
    init_utils2();
    init_view();
  }
});

// ../node_modules/drizzle-orm/expressions.js
var init_expressions2 = __esm({
  "../node_modules/drizzle-orm/expressions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_expressions();
  }
});

// ../node_modules/drizzle-orm/logger.js
var ConsoleLogWriter, DefaultLogger, NoopLogger;
var init_logger = __esm({
  "../node_modules/drizzle-orm/logger.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    ConsoleLogWriter = class {
      static {
        __name(this, "ConsoleLogWriter");
      }
      static [entityKind] = "ConsoleLogWriter";
      write(message) {
        console.log(message);
      }
    };
    DefaultLogger = class {
      static {
        __name(this, "DefaultLogger");
      }
      static [entityKind] = "DefaultLogger";
      writer;
      constructor(config) {
        this.writer = config?.writer ?? new ConsoleLogWriter();
      }
      logQuery(query, params) {
        const stringifiedParams = params.map((p) => {
          try {
            return JSON.stringify(p);
          } catch {
            return String(p);
          }
        });
        const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
        this.writer.write(`Query: ${query}${paramsStr}`);
      }
    };
    NoopLogger = class {
      static {
        __name(this, "NoopLogger");
      }
      static [entityKind] = "NoopLogger";
      logQuery() {
      }
    };
  }
});

// ../node_modules/drizzle-orm/operations.js
var init_operations = __esm({
  "../node_modules/drizzle-orm/operations.js"() {
    init_functionsRoutes_0_8044054200943971();
  }
});

// ../node_modules/drizzle-orm/index.js
var init_drizzle_orm = __esm({
  "../node_modules/drizzle-orm/index.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_alias();
    init_column_builder();
    init_column();
    init_entity();
    init_errors();
    init_expressions2();
    init_logger();
    init_operations();
    init_query_promise();
    init_relations();
    init_sql2();
    init_subquery();
    init_table();
    init_utils();
    init_view_common();
  }
});

// ../node_modules/zod/lib/index.mjs
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var util, objectUtil, ZodParsedType, getParsedType, ZodIssueCode, quotelessJson, ZodError, errorMap, overrideErrorMap, makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, errorUtil, _ZodEnum_cache, _ZodNativeEnum_cache, ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER, z;
var init_lib = __esm({
  "../node_modules/zod/lib/index.mjs"() {
    init_functionsRoutes_0_8044054200943971();
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      __name(assertIs, "assertIs");
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      __name(assertNever, "assertNever");
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      __name(joinValues, "joinValues");
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = /* @__PURE__ */ __name((data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    }, "getParsedType");
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = /* @__PURE__ */ __name((obj) => {
      const json25 = JSON.stringify(obj, null, 2);
      return json25.replace(/"([^"]+)":/g, "$1:");
    }, "quotelessJson");
    ZodError = class _ZodError extends Error {
      static {
        __name(this, "ZodError");
      }
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = /* @__PURE__ */ __name((error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        }, "processError");
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
    errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    }, "errorMap");
    overrideErrorMap = errorMap;
    __name(setErrorMap, "setErrorMap");
    __name(getErrorMap, "getErrorMap");
    makeIssue = /* @__PURE__ */ __name((params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    }, "makeIssue");
    EMPTY_PATH = [];
    __name(addIssueToContext, "addIssueToContext");
    ParseStatus = class _ParseStatus {
      static {
        __name(this, "ParseStatus");
      }
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
    OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
    isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
    isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
    isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
    isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");
    __name(__classPrivateFieldGet, "__classPrivateFieldGet");
    __name(__classPrivateFieldSet, "__classPrivateFieldSet");
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    ParseInputLazyPath = class {
      static {
        __name(this, "ParseInputLazyPath");
      }
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = /* @__PURE__ */ __name((ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    }, "handleResult");
    __name(processCreateParams, "processCreateParams");
    ZodType = class {
      static {
        __name(this, "ZodType");
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        var _a, _b;
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return isValid(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = /* @__PURE__ */ __name((val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        }, "getIssueProperties");
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          }), "setError");
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    __name(timeRegexSource, "timeRegexSource");
    __name(timeRegex, "timeRegex");
    __name(datetimeRegex, "datetimeRegex");
    __name(isValidIP, "isValidIP");
    __name(isValidJWT, "isValidJWT");
    __name(isValidCidr, "isValidCidr");
    ZodString = class _ZodString extends ZodType {
      static {
        __name(this, "ZodString");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "jwt") {
            if (!isValidJWT(input.data, check.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "jwt",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cidr") {
            if (!isValidCidr(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cidr",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil.errToObj(message)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a, _b;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    __name(floatSafeRemainder, "floatSafeRemainder");
    ZodNumber = class _ZodNumber extends ZodType {
      static {
        __name(this, "ZodNumber");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      static {
        __name(this, "ZodBigInt");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch (_a) {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return INVALID;
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = class extends ZodType {
      static {
        __name(this, "ZodBoolean");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      static {
        __name(this, "ZodDate");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = class extends ZodType {
      static {
        __name(this, "ZodSymbol");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = class extends ZodType {
      static {
        __name(this, "ZodUndefined");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = class extends ZodType {
      static {
        __name(this, "ZodNull");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = class extends ZodType {
      static {
        __name(this, "ZodAny");
      }
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = class extends ZodType {
      static {
        __name(this, "ZodUnknown");
      }
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = class extends ZodType {
      static {
        __name(this, "ZodNever");
      }
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = class extends ZodType {
      static {
        __name(this, "ZodVoid");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      static {
        __name(this, "ZodArray");
      }
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    __name(deepPartialify, "deepPartialify");
    ZodObject = class _ZodObject extends ZodType {
      static {
        __name(this, "ZodObject");
      }
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: /* @__PURE__ */ __name((issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }, "errorMap")
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...augmentation
          }), "shape")
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }), "shape"),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = class extends ZodType {
      static {
        __name(this, "ZodUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        __name(handleResults, "handleResults");
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = /* @__PURE__ */ __name((type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    }, "getDiscriminator");
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      static {
        __name(this, "ZodDiscriminatedUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    __name(mergeValues, "mergeValues");
    ZodIntersection = class extends ZodType {
      static {
        __name(this, "ZodIntersection");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        }, "handleParsed");
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      static {
        __name(this, "ZodTuple");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      static {
        __name(this, "ZodRecord");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      static {
        __name(this, "ZodMap");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      static {
        __name(this, "ZodSet");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        __name(finalizeSet, "finalizeSet");
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      static {
        __name(this, "ZodFunction");
      }
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        __name(makeArgsIssue, "makeArgsIssue");
        function makeReturnsIssue(returns, error) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        __name(makeReturnsIssue, "makeReturnsIssue");
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return OK(async function(...args) {
            const error = new ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy = class extends ZodType {
      static {
        __name(this, "ZodLazy");
      }
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = class extends ZodType {
      static {
        __name(this, "ZodLiteral");
      }
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    __name(createZodEnum, "createZodEnum");
    ZodEnum = class _ZodEnum extends ZodType {
      static {
        __name(this, "ZodEnum");
      }
      constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      static {
        __name(this, "ZodNativeEnum");
      }
      constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
      }
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = class extends ZodType {
      static {
        __name(this, "ZodPromise");
      }
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType {
      static {
        __name(this, "ZodEffects");
      }
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: /* @__PURE__ */ __name((arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          }, "addIssue"),
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY(result.value);
              if (status.value === "dirty")
                return DIRTY(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = /* @__PURE__ */ __name((acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          }, "executeRefinement");
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return base;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return base;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = class extends ZodType {
      static {
        __name(this, "ZodOptional");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = class extends ZodType {
      static {
        __name(this, "ZodNullable");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = class extends ZodType {
      static {
        __name(this, "ZodDefault");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = class extends ZodType {
      static {
        __name(this, "ZodCatch");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN = class extends ZodType {
      static {
        __name(this, "ZodNaN");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      static {
        __name(this, "ZodBranded");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      static {
        __name(this, "ZodPipeline");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = /* @__PURE__ */ __name(async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }, "handleAsync");
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      static {
        __name(this, "ZodReadonly");
      }
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = /* @__PURE__ */ __name((data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        }, "freeze");
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    __name(cleanParams, "cleanParams");
    __name(custom, "custom");
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = /* @__PURE__ */ __name((cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params), "instanceOfType");
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
    onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
    oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
    coerce = {
      string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), "string"),
      number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), "number"),
      boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }), "boolean"),
      bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), "bigint"),
      date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), "date")
    };
    NEVER = INVALID;
    z = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap,
      setErrorMap,
      getErrorMap,
      makeIssue,
      EMPTY_PATH,
      addIssueToContext,
      ParseStatus,
      INVALID,
      DIRTY,
      OK,
      isAborted,
      isDirty,
      isValid,
      isAsync,
      get util() {
        return util;
      },
      get objectUtil() {
        return objectUtil;
      },
      ZodParsedType,
      getParsedType,
      ZodType,
      datetimeRegex,
      ZodString,
      ZodNumber,
      ZodBigInt,
      ZodBoolean,
      ZodDate,
      ZodSymbol,
      ZodUndefined,
      ZodNull,
      ZodAny,
      ZodUnknown,
      ZodNever,
      ZodVoid,
      ZodArray,
      ZodObject,
      ZodUnion,
      ZodDiscriminatedUnion,
      ZodIntersection,
      ZodTuple,
      ZodRecord,
      ZodMap,
      ZodSet,
      ZodFunction,
      ZodLazy,
      ZodLiteral,
      ZodEnum,
      ZodNativeEnum,
      ZodPromise,
      ZodEffects,
      ZodTransformer: ZodEffects,
      ZodOptional,
      ZodNullable,
      ZodDefault,
      ZodCatch,
      ZodNaN,
      BRAND,
      ZodBranded,
      ZodPipeline,
      ZodReadonly,
      custom,
      Schema: ZodType,
      ZodSchema: ZodType,
      late,
      get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind;
      },
      coerce,
      any: anyType,
      array: arrayType,
      bigint: bigIntType,
      boolean: booleanType,
      date: dateType,
      discriminatedUnion: discriminatedUnionType,
      effect: effectsType,
      "enum": enumType,
      "function": functionType,
      "instanceof": instanceOfType,
      intersection: intersectionType,
      lazy: lazyType,
      literal: literalType,
      map: mapType,
      nan: nanType,
      nativeEnum: nativeEnumType,
      never: neverType,
      "null": nullType,
      nullable: nullableType,
      number: numberType,
      object: objectType,
      oboolean,
      onumber,
      optional: optionalType,
      ostring,
      pipeline: pipelineType,
      preprocess: preprocessType,
      promise: promiseType,
      record: recordType,
      set: setType,
      strictObject: strictObjectType,
      string: stringType,
      symbol: symbolType,
      transformer: effectsType,
      tuple: tupleType,
      "undefined": undefinedType,
      union: unionType,
      unknown: unknownType,
      "void": voidType,
      NEVER,
      ZodIssueCode,
      quotelessJson,
      ZodError
    });
  }
});

// ../node_modules/drizzle-zod/index.mjs
function isColumnType(column, columnTypes) {
  return columnTypes.includes(column.columnType);
}
function isWithEnum(column) {
  return "enumValues" in column && Array.isArray(column.enumValues) && column.enumValues.length > 0;
}
function columnToSchema(column, factory) {
  const z$1 = factory?.zodInstance ?? z;
  const coerce2 = factory?.coerce ?? {};
  let schema;
  if (isWithEnum(column)) {
    schema = column.enumValues.length ? z$1.enum(column.enumValues) : z$1.string();
  }
  if (!schema) {
    if (isColumnType(column, ["PgGeometry", "PgPointTuple"])) {
      schema = z$1.tuple([z$1.number(), z$1.number()]);
    } else if (isColumnType(column, ["PgGeometryObject", "PgPointObject"])) {
      schema = z$1.object({ x: z$1.number(), y: z$1.number() });
    } else if (isColumnType(column, ["PgHalfVector", "PgVector"])) {
      schema = z$1.array(z$1.number());
      schema = column.dimensions ? schema.length(column.dimensions) : schema;
    } else if (isColumnType(column, ["PgLine"])) {
      schema = z$1.tuple([z$1.number(), z$1.number(), z$1.number()]);
    } else if (isColumnType(column, ["PgLineABC"])) {
      schema = z$1.object({
        a: z$1.number(),
        b: z$1.number(),
        c: z$1.number()
      });
    } else if (isColumnType(column, ["PgArray"])) {
      schema = z$1.array(columnToSchema(column.baseColumn, z$1));
      schema = column.size ? schema.length(column.size) : schema;
    } else if (column.dataType === "array") {
      schema = z$1.array(z$1.any());
    } else if (column.dataType === "number") {
      schema = numberColumnToSchema(column, z$1, coerce2);
    } else if (column.dataType === "bigint") {
      schema = bigintColumnToSchema(column, z$1, coerce2);
    } else if (column.dataType === "boolean") {
      schema = coerce2 === true || coerce2.boolean ? z$1.coerce.boolean() : z$1.boolean();
    } else if (column.dataType === "date") {
      schema = coerce2 === true || coerce2.date ? z$1.coerce.date() : z$1.date();
    } else if (column.dataType === "string") {
      schema = stringColumnToSchema(column, z$1, coerce2);
    } else if (column.dataType === "json") {
      schema = jsonSchema;
    } else if (column.dataType === "custom") {
      schema = z$1.any();
    } else if (column.dataType === "buffer") {
      schema = bufferSchema;
    }
  }
  if (!schema) {
    schema = z$1.any();
  }
  return schema;
}
function numberColumnToSchema(column, z2, coerce2) {
  let unsigned = column.getSQLType().includes("unsigned");
  let min;
  let max;
  let integer2 = false;
  if (isColumnType(column, ["MySqlTinyInt", "SingleStoreTinyInt"])) {
    min = unsigned ? 0 : CONSTANTS.INT8_MIN;
    max = unsigned ? CONSTANTS.INT8_UNSIGNED_MAX : CONSTANTS.INT8_MAX;
    integer2 = true;
  } else if (isColumnType(column, [
    "PgSmallInt",
    "PgSmallSerial",
    "MySqlSmallInt",
    "SingleStoreSmallInt"
  ])) {
    min = unsigned ? 0 : CONSTANTS.INT16_MIN;
    max = unsigned ? CONSTANTS.INT16_UNSIGNED_MAX : CONSTANTS.INT16_MAX;
    integer2 = true;
  } else if (isColumnType(column, [
    "PgReal",
    "MySqlFloat",
    "MySqlMediumInt",
    "SingleStoreMediumInt",
    "SingleStoreFloat"
  ])) {
    min = unsigned ? 0 : CONSTANTS.INT24_MIN;
    max = unsigned ? CONSTANTS.INT24_UNSIGNED_MAX : CONSTANTS.INT24_MAX;
    integer2 = isColumnType(column, ["MySqlMediumInt", "SingleStoreMediumInt"]);
  } else if (isColumnType(column, [
    "PgInteger",
    "PgSerial",
    "MySqlInt",
    "SingleStoreInt"
  ])) {
    min = unsigned ? 0 : CONSTANTS.INT32_MIN;
    max = unsigned ? CONSTANTS.INT32_UNSIGNED_MAX : CONSTANTS.INT32_MAX;
    integer2 = true;
  } else if (isColumnType(column, [
    "PgDoublePrecision",
    "MySqlReal",
    "MySqlDouble",
    "SingleStoreReal",
    "SingleStoreDouble",
    "SQLiteReal"
  ])) {
    min = unsigned ? 0 : CONSTANTS.INT48_MIN;
    max = unsigned ? CONSTANTS.INT48_UNSIGNED_MAX : CONSTANTS.INT48_MAX;
  } else if (isColumnType(column, [
    "PgBigInt53",
    "PgBigSerial53",
    "MySqlBigInt53",
    "MySqlSerial",
    "SingleStoreBigInt53",
    "SingleStoreSerial",
    "SQLiteInteger"
  ])) {
    unsigned = unsigned || isColumnType(column, ["MySqlSerial", "SingleStoreSerial"]);
    min = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
    max = Number.MAX_SAFE_INTEGER;
    integer2 = true;
  } else if (isColumnType(column, ["MySqlYear", "SingleStoreYear"])) {
    min = 1901;
    max = 2155;
    integer2 = true;
  } else {
    min = Number.MIN_SAFE_INTEGER;
    max = Number.MAX_SAFE_INTEGER;
  }
  let schema = coerce2 === true || coerce2?.number ? z2.coerce.number() : z2.number();
  schema = schema.min(min).max(max);
  return integer2 ? schema.int() : schema;
}
function bigintColumnToSchema(column, z2, coerce2) {
  const unsigned = column.getSQLType().includes("unsigned");
  const min = unsigned ? 0n : CONSTANTS.INT64_MIN;
  const max = unsigned ? CONSTANTS.INT64_UNSIGNED_MAX : CONSTANTS.INT64_MAX;
  const schema = coerce2 === true || coerce2?.bigint ? z2.coerce.bigint() : z2.bigint();
  return schema.min(min).max(max);
}
function stringColumnToSchema(column, z2, coerce2) {
  if (isColumnType(column, ["PgUUID"])) {
    return z2.string().uuid();
  }
  let max;
  let regex;
  let fixed = false;
  if (isColumnType(column, ["PgVarchar", "SQLiteText"])) {
    max = column.length;
  } else if (isColumnType(column, ["MySqlVarChar", "SingleStoreVarChar"])) {
    max = column.length ?? CONSTANTS.INT16_UNSIGNED_MAX;
  } else if (isColumnType(column, ["MySqlText", "SingleStoreText"])) {
    if (column.textType === "longtext") {
      max = CONSTANTS.INT32_UNSIGNED_MAX;
    } else if (column.textType === "mediumtext") {
      max = CONSTANTS.INT24_UNSIGNED_MAX;
    } else if (column.textType === "text") {
      max = CONSTANTS.INT16_UNSIGNED_MAX;
    } else {
      max = CONSTANTS.INT8_UNSIGNED_MAX;
    }
  }
  if (isColumnType(column, [
    "PgChar",
    "MySqlChar",
    "SingleStoreChar"
  ])) {
    max = column.length;
    fixed = true;
  }
  if (isColumnType(column, ["PgBinaryVector"])) {
    regex = /^[01]+$/;
    max = column.dimensions;
  }
  let schema = coerce2 === true || coerce2?.string ? z2.coerce.string() : z2.string();
  schema = regex ? schema.regex(regex) : schema;
  return max && fixed ? schema.length(max) : max ? schema.max(max) : schema;
}
function getColumns(tableLike) {
  return isTable(tableLike) ? getTableColumns(tableLike) : getViewSelectedFields(tableLike);
}
function handleColumns(columns, refinements, conditions, factory) {
  const columnSchemas = {};
  for (const [key, selected] of Object.entries(columns)) {
    if (!is(selected, Column) && !is(selected, SQL) && !is(selected, SQL.Aliased) && typeof selected === "object") {
      const columns2 = isTable(selected) || isView(selected) ? getColumns(selected) : selected;
      columnSchemas[key] = handleColumns(columns2, refinements[key] ?? {}, conditions, factory);
      continue;
    }
    const refinement = refinements[key];
    if (refinement !== void 0 && typeof refinement !== "function") {
      columnSchemas[key] = refinement;
      continue;
    }
    const column = is(selected, Column) ? selected : void 0;
    const schema = column ? columnToSchema(column, factory) : z.any();
    const refined = typeof refinement === "function" ? refinement(schema) : schema;
    if (conditions.never(column)) {
      continue;
    } else {
      columnSchemas[key] = refined;
    }
    if (column) {
      if (conditions.nullable(column)) {
        columnSchemas[key] = columnSchemas[key].nullable();
      }
      if (conditions.optional(column)) {
        columnSchemas[key] = columnSchemas[key].optional();
      }
    }
  }
  return z.object(columnSchemas);
}
var CONSTANTS, literalSchema, jsonSchema, bufferSchema, insertConditions, createInsertSchema;
var init_drizzle_zod = __esm({
  "../node_modules/drizzle-zod/index.mjs"() {
    init_functionsRoutes_0_8044054200943971();
    init_drizzle_orm();
    init_lib();
    CONSTANTS = {
      INT8_MIN: -128,
      INT8_MAX: 127,
      INT8_UNSIGNED_MAX: 255,
      INT16_MIN: -32768,
      INT16_MAX: 32767,
      INT16_UNSIGNED_MAX: 65535,
      INT24_MIN: -8388608,
      INT24_MAX: 8388607,
      INT24_UNSIGNED_MAX: 16777215,
      INT32_MIN: -2147483648,
      INT32_MAX: 2147483647,
      INT32_UNSIGNED_MAX: 4294967295,
      INT48_MIN: -140737488355328,
      INT48_MAX: 140737488355327,
      INT48_UNSIGNED_MAX: 281474976710655,
      INT64_MIN: -9223372036854775808n,
      INT64_MAX: 9223372036854775807n,
      INT64_UNSIGNED_MAX: 18446744073709551615n
    };
    __name(isColumnType, "isColumnType");
    __name(isWithEnum, "isWithEnum");
    literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);
    jsonSchema = z.union([literalSchema, z.record(z.any()), z.array(z.any())]);
    bufferSchema = z.custom((v) => v instanceof Buffer);
    __name(columnToSchema, "columnToSchema");
    __name(numberColumnToSchema, "numberColumnToSchema");
    __name(bigintColumnToSchema, "bigintColumnToSchema");
    __name(stringColumnToSchema, "stringColumnToSchema");
    __name(getColumns, "getColumns");
    __name(handleColumns, "handleColumns");
    insertConditions = {
      never: /* @__PURE__ */ __name((column) => column?.generated?.type === "always" || column?.generatedIdentity?.type === "always", "never"),
      optional: /* @__PURE__ */ __name((column) => !column.notNull || column.notNull && column.hasDefault, "optional"),
      nullable: /* @__PURE__ */ __name((column) => !column.notNull, "nullable")
    };
    createInsertSchema = /* @__PURE__ */ __name((entity, refine) => {
      const columns = getColumns(entity);
      return handleColumns(columns, refine ?? {}, insertConditions);
    }, "createInsertSchema");
  }
});

// ../shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  activationCodes: () => activationCodes,
  activationKeys: () => activationKeys,
  activationKeysRelations: () => activationKeysRelations,
  affiliatePayouts: () => affiliatePayouts,
  affiliatePrograms: () => affiliatePrograms,
  affiliateSettings: () => affiliateSettings,
  affiliateTransactions: () => affiliateTransactions,
  affiliateTransactionsRelations: () => affiliateTransactionsRelations,
  announcementBadges: () => announcementBadges,
  authSettings: () => authSettings,
  cities: () => cities,
  citiesRelations: () => citiesRelations,
  continents: () => continents,
  continentsRelations: () => continentsRelations,
  countdownBanners: () => countdownBanners,
  countries: () => countries,
  countriesRelations: () => countriesRelations,
  coupons: () => coupons,
  customerPayments: () => customerPayments,
  customerPaymentsRelations: () => customerPaymentsRelations,
  customers: () => customers,
  customersRelations: () => customersRelations,
  dashboardFeatures: () => dashboardFeatures,
  demoUsers: () => demoUsers,
  downloads: () => downloads,
  downloadsRelations: () => downloadsRelations,
  extensionDownloads: () => extensionDownloads,
  extensionInstallations: () => extensionInstallations,
  extensionUsageLogs: () => extensionUsageLogs,
  extensionUsageStats: () => extensionUsageStats,
  extensionUsageStatsRelations: () => extensionUsageStatsRelations,
  globalUsageStats: () => globalUsageStats,
  insertActivationCodeSchema: () => insertActivationCodeSchema,
  insertActivationKeySchema: () => insertActivationKeySchema,
  insertAffiliateTransactionSchema: () => insertAffiliateTransactionSchema,
  insertAnnouncementBadgeSchema: () => insertAnnouncementBadgeSchema,
  insertAuthSettingSchema: () => insertAuthSettingSchema,
  insertCitySchema: () => insertCitySchema,
  insertContinentSchema: () => insertContinentSchema,
  insertCountdownBannerSchema: () => insertCountdownBannerSchema,
  insertCountrySchema: () => insertCountrySchema,
  insertCouponSchema: () => insertCouponSchema,
  insertCustomerPaymentSchema: () => insertCustomerPaymentSchema,
  insertCustomerSchema: () => insertCustomerSchema,
  insertDashboardFeaturesSchema: () => insertDashboardFeaturesSchema,
  insertDemoUserSchema: () => insertDemoUserSchema,
  insertDownloadSchema: () => insertDownloadSchema,
  insertExtensionDownloadSchema: () => insertExtensionDownloadSchema,
  insertExtensionInstallationSchema: () => insertExtensionInstallationSchema,
  insertExtensionUsageLogSchema: () => insertExtensionUsageLogSchema,
  insertExtensionUsageStatsSchema: () => insertExtensionUsageStatsSchema,
  insertGlobalUsageStatsSchema: () => insertGlobalUsageStatsSchema,
  insertMissionSchema: () => insertMissionSchema,
  insertOrderSchema: () => insertOrderSchema,
  insertPremiumDeviceSchema: () => insertPremiumDeviceSchema,
  insertProductSchema: () => insertProductSchema,
  insertSeoSettingsSchema: () => insertSeoSettingsSchema,
  insertSettingSchema: () => insertSettingSchema,
  insertTicketMessageSchema: () => insertTicketMessageSchema,
  insertTicketSchema: () => insertTicketSchema,
  insertUserLocationAssignmentSchema: () => insertUserLocationAssignmentSchema,
  insertUserSchema: () => insertUserSchema,
  insertUserTrialSchema: () => insertUserTrialSchema,
  invoiceItems: () => invoiceItems,
  invoiceSettings: () => invoiceSettings,
  invoices: () => invoices,
  missions: () => missions,
  orders: () => orders,
  ordersRelations: () => ordersRelations,
  premiumDevices: () => premiumDevices,
  products: () => products,
  seoSettings: () => seoSettings,
  settings: () => settings,
  ticketMessages: () => ticketMessages,
  ticketMessagesRelations: () => ticketMessagesRelations,
  tickets: () => tickets,
  ticketsRelations: () => ticketsRelations,
  trialUsage: () => trialUsage,
  userLocationAssignments: () => userLocationAssignments,
  userLocationAssignmentsRelations: () => userLocationAssignmentsRelations,
  userTrials: () => userTrials,
  users: () => users,
  usersRelations: () => usersRelations
});
var users, orders, products, coupons, settings, dashboardFeatures, missions, userTrials, trialUsage, authSettings, downloads, tickets, ticketMessages, activationKeys, demoUsers, customers, affiliateTransactions, extensionUsageStats, customerPayments, globalUsageStats, premiumDevices, seoSettings, usersRelations, ordersRelations, downloadsRelations, activationKeysRelations, ticketsRelations, ticketMessagesRelations, customersRelations, customerPaymentsRelations, extensionUsageStatsRelations, affiliateTransactionsRelations, countdownBanners, announcementBadges, extensionDownloads, extensionUsageLogs, activationCodes, extensionInstallations, insertUserSchema, insertTicketSchema, insertTicketMessageSchema, insertExtensionInstallationSchema, insertActivationCodeSchema, insertOrderSchema, insertProductSchema, insertDownloadSchema, insertCouponSchema, insertSettingSchema, insertSeoSettingsSchema, insertAuthSettingSchema, insertCustomerSchema, insertExtensionDownloadSchema, insertAnnouncementBadgeSchema, insertExtensionUsageLogSchema, insertPremiumDeviceSchema, insertDashboardFeaturesSchema, insertAffiliateTransactionSchema, insertCountdownBannerSchema, insertActivationKeySchema, insertDemoUserSchema, affiliatePrograms, affiliateSettings, affiliatePayouts, invoiceSettings, invoices, invoiceItems, insertMissionSchema, insertUserTrialSchema, insertExtensionUsageStatsSchema, insertCustomerPaymentSchema, insertGlobalUsageStatsSchema, continents, countries, cities, userLocationAssignments, continentsRelations, countriesRelations, citiesRelations, userLocationAssignmentsRelations, insertContinentSchema, insertCountrySchema, insertCitySchema, insertUserLocationAssignmentSchema;
var init_schema = __esm({
  "../shared/schema.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_sqlite_core();
    init_drizzle_zod();
    init_drizzle_orm();
    users = sqliteTable("users", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      username: text("username").notNull().unique(),
      password: text("password").notNull(),
      email: text("email").notNull(),
      isAdmin: integer("is_admin", { mode: "boolean" }).default(false),
      stripeCustomerId: text("stripe_customer_id"),
      isPremium: integer("is_premium", { mode: "boolean" }).default(false),
      extensionActivated: integer("extension_activated", { mode: "boolean" }).default(false),
      premiumActivatedAt: text("premium_activated_at"),
      totalSpent: text("total_spent").default("0"),
      totalOrders: integer("total_orders").default(0),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    orders = sqliteTable("orders", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      userId: integer("user_id").references(() => users.id),
      // Link to authenticated users
      customerEmail: text("customer_email").notNull(),
      customerName: text("customer_name").notNull(),
      originalAmount: text("original_amount").notNull(),
      finalAmount: text("final_amount").notNull(),
      discountAmount: text("discount_amount").default("0"),
      couponCode: text("coupon_code"),
      referralCode: text("referral_code"),
      // Added for affiliate tracking
      currency: text("currency").default("usd"),
      status: text("status").notNull().default("pending"),
      // pending, completed, failed, refunded
      paymentMethod: text("payment_method").notNull(),
      // stripe, paypal
      paymentIntentId: text("payment_intent_id"),
      paypalOrderId: text("paypal_order_id"),
      downloadToken: text("download_token").notNull(),
      downloadCount: integer("download_count").default(0),
      maxDownloads: integer("max_downloads").default(3),
      activationCode: text("activation_code"),
      // Generated activation code for the extension
      invoiceUrl: text("invoice_url"),
      // Path to generated invoice PDF
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`),
      completedAt: integer("completed_at")
    });
    products = sqliteTable("products", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      name: text("name").notNull(),
      description: text("description").notNull(),
      price: text("price").notNull(),
      beforePrice: text("before_price"),
      currency: text("currency").default("eur"),
      fileName: text("file_name").notNull(),
      filePath: text("file_path").notNull(),
      isActive: integer("is_active", { mode: "boolean" }).default(true),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    coupons = sqliteTable("coupons", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      code: text("code").notNull().unique(),
      discountType: text("discount_type").notNull(),
      // "percentage" or "fixed"
      discountValue: text("discount_value").notNull(),
      isActive: integer("is_active", { mode: "boolean" }).default(true),
      usageLimit: integer("usage_limit"),
      // null for unlimited
      usageCount: integer("usage_count").default(0),
      expiresAt: integer("expires_at"),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    settings = sqliteTable("settings", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      key: text("key").notNull().unique(),
      value: text("value").notNull(),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    dashboardFeatures = sqliteTable("dashboard_features", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      featureName: text("feature_name").notNull().unique(),
      isEnabled: integer("is_enabled", { mode: "boolean" }).default(true),
      description: text("description"),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    missions = sqliteTable("missions", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      missionId: text("mission_id").notNull().unique(),
      // OCUS mission ID
      userId: text("user_id").notNull(),
      // Extension user ID
      customerId: integer("customer_id"),
      // References users table if logged in
      missionName: text("mission_name").notNull(),
      compensationAmount: text("compensation_amount"),
      status: text("status").notNull().default("assignment_accepted"),
      // assignment_accepted, appointment_confirmation, media_upload, billing_payment, assignment_complete
      assignmentAcceptedAt: integer("assignment_accepted_at").default(sql`(CURRENT_TIMESTAMP)`),
      appointmentConfirmedAt: integer("appointment_confirmed_at"),
      mediaUploadedAt: integer("media_uploaded_at"),
      billingCompletedAt: integer("billing_completed_at"),
      assignmentCompletedAt: integer("assignment_completed_at"),
      trialUsed: integer("trial_used", { mode: "boolean" }).default(false),
      // Whether this mission used a trial attempt
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    userTrials = sqliteTable("user_trials", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      userId: text("user_id").notNull().unique(),
      // Extension user ID
      customerId: integer("customer_id"),
      // References users table if logged in
      trialsUsed: integer("trials_used").default(0),
      maxTrials: integer("max_trials").default(3),
      isActivated: integer("is_activated", { mode: "boolean" }).default(false),
      activationKey: text("activation_key"),
      activatedAt: integer("activated_at"),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    trialUsage = sqliteTable("trial_usage", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      trialKey: text("trial_key").notNull().unique(),
      // Combination of extensionId + userFingerprint
      extensionId: text("extension_id").notNull(),
      userFingerprint: text("user_fingerprint").notNull(),
      usageCount: integer("usage_count").default(0),
      lastUsed: integer("last_used").default(sql`(CURRENT_TIMESTAMP)`),
      isExpired: integer("is_expired", { mode: "boolean" }).default(false),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    authSettings = sqliteTable("auth_settings", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      // Google OAuth
      googleClientId: text("google_client_id"),
      googleClientSecret: text("google_client_secret"),
      googleRedirectUri: text("google_redirect_uri"),
      googleEnabled: integer("google_enabled", { mode: "boolean" }).default(false),
      // Facebook OAuth
      facebookAppId: text("facebook_app_id"),
      facebookAppSecret: text("facebook_app_secret"),
      facebookEnabled: integer("facebook_enabled", { mode: "boolean" }).default(false),
      // GitHub OAuth
      githubClientId: text("github_client_id"),
      githubClientSecret: text("github_client_secret"),
      githubEnabled: integer("github_enabled", { mode: "boolean" }).default(false),
      // reCAPTCHA settings
      recaptchaSiteKey: text("recaptcha_site_key"),
      recaptchaSecretKey: text("recaptcha_secret_key"),
      recaptchaEnabled: integer("recaptcha_enabled", { mode: "boolean" }).default(false),
      recaptchaMode: text("recaptcha_mode").default("v2"),
      // v2 or v3
      recaptchaCustomerEnabled: integer("recaptcha_customer_enabled", { mode: "boolean" }).default(false),
      recaptchaAdminEnabled: integer("recaptcha_admin_enabled", { mode: "boolean" }).default(true),
      // Payment Gateway Settings
      stripePublicKey: text("stripe_public_key"),
      stripeSecretKey: text("stripe_secret_key"),
      stripeEnabled: integer("stripe_enabled", { mode: "boolean" }).default(false),
      paypalClientId: text("paypal_client_id"),
      paypalClientSecret: text("paypal_client_secret"),
      paypalEnabled: integer("paypal_enabled", { mode: "boolean" }).default(false),
      defaultPaymentMethod: text("default_payment_method").default("stripe"),
      // stripe or paypal
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    downloads = sqliteTable("downloads", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      orderId: integer("order_id").references(() => orders.id).notNull(),
      downloadedAt: integer("downloaded_at").default(sql`(CURRENT_TIMESTAMP)`),
      ipAddress: text("ip_address"),
      userAgent: text("user_agent")
    });
    tickets = sqliteTable("tickets", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      title: text("title").notNull(),
      description: text("description").notNull(),
      category: text("category").notNull(),
      // "technical", "billing", "feature-request", "bug-report", "general"
      priority: text("priority").notNull().default("medium"),
      // "low", "medium", "high", "urgent"
      status: text("status").notNull().default("open"),
      // "open", "in-progress", "resolved", "closed"
      customerEmail: text("customer_email").notNull(),
      customerName: text("customer_name").notNull(),
      assignedToUserId: integer("assigned_to_user_id").references(() => users.id),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`),
      resolvedAt: integer("resolved_at")
    });
    ticketMessages = sqliteTable("ticket_messages", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      ticketId: integer("ticket_id").references(() => tickets.id).notNull(),
      message: text("message").notNull(),
      isFromCustomer: integer("is_from_customer", { mode: "boolean" }).notNull().default(true),
      senderName: text("sender_name").notNull(),
      senderEmail: text("sender_email"),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    activationKeys = sqliteTable("activation_keys", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      activationKey: text("activation_key").notNull().unique(),
      isActive: integer("is_active", { mode: "boolean" }).default(true),
      orderId: integer("order_id").references(() => orders.id),
      userId: integer("user_id").references(() => users.id),
      // Link to authenticated user
      installationId: text("installation_id", { length: 36 }),
      // Bind to specific installation
      usedAt: integer("used_at"),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    demoUsers = sqliteTable("demo_users", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      userId: text("user_id").notNull().unique(),
      // UUID from extension
      demoCount: integer("demo_count").default(0),
      maxDemoUses: integer("max_demo_uses").default(3),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`),
      lastUsedAt: integer("last_used_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    customers = sqliteTable("customers", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      email: text("email", { length: 255 }).notNull().unique(),
      password: text("password", { length: 255 }),
      // Optional for social logins
      name: text("name", { length: 255 }).notNull(),
      // Extension activation and usage
      activationKey: text("activation_key", { length: 100 }).unique(),
      activationKeyRevealed: integer("activation_key_revealed", { mode: "boolean" }).default(false).notNull(),
      activationKeyGeneratedAt: integer("activation_key_generated_at").default(sql`(CURRENT_TIMESTAMP)`),
      isActivated: integer("is_activated", { mode: "boolean" }).default(false).notNull(),
      extensionActivated: integer("extension_activated", { mode: "boolean" }).default(false).notNull(),
      extensionLastUsed: integer("extension_last_used"),
      extensionUsageCount: integer("extension_usage_count").default(0).notNull(),
      extensionSuccessfulJobs: integer("extension_successful_jobs").default(0).notNull(),
      extensionTrialJobsUsed: integer("extension_trial_jobs_used").default(0).notNull(),
      extensionTrialLimit: integer("extension_trial_limit").default(3).notNull(),
      isBlocked: integer("is_blocked", { mode: "boolean" }).default(false).notNull(),
      blockedReason: text("blocked_reason"),
      blockedAt: integer("blocked_at"),
      // Account status
      isAdmin: integer("is_admin", { mode: "boolean" }).default(false).notNull(),
      subscriptionStatus: text("subscription_status", { length: 20 }).default("inactive").notNull(),
      // inactive, active, cancelled, expired
      subscriptionExpiresAt: integer("subscription_expires_at"),
      // Payment integration
      stripeCustomerId: text("stripe_customer_id", { length: 255 }),
      stripeSubscriptionId: text("stripe_subscription_id", { length: 255 }),
      paypalCustomerId: text("paypal_customer_id", { length: 255 }),
      totalSpent: text("total_spent").default("0").notNull(),
      totalOrders: integer("total_orders").default(0).notNull(),
      lastOrderDate: integer("last_order_date"),
      // Social login fields
      googleId: text("google_id", { length: 255 }),
      facebookId: text("facebook_id", { length: 255 }),
      githubId: text("github_id", { length: 255 }),
      avatar: text("avatar", { length: 500 }),
      // Affiliate program
      referralCode: text("referral_code", { length: 20 }).unique(),
      referredBy: text("referred_by", { length: 255 }),
      totalEarnings: text("total_earnings").default("0"),
      commissionRate: text("commission_rate").default("10.00"),
      // 10% default
      // Profile
      phone: text("phone", { length: 50 }),
      address: text("address"),
      dateOfBirth: text("date_of_birth", { length: 10 }),
      preferredLanguage: text("preferred_language", { length: 10 }).default("en").notNull(),
      marketingOptIn: integer("marketing_opt_in", { mode: "boolean" }).default(false).notNull(),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    affiliateTransactions = sqliteTable("affiliate_transactions", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      affiliateId: integer("affiliate_id").notNull().references(() => customers.id),
      orderId: integer("order_id").notNull().references(() => orders.id),
      commission: text("commission").notNull(),
      status: text("status", { length: 20 }).default("pending").notNull(),
      // pending, paid, cancelled
      paidAt: integer("paid_at"),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    extensionUsageStats = sqliteTable("extension_usage_stats", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      customerId: integer("customer_id").notNull().references(() => customers.id),
      sessionId: text("session_id", { length: 100 }).notNull(),
      usageDate: integer("usage_date").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      jobsFound: integer("jobs_found").default(0).notNull(),
      jobsApplied: integer("jobs_applied").default(0).notNull(),
      successfulJobs: integer("successful_jobs").default(0).notNull(),
      sessionDuration: integer("session_duration_minutes").default(0).notNull(),
      // in minutes
      platform: text("platform", { length: 50 }).default("ocus").notNull(),
      // ocus, ubereats, foodora
      location: text("location", { length: 100 }),
      userAgent: text("user_agent"),
      extensionVersion: text("extension_version", { length: 20 }),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    customerPayments = sqliteTable("customer_payments", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      customerId: integer("customer_id").notNull().references(() => customers.id),
      orderId: integer("order_id").notNull().references(() => orders.id),
      paymentMethod: text("payment_method", { length: 20 }).notNull(),
      // stripe, paypal
      paymentIntentId: text("payment_intent_id", { length: 255 }),
      paypalOrderId: text("paypal_order_id", { length: 255 }),
      amount: text("amount").notNull(),
      currency: text("currency", { length: 3 }).default("usd").notNull(),
      status: text("status", { length: 20 }).default("pending").notNull(),
      // pending, completed, failed, refunded
      failureReason: text("failure_reason"),
      refundAmount: text("refund_amount").default("0"),
      refundReason: text("refund_reason"),
      processedAt: integer("processed_at"),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    globalUsageStats = sqliteTable("global_usage_stats", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      statDate: text("stat_date", { length: 10 }).notNull(),
      // YYYY-MM-DD format
      totalUsers: integer("total_users").default(0).notNull(),
      activeUsers: integer("active_users").default(0).notNull(),
      totalSessions: integer("total_sessions").default(0).notNull(),
      totalJobsFound: integer("total_jobs_found").default(0).notNull(),
      totalJobsApplied: integer("total_jobs_applied").default(0).notNull(),
      totalSuccessfulJobs: integer("total_successful_jobs").default(0).notNull(),
      avgSessionDuration: text("avg_session_duration").default("0").notNull(),
      topPlatform: text("top_platform", { length: 50 }),
      topLocation: text("top_location", { length: 100 }),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    premiumDevices = sqliteTable("premium_devices", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      userId: text("user_id", { length: 100 }).notNull(),
      // Extension user ID
      deviceFingerprint: text("device_fingerprint", { length: 64 }).notNull().unique(),
      extensionId: text("extension_id", { length: 100 }).notNull(),
      isActive: integer("is_active", { mode: "boolean" }).default(true).notNull(),
      registeredAt: integer("registered_at").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      lastSeenAt: integer("last_seen_at").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      deactivatedAt: integer("deactivated_at"),
      deactivationReason: text("deactivation_reason")
    });
    seoSettings = sqliteTable("seo_settings", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      siteTitle: text("site_title", { length: 100 }).default("OCUS Job Hunter - Premium Chrome Extension").notNull(),
      siteDescription: text("site_description").default("Boost your photography career with OCUS Job Hunter Chrome Extension. Automated mission detection, smart acceptance, and unlimited job opportunities for OCUS photographers.").notNull(),
      siteKeywords: text("site_keywords").default("OCUS extension, photography jobs, Chrome extension, job hunter, photographer tools, mission automation"),
      siteAuthor: text("site_author", { length: 100 }).default("OCUS Job Hunter"),
      // Open Graph settings
      ogTitle: text("og_title", { length: 100 }),
      ogDescription: text("og_description"),
      ogImage: text("og_image").default("/og-image.svg"),
      // URL or path to image
      ogImageAlt: text("og_image_alt", { length: 200 }),
      ogSiteName: text("og_site_name", { length: 100 }).default("OCUS Job Hunter"),
      ogType: text("og_type", { length: 50 }).default("website"),
      ogUrl: text("og_url", { length: 255 }).default("https://jobhunter.one/"),
      // Twitter Card settings  
      twitterCard: text("twitter_card", { length: 50 }).default("summary_large_image"),
      twitterTitle: text("twitter_title", { length: 100 }),
      twitterDescription: text("twitter_description"),
      twitterImage: text("twitter_image").default("/og-image.svg"),
      twitterSite: text("twitter_site", { length: 50 }),
      twitterCreator: text("twitter_creator", { length: 50 }),
      // Additional SEO settings
      metaRobots: text("meta_robots", { length: 100 }).default("index, follow"),
      canonicalUrl: text("canonical_url", { length: 255 }),
      themeColor: text("theme_color", { length: 7 }).default("#2563eb"),
      // Custom image uploads
      customLogo: text("custom_logo"),
      // Base64 or URL
      customFavicon: text("custom_favicon"),
      // Base64 or URL
      customOgImage: text("custom_og_image"),
      // Base64 or URL
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    usersRelations = relations(users, ({ many }) => ({
      orders: many(orders)
    }));
    ordersRelations = relations(orders, ({ many, one }) => ({
      downloads: many(downloads),
      invoice: one(invoices, {
        fields: [orders.id],
        references: [invoices.orderId]
      }),
      user: one(users, {
        fields: [orders.userId],
        references: [users.id]
      })
    }));
    downloadsRelations = relations(downloads, ({ one }) => ({
      order: one(orders, {
        fields: [downloads.orderId],
        references: [orders.id]
      })
    }));
    activationKeysRelations = relations(activationKeys, ({ one }) => ({
      order: one(orders, {
        fields: [activationKeys.orderId],
        references: [orders.id]
      })
    }));
    ticketsRelations = relations(tickets, ({ many, one }) => ({
      messages: many(ticketMessages),
      assignedTo: one(users, {
        fields: [tickets.assignedToUserId],
        references: [users.id]
      })
    }));
    ticketMessagesRelations = relations(ticketMessages, ({ one }) => ({
      ticket: one(tickets, {
        fields: [ticketMessages.ticketId],
        references: [tickets.id]
      })
    }));
    customersRelations = relations(customers, ({ many }) => ({
      payments: many(customerPayments),
      usageStats: many(extensionUsageStats),
      affiliateTransactions: many(affiliateTransactions)
    }));
    customerPaymentsRelations = relations(customerPayments, ({ one }) => ({
      customer: one(customers, {
        fields: [customerPayments.customerId],
        references: [customers.id]
      }),
      order: one(orders, {
        fields: [customerPayments.orderId],
        references: [orders.id]
      })
    }));
    extensionUsageStatsRelations = relations(extensionUsageStats, ({ one }) => ({
      customer: one(customers, {
        fields: [extensionUsageStats.customerId],
        references: [customers.id]
      })
    }));
    affiliateTransactionsRelations = relations(affiliateTransactions, ({ one }) => ({
      affiliate: one(customers, {
        fields: [affiliateTransactions.affiliateId],
        references: [customers.id]
      }),
      order: one(orders, {
        fields: [affiliateTransactions.orderId],
        references: [orders.id]
      })
    }));
    countdownBanners = sqliteTable("countdown_banners", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      isEnabled: integer("is_enabled", { mode: "boolean" }).default(false),
      titleEn: text("title_en").notNull(),
      subtitleEn: text("subtitle_en").notNull(),
      titleTranslations: text("title_translations").default("{}"),
      subtitleTranslations: text("subtitle_translations").default("{}"),
      targetPrice: text("target_price").notNull(),
      originalPrice: text("original_price"),
      endDateTime: integer("end_date_time").notNull(),
      backgroundColor: text("background_color", { length: 20 }).default("gradient-primary"),
      textColor: text("text_color", { length: 20 }).default("white"),
      priority: integer("priority").default(1),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    announcementBadges = sqliteTable("announcement_badges", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      isEnabled: integer("is_enabled", { mode: "boolean" }).default(true),
      textEn: text("text_en").notNull(),
      textTranslations: text("text_translations").default("{}"),
      backgroundColor: text("background_color", { length: 20 }).default("gradient-primary"),
      textColor: text("text_color", { length: 20 }).default("white"),
      priority: integer("priority").default(1),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`)
    });
    extensionDownloads = sqliteTable("extension_downloads", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      customerId: integer("customer_id").notNull().references(() => customers.id),
      downloadToken: text("download_token", { length: 255 }).notNull().unique(),
      downloadType: text("download_type", { length: 50 }).default("premium").notNull(),
      // premium, trial, etc.
      downloadedAt: integer("downloaded_at").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      ipAddress: text("ip_address", { length: 45 }),
      userAgent: text("user_agent"),
      downloadCount: integer("download_count").default(1).notNull(),
      maxDownloads: integer("max_downloads").default(3).notNull(),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    extensionUsageLogs = sqliteTable("extension_usage_logs", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      customerId: integer("customer_id").notNull().references(() => customers.id),
      sessionId: text("session_id", { length: 100 }).notNull(),
      jobsUsed: integer("jobs_used").default(1).notNull(),
      platform: text("platform", { length: 50 }).default("ocus").notNull(),
      location: text("location", { length: 100 }),
      usageDate: integer("usage_date").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      extensionVersion: text("extension_version", { length: 20 }),
      ipAddress: text("ip_address"),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    activationCodes = sqliteTable("activation_codes", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      code: text("code", { length: 50 }).notNull().unique(),
      customerId: integer("customer_id").references(() => customers.id),
      orderId: integer("order_id").references(() => orders.id),
      userId: integer("user_id").references(() => users.id),
      // Link to authenticated user
      installationId: text("installation_id", { length: 36 }),
      // Unique installation identifier
      versionToken: text("version_token", { length: 36 }).unique(),
      activatedAt: integer("activated_at"),
      activationCount: integer("activation_count").default(0).notNull(),
      maxActivations: integer("max_activations").default(1).notNull(),
      deviceId: text("device_id", { length: 100 }),
      ipAddress: text("ip_address"),
      isActive: integer("is_active", { mode: "boolean" }).default(true).notNull(),
      dailyValidationCount: integer("daily_validation_count").default(0).notNull(),
      // Daily rate limiting
      lastValidationDate: integer("last_validation_date"),
      // Track daily reset
      isRevoked: integer("is_revoked", { mode: "boolean" }).default(false).notNull(),
      // Manual revocation flag
      expiresAt: integer("expires_at"),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    extensionInstallations = sqliteTable("extension_installations", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      installationId: text("installation_id", { length: 36 }).notNull().unique(),
      userId: integer("user_id").references(() => users.id),
      // Link to authenticated user if logged in
      customerId: integer("customer_id").references(() => customers.id),
      // Fixed to integer
      deviceFingerprint: text("device_fingerprint"),
      userAgent: text("user_agent"),
      ipAddress: text("ip_address"),
      extensionVersion: text("extension_version", { length: 20 }),
      isActive: integer("is_active", { mode: "boolean" }).default(true).notNull(),
      lastSeenAt: integer("last_seen_at").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    insertUserSchema = createInsertSchema(users).pick({
      username: true,
      password: true,
      email: true
    });
    insertTicketSchema = createInsertSchema(tickets).pick({
      title: true,
      description: true,
      category: true,
      priority: true,
      customerEmail: true,
      customerName: true
    });
    insertTicketMessageSchema = createInsertSchema(ticketMessages).pick({
      ticketId: true,
      message: true,
      isFromCustomer: true,
      senderName: true,
      senderEmail: true
    });
    insertExtensionInstallationSchema = createInsertSchema(extensionInstallations).omit({
      id: true,
      createdAt: true,
      lastSeenAt: true
    });
    insertActivationCodeSchema = createInsertSchema(activationCodes).omit({
      id: true,
      createdAt: true,
      activatedAt: true,
      activationCount: true,
      dailyValidationCount: true,
      lastValidationDate: true
    });
    insertOrderSchema = createInsertSchema(orders).omit({
      id: true,
      createdAt: true,
      completedAt: true,
      downloadToken: true,
      downloadCount: true
    });
    insertProductSchema = createInsertSchema(products).omit({
      id: true,
      createdAt: true
    });
    insertDownloadSchema = createInsertSchema(downloads).omit({
      id: true,
      downloadedAt: true
    });
    insertCouponSchema = createInsertSchema(coupons).omit({
      id: true,
      createdAt: true,
      usageCount: true
    });
    insertSettingSchema = createInsertSchema(settings).omit({
      id: true,
      updatedAt: true
    });
    insertSeoSettingsSchema = createInsertSchema(seoSettings).omit({
      id: true,
      updatedAt: true
    });
    insertAuthSettingSchema = createInsertSchema(authSettings).omit({
      id: true,
      updatedAt: true
    });
    insertCustomerSchema = createInsertSchema(customers).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertExtensionDownloadSchema = createInsertSchema(extensionDownloads).omit({
      id: true,
      createdAt: true,
      downloadedAt: true
    });
    insertAnnouncementBadgeSchema = createInsertSchema(announcementBadges).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertExtensionUsageLogSchema = createInsertSchema(extensionUsageLogs).omit({
      id: true,
      createdAt: true
    });
    insertPremiumDeviceSchema = createInsertSchema(premiumDevices).omit({
      id: true,
      registeredAt: true,
      lastSeenAt: true
    });
    insertDashboardFeaturesSchema = createInsertSchema(dashboardFeatures).omit({
      id: true,
      updatedAt: true
    });
    insertAffiliateTransactionSchema = createInsertSchema(affiliateTransactions).omit({
      id: true,
      createdAt: true
    });
    insertCountdownBannerSchema = createInsertSchema(countdownBanners).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertActivationKeySchema = createInsertSchema(activationKeys).omit({
      id: true,
      createdAt: true
    });
    insertDemoUserSchema = createInsertSchema(demoUsers).omit({
      id: true,
      createdAt: true,
      lastUsedAt: true
    });
    affiliatePrograms = sqliteTable("affiliate_programs", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      name: text("name", { length: 100 }).notNull(),
      rewardType: text("reward_type", { length: 20 }).default("percentage").notNull(),
      // percentage, fixed
      commissionRate: text("commission_rate"),
      // for percentage
      fixedAmount: text("fixed_amount"),
      // for fixed amount
      minPayout: text("min_payout").default("50.00"),
      cookieLifetime: integer("cookie_lifetime").default(30),
      // days
      autoApproval: integer("auto_approval", { mode: "boolean" }).default(false),
      isActive: integer("is_active", { mode: "boolean" }).default(true),
      description: text("description"),
      termsAndConditions: text("terms_and_conditions"),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    affiliateSettings = sqliteTable("affiliate_settings", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      defaultRewardType: text("default_reward_type", { length: 20 }).default("percentage").notNull(),
      defaultCommissionRate: text("default_commission_rate").default("10.00"),
      defaultFixedAmount: text("default_fixed_amount").default("5.00"),
      minPayoutAmount: text("min_payout_amount").default("50.00"),
      cookieLifetimeDays: integer("cookie_lifetime_days").default(30),
      autoApprovalEnabled: integer("auto_approval_enabled", { mode: "boolean" }).default(false),
      autoApprovalThreshold: text("auto_approval_threshold").default("100.00"),
      payoutFrequency: text("payout_frequency", { length: 20 }).default("monthly"),
      // weekly, monthly, quarterly
      isActive: integer("is_active", { mode: "boolean" }).default(true),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    affiliatePayouts = sqliteTable("affiliate_payouts", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      affiliateId: integer("affiliate_id").notNull().references(() => customers.id),
      amount: text("amount").notNull(),
      paymentMethod: text("payment_method", { length: 20 }).notNull(),
      // paypal, bank, manual
      paymentEmail: text("payment_email", { length: 255 }),
      bankDetails: text("bank_details"),
      status: text("status", { length: 20 }).default("pending").notNull(),
      // pending, processing, paid, failed
      transactionId: text("transaction_id", { length: 255 }),
      notes: text("notes"),
      requestedAt: integer("requested_at").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      processedAt: integer("processed_at"),
      paidAt: integer("paid_at"),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    invoiceSettings = sqliteTable("invoice_settings", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      companyName: text("company_name", { length: 255 }).default("OCUS Job Hunter").notNull(),
      companyLogo: text("company_logo"),
      // Base64 or URL
      companyAddress: text("company_address"),
      companyPhone: text("company_phone", { length: 50 }),
      companyEmail: text("company_email", { length: 255 }),
      companyWebsite: text("company_website", { length: 255 }),
      taxNumber: text("tax_number", { length: 100 }),
      invoicePrefix: text("invoice_prefix", { length: 10 }).default("INV").notNull(),
      receiptPrefix: text("receipt_prefix", { length: 10 }).default("RCP").notNull(),
      invoiceNotes: text("invoice_notes"),
      termsAndConditions: text("terms_and_conditions"),
      footerText: text("footer_text"),
      primaryColor: text("primary_color", { length: 7 }).default("#007bff"),
      secondaryColor: text("secondary_color", { length: 7 }).default("#6c757d"),
      isActive: integer("is_active", { mode: "boolean" }).default(true),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    invoices = sqliteTable("invoices", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      invoiceNumber: text("invoice_number", { length: 50 }).notNull().unique(),
      orderId: integer("order_id").references(() => orders.id),
      customerId: integer("customer_id").references(() => customers.id),
      customerName: text("customer_name", { length: 255 }).notNull(),
      customerEmail: text("customer_email", { length: 255 }).notNull(),
      customerAddress: text("customer_address"),
      billingAddress: text("billing_address"),
      invoiceDate: integer("invoice_date").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      dueDate: integer("due_date").notNull(),
      subtotal: text("subtotal").notNull(),
      taxAmount: text("tax_amount").default("0.00"),
      discountAmount: text("discount_amount").default("0.00"),
      totalAmount: text("total_amount").notNull(),
      currency: text("currency", { length: 3 }).default("USD").notNull(),
      status: text("status", { length: 20 }).default("issued").notNull(),
      // issued, paid, overdue, cancelled
      paidAt: integer("paid_at"),
      notes: text("notes"),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
      updatedAt: integer("updated_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    invoiceItems = sqliteTable("invoice_items", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      invoiceId: integer("invoice_id").references(() => invoices.id).notNull(),
      productName: text("product_name", { length: 255 }).notNull(),
      description: text("description"),
      quantity: integer("quantity").default(1).notNull(),
      unitPrice: text("unit_price").notNull(),
      totalPrice: text("total_price").notNull(),
      createdAt: integer("created_at").default(sql`(CURRENT_TIMESTAMP)`).notNull()
    });
    insertMissionSchema = createInsertSchema(missions).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUserTrialSchema = createInsertSchema(userTrials).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertExtensionUsageStatsSchema = createInsertSchema(extensionUsageStats).omit({
      id: true,
      createdAt: true
    });
    insertCustomerPaymentSchema = createInsertSchema(customerPayments).omit({
      id: true,
      createdAt: true
    });
    insertGlobalUsageStatsSchema = createInsertSchema(globalUsageStats).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    continents = sqliteTable("continents", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      name: text("name", { length: 100 }).notNull().unique(),
      code: text("code", { length: 2 }).notNull().unique(),
      createdAt: integer("created_at").notNull().default(sql`(CURRENT_TIMESTAMP)`)
    });
    countries = sqliteTable("countries", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      name: text("name", { length: 100 }).notNull(),
      code: text("code", { length: 2 }).notNull().unique(),
      continentId: integer("continent_id").references(() => continents.id).notNull(),
      createdAt: integer("created_at").notNull().default(sql`(CURRENT_TIMESTAMP)`)
    });
    cities = sqliteTable("cities", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      name: text("name", { length: 100 }).notNull(),
      countryId: integer("country_id").references(() => countries.id).notNull(),
      isAvailable: integer("is_available", { mode: "boolean" }).notNull().default(true),
      assignedUserId: integer("assigned_user_id").references(() => customers.id),
      assignedAt: integer("assigned_at"),
      createdAt: integer("created_at").notNull().default(sql`(CURRENT_TIMESTAMP)`)
    });
    userLocationAssignments = sqliteTable("user_location_assignments", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      userId: integer("user_id").references(() => customers.id).notNull().unique(),
      continentId: integer("continent_id").references(() => continents.id).notNull(),
      countryId: integer("country_id").references(() => countries.id).notNull(),
      cityId: integer("city_id").references(() => cities.id).notNull(),
      assignedAt: integer("assigned_at").notNull().default(sql`(CURRENT_TIMESTAMP)`),
      assignedBy: integer("assigned_by").references(() => customers.id),
      // null for self-assignment, admin user id for admin assignment
      isLocked: integer("is_locked", { mode: "boolean" }).notNull().default(true)
    });
    continentsRelations = relations(continents, ({ many }) => ({
      countries: many(countries)
    }));
    countriesRelations = relations(countries, ({ one, many }) => ({
      continent: one(continents, {
        fields: [countries.continentId],
        references: [continents.id]
      }),
      cities: many(cities)
    }));
    citiesRelations = relations(cities, ({ one }) => ({
      country: one(countries, {
        fields: [cities.countryId],
        references: [countries.id]
      }),
      assignedUser: one(customers, {
        fields: [cities.assignedUserId],
        references: [customers.id]
      })
    }));
    userLocationAssignmentsRelations = relations(userLocationAssignments, ({ one }) => ({
      user: one(customers, {
        fields: [userLocationAssignments.userId],
        references: [customers.id]
      }),
      continent: one(continents, {
        fields: [userLocationAssignments.continentId],
        references: [continents.id]
      }),
      country: one(countries, {
        fields: [userLocationAssignments.countryId],
        references: [countries.id]
      }),
      city: one(cities, {
        fields: [userLocationAssignments.cityId],
        references: [cities.id]
      }),
      assignedBy: one(customers, {
        fields: [userLocationAssignments.assignedBy],
        references: [customers.id]
      })
    }));
    insertContinentSchema = createInsertSchema(continents);
    insertCountrySchema = createInsertSchema(countries);
    insertCitySchema = createInsertSchema(cities);
    insertUserLocationAssignmentSchema = createInsertSchema(userLocationAssignments);
  }
});

// ../server/storage.ts
var DatabaseStorage, storage;
var init_storage = __esm({
  "../server/storage.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_schema();
    init_drizzle_orm();
    DatabaseStorage = class {
      static {
        __name(this, "DatabaseStorage");
      }
      db;
      constructor(db) {
        this.db = db;
      }
      // Users
      async getUser(id) {
        const [user] = await this.db.select().from(users).where(eq(users.id, id));
        return user || void 0;
      }
      async getUserByUsername(username) {
        const [user] = await this.db.select().from(users).where(eq(users.username, username));
        return user || void 0;
      }
      async getUserByEmail(email) {
        const [user] = await this.db.select().from(users).where(eq(users.email, email));
        return user || void 0;
      }
      async createCustomer(customerData) {
        const now = (/* @__PURE__ */ new Date()).getTime();
        const [customer] = await this.db.insert(customers).values({ ...customerData, createdAt: now, updatedAt: now }).returning();
        return customer;
      }
      async updateUser(id, updates) {
        const [user] = await this.db.update(users).set(updates).where(eq(users.id, id)).returning();
        if (!user) {
          throw new Error(`User with id ${id} not found`);
        }
        return user;
      }
      async updateAuthSettings(updates) {
        const existing = await this.getAuthSettings();
        if (existing) {
          const [updated] = await this.db.update(authSettings).set({ ...updates, updatedAt: (/* @__PURE__ */ new Date()).getTime() }).where(eq(authSettings.id, existing.id)).returning();
          return updated;
        } else {
          return await this.createAuthSettings(updates);
        }
      }
      async updateSeoSettings(updates) {
        const existing = await this.getSeoSettings();
        if (existing) {
          const [updated] = await this.db.update(seoSettings).set({ ...updates, updatedAt: (/* @__PURE__ */ new Date()).getTime() }).where(eq(seoSettings.id, existing.id)).returning();
          return updated;
        } else {
          const [created] = await this.db.insert(seoSettings).values(updates).returning();
          return created;
        }
      }
      async getCustomerByEmail(email) {
        const [customer] = await this.db.select().from(customers).where(eq(customers.email, email));
        return customer;
      }
      async createActivationKey(insertActivationKey) {
        const [activationKey] = await this.db.insert(activationKeys).values(insertActivationKey).returning();
        return activationKey;
      }
      async updateTicket(id, updateData) {
        const [updatedTicket] = await this.db.update(tickets).set({ ...updateData, updatedAt: (/* @__PURE__ */ new Date()).getTime() }).where(eq(tickets.id, id)).returning();
        return updatedTicket;
      }
      async addTicketMessage(message) {
        const [newMessage] = await this.db.insert(ticketMessages).values({ ...message, createdAt: (/* @__PURE__ */ new Date()).getTime() }).returning();
        return newMessage;
      }
      async recordExtensionUsage(stats) {
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const existingStats = await this.db.select().from(extensionUsageStats).where(and(eq(extensionUsageStats.customerId, stats.customerId), eq(extensionUsageStats.usageDate, today.getTime()))).limit(1);
        if (existingStats.length > 0) {
          const [updatedStats] = await this.db.update(extensionUsageStats).set({
            ...stats,
            updatedAt: (/* @__PURE__ */ new Date()).getTime()
          }).where(eq(extensionUsageStats.id, existingStats[0].id)).returning();
          return updatedStats;
        } else {
          const [newStats] = await this.db.insert(extensionUsageStats).values({
            ...stats,
            usageDate: today.getTime(),
            createdAt: (/* @__PURE__ */ new Date()).getTime(),
            updatedAt: (/* @__PURE__ */ new Date()).getTime()
          }).returning();
          return newStats;
        }
      }
      async getCustomerUsageStats(customerId) {
        const thirtyDaysAgo = /* @__PURE__ */ new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        return await this.db.select().from(extensionUsageStats).where(and(eq(extensionUsageStats.customerId, parseInt(customerId)), gte(extensionUsageStats.usageDate, thirtyDaysAgo.getTime()))).orderBy(asc(extensionUsageStats.usageDate));
      }
      async getGlobalUsageStats() {
        const thirtyDaysAgo = /* @__PURE__ */ new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        return await this.db.select().from(globalUsageStats).where(gte(globalUsageStats.statDate, thirtyDaysAgo.getTime())).orderBy(asc(globalUsageStats.statDate));
      }
      async updateGlobalStats(date) {
        const statDate = new Date(date).getTime();
        const [existingStats] = await this.db.select().from(globalUsageStats).where(eq(globalUsageStats.statDate, date));
        const todayStart = (/* @__PURE__ */ new Date(date + "T00:00:00Z")).getTime();
        const todayEnd = (/* @__PURE__ */ new Date(date + "T23:59:59Z")).getTime();
        const totalUsers = await this.db.select({ count: count() }).from(customers).where(eq(customers.isActivated, true));
        const activeUsers = await this.db.select({ count: count() }).from(extensionUsageStats).where(and(
          gte(extensionUsageStats.usageDate, todayStart),
          lte(extensionUsageStats.usageDate, todayEnd)
        ));
        const dailyStats = await this.db.select({
          totalSessions: count(),
          totalJobsFound: sql`COALESCE(SUM(${extensionUsageStats.jobsFound}), 0)`,
          totalJobsApplied: sql`COALESCE(SUM(${extensionUsageStats.jobsApplied}), 0)`,
          totalSuccessfulJobs: sql`COALESCE(SUM(${extensionUsageStats.successfulJobs}), 0)`,
          avgSessionDuration: sql`COALESCE(AVG(${extensionUsageStats.sessionDuration}), 0)`
        }).from(extensionUsageStats).where(and(
          gte(extensionUsageStats.usageDate, todayStart),
          lte(extensionUsageStats.usageDate, todayEnd)
        ));
        const statsData = {
          statDate: date,
          totalUsers: totalUsers[0]?.count || 0,
          activeUsers: activeUsers[0]?.count || 0,
          totalSessions: dailyStats[0]?.totalSessions || 0,
          totalJobsFound: Number(dailyStats[0]?.totalJobsFound) || 0,
          totalJobsApplied: Number(dailyStats[0]?.totalJobsApplied) || 0,
          totalSuccessfulJobs: Number(dailyStats[0]?.totalSuccessfulJobs) || 0,
          avgSessionDuration: dailyStats[0]?.avgSessionDuration?.toString() || "0",
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        };
        if (existingStats) {
          await this.db.update(globalUsageStats).set(statsData).where(eq(globalUsageStats.id, existingStats.id));
        } else {
          await this.db.insert(globalUsageStats).values(statsData);
        }
      }
      // Customer Payments
      async recordPayment(payment) {
        const [newPayment] = await this.db.insert(customerPayments).values(payment).returning();
        if (payment.status === "completed") {
          await this.db.update(customers).set({
            totalSpent: sql`${customers.totalSpent} + ${payment.amount}`,
            totalOrders: sql`${customers.totalOrders} + 1`,
            lastOrderDate: (/* @__PURE__ */ new Date()).getTime(),
            updatedAt: (/* @__PURE__ */ new Date()).getTime()
          }).where(eq(customers.id, payment.customerId));
        }
        return newPayment;
      }
      async getCustomerPayments(customerId) {
        return await this.db.select().from(customerPayments).where(eq(customerPayments.customerId, customerId)).orderBy(desc(customerPayments.createdAt));
      }
      async updatePaymentStatus(paymentId, status, processedAt) {
        const [updatedPayment] = await this.db.update(customerPayments).set({
          status,
          processedAt: (processedAt || /* @__PURE__ */ new Date()).getTime()
        }).where(eq(customerPayments.id, paymentId)).returning();
        return updatedPayment;
      }
      // Database Ticket Operations (Real Implementation)
      async createTicketDB(ticket) {
        const [newTicket] = await this.db.insert(tickets).values(ticket).returning();
        return newTicket;
      }
      async getTicketDB(id) {
        const [ticket] = await this.db.select().from(tickets).where(eq(tickets.id, id));
        return ticket;
      }
      async getCustomerTickets(customerEmail) {
        return await this.db.select().from(tickets).where(eq(tickets.customerEmail, customerEmail)).orderBy(desc(tickets.createdAt));
      }
      async getAllTicketsDB() {
        return await this.db.select().from(tickets).orderBy(desc(tickets.createdAt));
      }
      async updateTicketStatusDB(id, status) {
        const updateData = {
          status,
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        };
        if (status === "resolved" || status === "closed") {
          updateData.resolvedAt = (/* @__PURE__ */ new Date()).getTime();
        }
        const [updatedTicket] = await this.db.update(tickets).set(updateData).where(eq(tickets.id, id)).returning();
        return updatedTicket;
      }
      async deleteTicketDB(id) {
        await this.db.delete(ticketMessages).where(eq(ticketMessages.ticketId, id));
        await this.db.delete(tickets).where(eq(tickets.id, id));
      }
      async addTicketMessageDB(message) {
        const [newMessage] = await this.db.insert(ticketMessages).values(message).returning();
        await this.db.update(tickets).set({ updatedAt: (/* @__PURE__ */ new Date()).getTime() }).where(eq(tickets.id, message.ticketId));
        return newMessage;
      }
      async getTicketMessagesDB(ticketId) {
        return await this.db.select().from(ticketMessages).where(eq(ticketMessages.ticketId, ticketId)).orderBy(ticketMessages.createdAt);
      }
      // Product Pricing Management Implementation
      async updateProductPricing(data) {
        try {
          const existingProducts = await this.db.select().from(products).limit(1);
          if (existingProducts.length === 0) {
            const [newProduct] = await this.db.insert(products).values({
              name: "OCUS Job Hunter Chrome Extension",
              description: "Premium Chrome extension for photography job hunting on OCUS (Ubereats/Foodora deliveries)",
              price: data.price.toString(),
              beforePrice: data.beforePrice ? data.beforePrice.toString() : null,
              currency: "eur",
              fileName: "ocus-extension.crx",
              filePath: "/uploads/ocus-extension.crx",
              isActive: true
            }).returning();
            return newProduct;
          } else {
            const [updatedProduct] = await this.db.update(products).set({
              price: data.price.toString(),
              beforePrice: data.beforePrice ? data.beforePrice.toString() : null
            }).where(eq(products.id, existingProducts[0].id)).returning();
            return updatedProduct;
          }
        } catch (error) {
          console.error("Error updating product pricing:", error);
          throw error;
        }
      }
      async getCurrentProduct() {
        try {
          const productList = await this.db.select().from(products).where(eq(products.isActive, true)).limit(1);
          if (productList.length === 0) {
            return {
              id: 1,
              name: "OCUS Job Hunter Chrome Extension",
              description: "Premium Chrome extension for photography job hunting on OCUS (Ubereats/Foodora deliveries)",
              price: "500.00",
              beforePrice: null,
              currency: "eur"
            };
          }
          return productList[0];
        } catch (error) {
          console.error("Error fetching current product:", error);
          throw error;
        }
      }
      // Countdown Banner Management
      async createCountdownBanner(bannerData) {
        try {
          const [newBanner] = await this.db.insert(countdownBanners).values(bannerData).returning();
          return newBanner;
        } catch (error) {
          console.error("Error creating countdown banner:", error);
          throw error;
        }
      }
      async updateCountdownBanner(id, bannerData) {
        try {
          const [updatedBanner] = await this.db.update(countdownBanners).set({ ...bannerData, updatedAt: (/* @__PURE__ */ new Date()).getTime() }).where(eq(countdownBanners.id, id)).returning();
          return updatedBanner;
        } catch (error) {
          console.error("Error updating countdown banner:", error);
          throw error;
        }
      }
      async getActiveCountdownBanner() {
        try {
          const [activeBanner] = await this.db.select().from(countdownBanners).where(eq(countdownBanners.isEnabled, true)).orderBy(countdownBanners.priority, countdownBanners.createdAt).limit(1);
          if (activeBanner && new Date(activeBanner.endDateTime) <= /* @__PURE__ */ new Date()) {
            await this.db.update(countdownBanners).set({ isEnabled: false }).where(eq(countdownBanners.id, activeBanner.id));
            return null;
          }
          return activeBanner || null;
        } catch (error) {
          console.error("Error fetching active countdown banner:", error);
          throw error;
        }
      }
      async getAllCountdownBanners() {
        try {
          return await this.db.select().from(countdownBanners).orderBy(countdownBanners.createdAt);
        } catch (error) {
          console.error("Error fetching countdown banners:", error);
          throw error;
        }
      }
      async deleteCountdownBanner(id) {
        try {
          await this.db.delete(countdownBanners).where(eq(countdownBanners.id, id));
        } catch (error) {
          console.error("Error deleting countdown banner:", error);
          throw error;
        }
      }
      // Announcement Badge Management
      async getActiveAnnouncementBadge() {
        try {
          const [activeBadge] = await this.db.select().from(announcementBadges).where(eq(announcementBadges.isEnabled, true)).orderBy(desc(announcementBadges.priority), desc(announcementBadges.createdAt)).limit(1);
          return activeBadge || null;
        } catch (error) {
          console.error("Error fetching active announcement badge:", error);
          throw error;
        }
      }
      async getAllAnnouncementBadges() {
        try {
          return await this.db.select().from(announcementBadges).orderBy(desc(announcementBadges.createdAt));
        } catch (error) {
          console.error("Error fetching announcement badges:", error);
          throw error;
        }
      }
      async createAnnouncementBadge(data) {
        try {
          const [badge] = await this.db.insert(announcementBadges).values(data).returning();
          return badge;
        } catch (error) {
          console.error("Error creating announcement badge:", error);
          throw error;
        }
      }
      async updateAnnouncementBadge(id, data) {
        try {
          const [badge] = await this.db.update(announcementBadges).set({ ...data, updatedAt: (/* @__PURE__ */ new Date()).getTime() }).where(eq(announcementBadges.id, id)).returning();
          return badge;
        } catch (error) {
          console.error("Error updating announcement badge:", error);
          throw error;
        }
      }
      async deleteAnnouncementBadge(id) {
        try {
          await this.db.delete(announcementBadges).where(eq(announcementBadges.id, id));
        } catch (error) {
          console.error("Error deleting announcement badge:", error);
          throw error;
        }
      }
      async deleteCustomer(id) {
        const customerId = typeof id === "string" ? parseInt(id) : id;
        await this.db.delete(tickets).where(eq(tickets.customerEmail, (await this.getCustomer(customerId))?.email || ""));
        await this.db.delete(customers).where(eq(customers.id, customerId));
      }
      // Lottery Scratch Activation System
      generateUniqueActivationKey() {
        return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      }
      async revealActivationKey(customerId) {
        const [customer] = await this.db.update(customers).set({
          activationKeyRevealed: true,
          extensionActivated: true,
          // Activate extension after payment
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        }).where(eq(customers.id, parseInt(customerId))).returning();
        return customer;
      }
      // Activation Code System Implementation
      async createActivationCode(codeData) {
        const [code] = await this.db.insert(activationCodes).values(codeData).returning();
        return code;
      }
      async getActivationCode(code) {
        const [activation] = await this.db.select().from(activationCodes).where(eq(activationCodes.code, code));
        return activation || void 0;
      }
      async getActivationCodeByVersionToken(versionToken) {
        const [activation] = await this.db.select().from(activationCodes).where(eq(activationCodes.versionToken, versionToken));
        return activation || void 0;
      }
      async activateCode(code, deviceId, ipAddress) {
        const activation = await this.getActivationCode(code);
        if (!activation) {
          throw new Error("Invalid activation code");
        }
        if (!activation.isActive) {
          throw new Error("Activation code is inactive");
        }
        if (activation.expiresAt && (/* @__PURE__ */ new Date()).getTime() > activation.expiresAt) {
          throw new Error("Activation code has expired");
        }
        if (activation.activationCount >= activation.maxActivations) {
          throw new Error("Activation code has reached maximum activations");
        }
        const [updated] = await this.db.update(activationCodes).set({
          activatedAt: activation.activatedAt || (/* @__PURE__ */ new Date()).getTime(),
          activationCount: activation.activationCount + 1,
          deviceId,
          ipAddress
        }).where(eq(activationCodes.code, code)).returning();
        return updated;
      }
      async getCustomerActivationCodes(customerId) {
        return await this.db.select().from(activationCodes).where(eq(activationCodes.customerId, parseInt(customerId))).orderBy(desc(activationCodes.createdAt));
      }
      async deactivateCode(code) {
        const [updated] = await this.db.update(activationCodes).set({ isActive: false }).where(eq(activationCodes.code, code)).returning();
        return updated;
      }
      async generateActivationCode(customerId, orderId) {
        let code;
        let exists2 = true;
        while (exists2) {
          code = this.generateUniqueActivationKey();
          const existing = await this.getActivationCode(code);
          exists2 = !!existing;
        }
        const versionToken = crypto.randomUUID();
        const codeData = {
          code,
          customerId: parseInt(customerId),
          orderId,
          versionToken,
          maxActivations: 1,
          isActive: true,
          expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1e3).getTime()
          // 1 year expiry
        };
        return await this.createActivationCode(codeData);
      }
      async getActivationKeyByOrderId(orderId) {
        const [key] = await this.db.select().from(activationKeys).where(eq(activationKeys.orderId, orderId));
        return key || null;
      }
      // Extension Management
      async createExtensionDownload(download) {
        const [newDownload] = await this.db.insert(extensionDownloads).values({
          ...download,
          downloadToken: download.downloadToken || crypto.randomUUID()
        }).returning();
        return newDownload;
      }
      async getExtensionDownload(token) {
        const [download] = await this.db.select().from(extensionDownloads).where(eq(extensionDownloads.downloadToken, token));
        return download || void 0;
      }
      async incrementExtensionDownloadCount(id) {
        const [download] = await this.db.update(extensionDownloads).set({
          downloadCount: sql`${extensionDownloads.downloadCount} + 1`
        }).where(eq(extensionDownloads.id, id)).returning();
        return download;
      }
      async getExtensionDownloads(customerId) {
        const id = typeof customerId === "string" ? parseInt(customerId) : customerId;
        return await this.db.select().from(extensionDownloads).where(eq(extensionDownloads.customerId, id)).orderBy(desc(extensionDownloads.createdAt));
      }
      async getCustomerExtensionDownloads(customerId) {
        return await this.getExtensionDownloads(customerId);
      }
      // Social Authentication Methods
      // Customer Extension Management
      async blockCustomer(customerId, reason) {
        const id = typeof customerId === "string" ? parseInt(customerId) : customerId;
        const [customer] = await this.db.update(customers).set({
          isBlocked: true,
          blockedReason: reason,
          blockedAt: (/* @__PURE__ */ new Date()).getTime(),
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        }).where(eq(customers.id, id)).returning();
        return customer;
      }
      async unblockCustomer(customerId) {
        const id = typeof customerId === "string" ? parseInt(customerId) : customerId;
        const [customer] = await this.db.update(customers).set({
          isBlocked: false,
          blockedReason: null,
          blockedAt: null,
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        }).where(eq(customers.id, id)).returning();
        return customer;
      }
      async generateExtensionActivationKey(customerId) {
        const id = typeof customerId === "string" ? parseInt(customerId) : customerId;
        const activationKey = crypto.randomUUID().replace(/-/g, "").substring(0, 20).toUpperCase();
        const [customer] = await this.db.update(customers).set({
          activationKey,
          isActivated: true,
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        }).where(eq(customers.id, id)).returning();
        return customer;
      }
      async activateExtension(customerId, activationKey) {
        const [customer] = await this.db.update(customers).set({
          extensionActivated: true,
          extensionLastUsed: (/* @__PURE__ */ new Date()).getTime(),
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        }).where(and(
          eq(customers.id, parseInt(customerId)),
          eq(customers.activationKey, activationKey),
          eq(customers.isActivated, true)
        )).returning();
        return customer;
      }
      async recordExtensionUsageLog(usage) {
        await this.db.update(customers).set({
          extensionTrialJobsUsed: sql`${customers.extensionTrialJobsUsed} + ${usage.jobsUsed}`,
          extensionLastUsed: (/* @__PURE__ */ new Date()).getTime(),
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        }).where(eq(customers.id, typeof usage.customerId === "string" ? parseInt(usage.customerId) : usage.customerId));
        const [usageLog] = await this.db.insert(extensionUsageLogs).values(usage).returning();
        return usageLog;
      }
      // Extension installation methods
      async createExtensionInstallation(data) {
        const [installation] = await this.db.insert(extensionInstallations).values(data).returning();
        return installation;
      }
      async getExtensionInstallation(installationId) {
        const [installation] = await this.db.select().from(extensionInstallations).where(eq(extensionInstallations.installationId, installationId));
        return installation || null;
      }
      async updateInstallationLastSeen(installationId) {
        await this.db.update(extensionInstallations).set({ lastSeenAt: (/* @__PURE__ */ new Date()).getTime() }).where(eq(extensionInstallations.installationId, installationId));
      }
      async getUserInstallations(userId) {
        return await this.db.select().from(extensionInstallations).where(eq(extensionInstallations.userId, userId));
      }
      // Enhanced activation code methods
      async createActivationCodeForUser(userId, installationId, orderId) {
        const code = `OCUS-${Date.now()}-${crypto.randomBytes(4).toString("hex").toUpperCase()}`;
        const versionToken = crypto.randomUUID();
        const [activationCode] = await this.db.insert(activationCodes).values({
          code,
          userId,
          orderId,
          installationId,
          versionToken,
          maxActivations: 1,
          activationCount: 0,
          isActive: true,
          dailyValidationCount: 0,
          isRevoked: false
        }).returning();
        return activationCode;
      }
      async validateActivationCodeForInstallation(code, installationId) {
        const [activationCode] = await this.db.select().from(activationCodes).where(eq(activationCodes.code, code));
        if (!activationCode) {
          return { valid: false, message: "Invalid activation code" };
        }
        if (activationCode.isRevoked) {
          return { valid: false, message: "Activation code has been revoked" };
        }
        if (activationCode.expiresAt && (/* @__PURE__ */ new Date()).getTime() > activationCode.expiresAt) {
          return { valid: false, message: "Activation code has expired" };
        }
        if (!activationCode.isActive) {
          return { valid: false, message: "Activation code is inactive" };
        }
        if (activationCode.installationId && activationCode.installationId !== installationId) {
          return { valid: false, message: "Activation code is already bound to another installation" };
        }
        if (activationCode.activationCount >= activationCode.maxActivations) {
          return { valid: false, message: "Activation code has been used maximum number of times" };
        }
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const lastValidationDate = activationCode.lastValidationDate ? new Date(activationCode.lastValidationDate) : null;
        if (lastValidationDate) {
          lastValidationDate.setHours(0, 0, 0, 0);
        }
        let dailyCount = activationCode.dailyValidationCount;
        if (!lastValidationDate || lastValidationDate.getTime() !== today.getTime()) {
          dailyCount = 0;
        }
        if (dailyCount >= 100) {
          return { valid: false, message: "Daily validation limit exceeded" };
        }
        await this.db.update(activationCodes).set({
          installationId: activationCode.installationId || installationId,
          activationCount: activationCode.installationId ? activationCode.activationCount : activationCode.activationCount + 1,
          activatedAt: activationCode.activatedAt || (/* @__PURE__ */ new Date()).getTime(),
          dailyValidationCount: dailyCount + 1,
          lastValidationDate: (/* @__PURE__ */ new Date()).getTime()
        }).where(eq(activationCodes.id, activationCode.id));
        return { valid: true, message: "Activation code is valid", activationCode };
      }
      async getActivationCodeByInstallation(installationId) {
        const [activationCode] = await this.db.select().from(activationCodes).where(eq(activationCodes.installationId, installationId));
        return activationCode || null;
      }
      async revokeActivationCode(codeId, reason) {
        await this.db.update(activationCodes).set({
          isRevoked: true,
          isActive: false
        }).where(eq(activationCodes.id, codeId));
      }
      async getCustomerTrialUsage(customerId) {
        const [customer] = await this.db.select({ extensionTrialJobsUsed: customers.extensionTrialJobsUsed }).from(customers).where(eq(customers.id, parseInt(customerId)));
        return customer?.extensionTrialJobsUsed || 0;
      }
      async canUseExtension(customerId) {
        const id = typeof customerId === "string" ? parseInt(customerId) : customerId;
        const [customer] = await this.db.select().from(customers).where(eq(customers.id, id));
        if (!customer) {
          return { canUse: false, reason: "Customer not found" };
        }
        if (customer.isBlocked) {
          return {
            canUse: false,
            reason: customer.blockedReason || "Account blocked",
            isBlocked: true
          };
        }
        if (customer.extensionActivated) {
          return { canUse: true };
        }
        if (customer.extensionTrialJobsUsed >= customer.extensionTrialLimit) {
          return {
            canUse: false,
            reason: "Trial limit exceeded. Please purchase activation code.",
            trialUsed: customer.extensionTrialJobsUsed
          };
        }
        return {
          canUse: true,
          trialUsed: customer.extensionTrialJobsUsed
        };
      }
      // Admin Customer Management
      async getAllCustomersForAdmin() {
        return await this.db.select().from(customers).orderBy(desc(customers.createdAt));
      }
      async getCustomerActivations() {
        const customersList = await this.getAllCustomersForAdmin();
        const result = [];
        for (const customer of customersList) {
          const downloads3 = await this.getCustomerExtensionDownloads(customer.id.toString());
          result.push({ customer, downloads: downloads3 });
        }
        return result;
      }
      // Mission Tracking Implementation
      async createMission(mission) {
        const [newMission] = await this.db.insert(missions).values({
          ...mission,
          createdAt: (/* @__PURE__ */ new Date()).getTime(),
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        }).returning();
        return newMission;
      }
      async getMission(missionId) {
        const [mission] = await this.db.select().from(missions).where(eq(missions.missionId, missionId));
        return mission || void 0;
      }
      async updateMissionStatus(missionId, status, timestamp) {
        const updateData = {
          status,
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        };
        switch (status) {
          case "assignment_accepted":
            updateData.assignmentAcceptedAt = (timestamp || /* @__PURE__ */ new Date()).getTime();
            break;
          case "appointment_confirmation":
            updateData.appointmentConfirmedAt = (timestamp || /* @__PURE__ */ new Date()).getTime();
            break;
          case "media_upload":
            updateData.mediaUploadedAt = (timestamp || /* @__PURE__ */ new Date()).getTime();
            break;
          case "billing_payment":
            updateData.billingCompletedAt = (timestamp || /* @__PURE__ */ new Date()).getTime();
            break;
          case "assignment_complete":
            updateData.assignmentCompletedAt = (timestamp || /* @__PURE__ */ new Date()).getTime();
            break;
        }
        const [updatedMission] = await this.db.update(missions).set(updateData).where(eq(missions.missionId, missionId)).returning();
        return updatedMission;
      }
      async getUserMissions(userId) {
        return await this.db.select().from(missions).where(eq(missions.userId, userId)).orderBy(desc(missions.createdAt));
      }
      async getCustomerMissions(customerId) {
        return await this.db.select().from(missions).where(eq(missions.customerId, customerId)).orderBy(desc(missions.createdAt));
      }
      // User Trial Management Implementation
      async createUserTrial(trial) {
        const [newTrial] = await this.db.insert(userTrials).values({
          ...trial,
          createdAt: (/* @__PURE__ */ new Date()).getTime(),
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        }).returning();
        return newTrial;
      }
      async getUserTrial(userId) {
        const [trial] = await this.db.select().from(userTrials).where(eq(userTrials.userId, userId));
        return trial || void 0;
      }
      // Trial usage methods for cross-browser tracking
      async getTrialUsage(trialKey) {
        const [usage] = await this.db.select().from(trialUsage).where(eq(trialUsage.trialKey, trialKey));
        return usage || void 0;
      }
      async createTrialUsage(data) {
        const [usage] = await this.db.insert(trialUsage).values(data).returning();
        return usage;
      }
      async incrementTrialUsage(trialKey) {
        const [usage] = await this.db.update(trialUsage).set({
          usageCount: sql`${trialUsage.usageCount} + 1`,
          lastUsed: (/* @__PURE__ */ new Date()).getTime()
        }).where(eq(trialUsage.trialKey, trialKey)).returning();
        return usage;
      }
      async expireTrialUsage(trialKey) {
        const [usage] = await this.db.update(trialUsage).set({ isExpired: true }).where(eq(trialUsage.trialKey, trialKey)).returning();
        return usage;
      }
      // Premium Device Management Implementation
      async getPremiumDevice(userId, deviceFingerprint) {
        const [device] = await this.db.select().from(premiumDevices).where(
          and(
            eq(premiumDevices.userId, userId),
            eq(premiumDevices.deviceFingerprint, deviceFingerprint),
            eq(premiumDevices.isActive, true)
          )
        );
        return device || void 0;
      }
      async getUserPremiumDevices(userId) {
        return await this.db.select().from(premiumDevices).where(
          and(
            eq(premiumDevices.userId, userId),
            eq(premiumDevices.isActive, true)
          )
        );
      }
      async registerPremiumDevice(userId, deviceFingerprint, extensionId) {
        const [device] = await this.db.insert(premiumDevices).values({
          userId,
          deviceFingerprint,
          extensionId,
          isActive: true,
          registeredAt: (/* @__PURE__ */ new Date()).getTime(),
          lastSeenAt: (/* @__PURE__ */ new Date()).getTime()
        }).returning();
        return device;
      }
      async deactivatePremiumDevice(deviceFingerprint, reason) {
        const [device] = await this.db.update(premiumDevices).set({
          isActive: false,
          deactivatedAt: (/* @__PURE__ */ new Date()).getTime(),
          deactivationReason: reason || "User requested deactivation"
        }).where(eq(premiumDevices.deviceFingerprint, deviceFingerprint)).returning();
        return device;
      }
      async updatePremiumDeviceLastSeen(deviceFingerprint) {
        const [device] = await this.db.update(premiumDevices).set({ lastSeenAt: (/* @__PURE__ */ new Date()).getTime() }).where(eq(premiumDevices.deviceFingerprint, deviceFingerprint)).returning();
        return device;
      }
      // Dashboard Features Management Implementation
      async getDashboardFeatures() {
        return await this.db.select().from(dashboardFeatures);
      }
      async getDashboardFeature(featureName) {
        const [feature] = await this.db.select().from(dashboardFeatures).where(eq(dashboardFeatures.featureName, featureName));
        return feature || void 0;
      }
      async createDashboardFeature(feature) {
        const [newFeature] = await this.db.insert(dashboardFeatures).values({
          ...feature,
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        }).returning();
        return newFeature;
      }
      async updateDashboardFeature(featureName, isEnabled, description) {
        const [updatedFeature] = await this.db.update(dashboardFeatures).set({
          isEnabled,
          description: description || void 0,
          updatedAt: (/* @__PURE__ */ new Date()).getTime()
        }).where(eq(dashboardFeatures.featureName, featureName)).returning();
        return updatedFeature;
      }
      async initializeDashboardFeatures() {
        const defaultFeatures = [
          { featureName: "affiliate_program", isEnabled: true, description: "Enable/disable affiliate program section in user dashboard" },
          { featureName: "analytics", isEnabled: true, description: "Enable/disable analytics section in user dashboard" },
          { featureName: "billing", isEnabled: true, description: "Enable/disable billing section in user dashboard" }
        ];
        for (const feature of defaultFeatures) {
          const existing = await this.getDashboardFeature(feature.featureName);
          if (!existing) {
            await this.createDashboardFeature(feature);
          }
        }
      }
      // Order Management - Missing method implementation
      async updateOrder(id, updates) {
        const [updatedOrder] = await this.db.update(orders).set({ ...updates }).where(eq(orders.id, id)).returning();
        return updatedOrder;
      }
      // Missing method implementations for Stripe webhook
      async createOrder(order) {
        const [newOrder] = await this.db.insert(orders).values({ ...order, createdAt: (/* @__PURE__ */ new Date()).getTime() }).returning();
        return newOrder;
      }
      async getOrderByPaymentIntentId(paymentIntentId) {
        const [order] = await this.db.select().from(orders).where(eq(orders.paymentIntentId, paymentIntentId));
        return order || void 0;
      }
      async updateCustomer(id, updates) {
        const customerId = typeof id === "string" ? parseInt(id) : id;
        const [updatedCustomer] = await this.db.update(customers).set({ ...updates, updatedAt: (/* @__PURE__ */ new Date()).getTime() }).where(eq(customers.id, customerId)).returning();
        return updatedCustomer;
      }
      async createInvoice(invoice) {
        const [newInvoice] = await this.db.insert(invoices).values({ ...invoice, createdAt: (/* @__PURE__ */ new Date()).getTime(), updatedAt: (/* @__PURE__ */ new Date()).getTime() }).returning();
        return newInvoice;
      }
      async createInvoiceItem(item) {
        const [newItem] = await this.db.insert(invoiceItems).values({ ...item, createdAt: (/* @__PURE__ */ new Date()).getTime() }).returning();
        return newItem;
      }
    };
    storage = new DatabaseStorage();
  }
});

// ../node_modules/drizzle-orm/d1/session.js
function d1ToRawMapping(results) {
  const rows = [];
  for (const row of results) {
    const entry = Object.keys(row).map((k) => row[k]);
    rows.push(entry);
  }
  return rows;
}
var SQLiteD1Session, D1Transaction, D1PreparedQuery;
var init_session2 = __esm({
  "../node_modules/drizzle-orm/d1/session.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_logger();
    init_sql();
    init_sqlite_core();
    init_session();
    init_utils();
    SQLiteD1Session = class extends SQLiteSession {
      static {
        __name(this, "SQLiteD1Session");
      }
      constructor(client, dialect, schema, options = {}) {
        super(dialect);
        this.client = client;
        this.schema = schema;
        this.options = options;
        this.logger = options.logger ?? new NoopLogger();
      }
      static [entityKind] = "SQLiteD1Session";
      logger;
      prepareQuery(query, fields, executeMethod, isResponseInArrayMode, customResultMapper) {
        const stmt = this.client.prepare(query.sql);
        return new D1PreparedQuery(
          stmt,
          query,
          this.logger,
          fields,
          executeMethod,
          isResponseInArrayMode,
          customResultMapper
        );
      }
      async batch(queries) {
        const preparedQueries = [];
        const builtQueries = [];
        for (const query of queries) {
          const preparedQuery = query._prepare();
          const builtQuery = preparedQuery.getQuery();
          preparedQueries.push(preparedQuery);
          if (builtQuery.params.length > 0) {
            builtQueries.push(preparedQuery.stmt.bind(...builtQuery.params));
          } else {
            const builtQuery2 = preparedQuery.getQuery();
            builtQueries.push(
              this.client.prepare(builtQuery2.sql).bind(...builtQuery2.params)
            );
          }
        }
        const batchResults = await this.client.batch(builtQueries);
        return batchResults.map((result, i) => preparedQueries[i].mapResult(result, true));
      }
      extractRawAllValueFromBatchResult(result) {
        return result.results;
      }
      extractRawGetValueFromBatchResult(result) {
        return result.results[0];
      }
      extractRawValuesValueFromBatchResult(result) {
        return d1ToRawMapping(result.results);
      }
      async transaction(transaction, config) {
        const tx = new D1Transaction("async", this.dialect, this, this.schema);
        await this.run(sql.raw(`begin${config?.behavior ? " " + config.behavior : ""}`));
        try {
          const result = await transaction(tx);
          await this.run(sql`commit`);
          return result;
        } catch (err) {
          await this.run(sql`rollback`);
          throw err;
        }
      }
    };
    D1Transaction = class _D1Transaction extends SQLiteTransaction {
      static {
        __name(this, "D1Transaction");
      }
      static [entityKind] = "D1Transaction";
      async transaction(transaction) {
        const savepointName = `sp${this.nestedIndex}`;
        const tx = new _D1Transaction("async", this.dialect, this.session, this.schema, this.nestedIndex + 1);
        await this.session.run(sql.raw(`savepoint ${savepointName}`));
        try {
          const result = await transaction(tx);
          await this.session.run(sql.raw(`release savepoint ${savepointName}`));
          return result;
        } catch (err) {
          await this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));
          throw err;
        }
      }
    };
    __name(d1ToRawMapping, "d1ToRawMapping");
    D1PreparedQuery = class extends SQLitePreparedQuery {
      static {
        __name(this, "D1PreparedQuery");
      }
      constructor(stmt, query, logger, fields, executeMethod, _isResponseInArrayMode, customResultMapper) {
        super("async", executeMethod, query);
        this.logger = logger;
        this._isResponseInArrayMode = _isResponseInArrayMode;
        this.customResultMapper = customResultMapper;
        this.fields = fields;
        this.stmt = stmt;
      }
      static [entityKind] = "D1PreparedQuery";
      /** @internal */
      customResultMapper;
      /** @internal */
      fields;
      /** @internal */
      stmt;
      run(placeholderValues) {
        const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
        this.logger.logQuery(this.query.sql, params);
        return this.stmt.bind(...params).run();
      }
      async all(placeholderValues) {
        const { fields, query, logger, stmt, customResultMapper } = this;
        if (!fields && !customResultMapper) {
          const params = fillPlaceholders(query.params, placeholderValues ?? {});
          logger.logQuery(query.sql, params);
          return stmt.bind(...params).all().then(({ results }) => this.mapAllResult(results));
        }
        const rows = await this.values(placeholderValues);
        return this.mapAllResult(rows);
      }
      mapAllResult(rows, isFromBatch) {
        if (isFromBatch) {
          rows = d1ToRawMapping(rows.results);
        }
        if (!this.fields && !this.customResultMapper) {
          return rows;
        }
        if (this.customResultMapper) {
          return this.customResultMapper(rows);
        }
        return rows.map((row) => mapResultRow(this.fields, row, this.joinsNotNullableMap));
      }
      async get(placeholderValues) {
        const { fields, joinsNotNullableMap, query, logger, stmt, customResultMapper } = this;
        if (!fields && !customResultMapper) {
          const params = fillPlaceholders(query.params, placeholderValues ?? {});
          logger.logQuery(query.sql, params);
          return stmt.bind(...params).all().then(({ results }) => results[0]);
        }
        const rows = await this.values(placeholderValues);
        if (!rows[0]) {
          return void 0;
        }
        if (customResultMapper) {
          return customResultMapper(rows);
        }
        return mapResultRow(fields, rows[0], joinsNotNullableMap);
      }
      mapGetResult(result, isFromBatch) {
        if (isFromBatch) {
          result = d1ToRawMapping(result.results)[0];
        }
        if (!this.fields && !this.customResultMapper) {
          return result;
        }
        if (this.customResultMapper) {
          return this.customResultMapper([result]);
        }
        return mapResultRow(this.fields, result, this.joinsNotNullableMap);
      }
      values(placeholderValues) {
        const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
        this.logger.logQuery(this.query.sql, params);
        return this.stmt.bind(...params).raw();
      }
      /** @internal */
      isResponseInArrayMode() {
        return this._isResponseInArrayMode;
      }
    };
  }
});

// ../node_modules/drizzle-orm/d1/driver.js
function drizzle(client, config = {}) {
  const dialect = new SQLiteAsyncDialect({ casing: config.casing });
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger();
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  let schema;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(
      config.schema,
      createTableRelationsHelpers
    );
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new SQLiteD1Session(client, dialect, schema, { logger });
  const db = new DrizzleD1Database("async", dialect, session, schema);
  db.$client = client;
  return db;
}
var DrizzleD1Database;
var init_driver = __esm({
  "../node_modules/drizzle-orm/d1/driver.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_entity();
    init_logger();
    init_relations();
    init_db2();
    init_dialect();
    init_session2();
    DrizzleD1Database = class extends BaseSQLiteDatabase {
      static {
        __name(this, "DrizzleD1Database");
      }
      static [entityKind] = "D1Database";
      async batch(batch) {
        return this.session.batch(batch);
      }
    };
    __name(drizzle, "drizzle");
  }
});

// ../node_modules/drizzle-orm/d1/index.js
var init_d1 = __esm({
  "../node_modules/drizzle-orm/d1/index.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_driver();
    init_session2();
  }
});

// api/orders/user-orders.ts
var onRequestGet48, onRequestOptions44;
var init_user_orders = __esm({
  "api/orders/user-orders.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_storage();
    init_d1();
    init_schema();
    onRequestGet48 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const url = new URL(request.url);
        const customerEmail = url.searchParams.get("email");
        const userId = url.searchParams.get("userId");
        if (!customerEmail && !userId) {
          return new Response(JSON.stringify({
            success: false,
            error: "Email or userId parameter is required"
          }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        if (!env.DB) {
          return new Response(JSON.stringify({
            success: false,
            error: "Database not available"
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const db = drizzle(env.DB, { schema: schema_exports });
        const storage2 = new DatabaseStorage(db);
        let orders2 = [];
        let customer = null;
        try {
          if (customerEmail) {
            customer = await storage2.getCustomerByEmail(customerEmail);
            if (customer) {
              orders2 = await storage2.getCustomerOrders(customer.id.toString());
            }
            const user = await storage2.getUserByEmail(customerEmail);
            if (user) {
              const userOrders = await storage2.getUserOrders(user.id);
              const allOrders = [...orders2, ...userOrders];
              const uniqueOrders = allOrders.filter(
                (order, index, self) => index === self.findIndex((o) => o.id === order.id)
              );
              orders2 = uniqueOrders;
            }
          } else if (userId) {
            orders2 = await storage2.getUserOrders(parseInt(userId));
          }
          orders2.sort((a, b) => {
            const dateA = a.completedAt || a.createdAt || 0;
            const dateB = b.completedAt || b.createdAt || 0;
            return dateB - dateA;
          });
          console.log(`Found ${orders2.length} orders for ${customerEmail || userId}`);
          return new Response(JSON.stringify({
            success: true,
            orders: orders2,
            customer: customer ? {
              id: customer.id,
              email: customer.email,
              name: customer.name,
              subscriptionStatus: customer.subscriptionStatus,
              extensionActivated: customer.extensionActivated
            } : null
          }), {
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        } catch (dbError) {
          console.error("Database error in user-orders:", dbError);
          return new Response(JSON.stringify({
            success: false,
            error: "Database query failed",
            details: String(dbError)
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
      } catch (error) {
        console.error("Error fetching user orders:", error);
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to fetch orders",
          details: String(error)
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions44 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type",
          "Access-Control-Max-Age": "86400"
        }
      });
    }, "onRequestOptions");
  }
});

// api/products/pricing.ts
async function onRequestGet49(context) {
  const { env } = context;
  try {
    const selectQuery = `SELECT * FROM products WHERE id = 1 AND isActive = 1`;
    const result = await env.DB.prepare(selectQuery).first();
    if (!result) {
      return new Response(JSON.stringify({
        id: 1,
        name: "OCUS Job Hunter Extension",
        price: "250.00",
        beforePrice: null
      }), {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }
    return new Response(JSON.stringify({
      id: result.id,
      name: result.name,
      price: result.price.toString(),
      beforePrice: result.beforePrice ? result.beforePrice.toString() : null
    }), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization"
      }
    });
  } catch (error) {
    console.error("Error fetching pricing:", error);
    return new Response(JSON.stringify({
      message: "Error fetching pricing: " + error.message
    }), {
      status: 500,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization"
      }
    });
  }
}
async function onRequestOptions45(context) {
  return new Response(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
var init_pricing2 = __esm({
  "api/products/pricing.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(onRequestGet49, "onRequestGet");
    __name(onRequestOptions45, "onRequestOptions");
  }
});

// api/download-extension/[type].ts
var onRequestGet50, onRequestOptions46;
var init_type = __esm({
  "api/download-extension/[type].ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet50 = /* @__PURE__ */ __name(async (context) => {
      try {
        const { params, request } = context;
        const downloadType = params.type;
        const url = new URL(request.url);
        const userId = url.searchParams.get("userId") || "1";
        if (!["premium", "trial"].includes(downloadType)) {
          return new Response(JSON.stringify({ error: "Invalid download type" }), {
            status: 400,
            headers: { "Content-Type": "application/json" }
          });
        }
        if (downloadType === "premium") {
          const userQuery = `SELECT is_premium FROM users WHERE id = ?`;
          const userResult = await context.env.DB.prepare(userQuery).bind(userId).first();
          if (!userResult?.is_premium) {
            return new Response(JSON.stringify({ error: "Premium access required" }), {
              status: 403,
              headers: { "Content-Type": "application/json" }
            });
          }
        }
        const downloadLogQuery = `
      INSERT INTO user_downloads (user_id, download_type, version, ip_address, user_agent)
      VALUES (?, ?, ?, ?, ?)
    `;
        const clientIP = request.headers.get("CF-Connecting-IP") || request.headers.get("X-Forwarded-For") || "unknown";
        const userAgent = request.headers.get("User-Agent") || "unknown";
        await context.env.DB.prepare(downloadLogQuery).bind(userId, downloadType, "v2.1.9", clientIP, userAgent).run();
        const fileName = downloadType === "premium" ? "ocus-job-hunter-premium-v2.1.9-STABLE.zip" : "ocus-job-hunter-trial-v2.1.9-STABLE.zip";
        const mockFileContent = `Mock ${downloadType} extension file content for ${fileName}`;
        return new Response(mockFileContent, {
          status: 200,
          headers: {
            "Content-Type": "application/zip",
            "Content-Disposition": `attachment; filename="${fileName}"`,
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Error handling extension download:", error);
        return new Response(JSON.stringify({ error: "Download failed" }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions46 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/generate-invoice/[orderId].ts
async function onRequestPost20(context) {
  const { request, env, params } = context;
  const orderId = params.orderId;
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const orderQuery = `
      SELECT 
        id, customer_id, customer_email, customer_name, 
        product_id, final_amount, currency, payment_method,
        status, completed_at, created_at
      FROM orders 
      WHERE id = ? AND status = 'completed'
    `;
    const orderResult = await env.DB.prepare(orderQuery).bind(orderId).first();
    if (!orderResult) {
      return new Response(JSON.stringify({
        success: false,
        error: "Order not found or not completed"
      }), {
        status: 404,
        headers: { "Content-Type": "application/json", ...corsHeaders }
      });
    }
    const existingInvoiceQuery = `
      SELECT id FROM invoices WHERE order_id = ?
    `;
    const existingInvoice = await env.DB.prepare(existingInvoiceQuery).bind(orderId).first();
    if (existingInvoice) {
      return new Response(JSON.stringify({
        success: false,
        error: "Invoice already exists for this order"
      }), {
        status: 400,
        headers: { "Content-Type": "application/json", ...corsHeaders }
      });
    }
    const invoiceNumber = `INV-${Date.now()}-${orderId}`;
    const amount = parseFloat(orderResult.final_amount);
    const taxRate = 0;
    const taxAmount = amount * taxRate;
    const createInvoiceQuery = `
      INSERT INTO invoices (
        invoice_number, order_id, customer_id, amount, currency,
        tax_amount, status, invoice_date, paid_at, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const invoiceResult = await env.DB.prepare(createInvoiceQuery).bind(
      invoiceNumber,
      orderId,
      orderResult.customer_id,
      orderResult.final_amount,
      orderResult.currency,
      taxAmount.toString(),
      "paid",
      // Since order is completed, invoice is paid
      orderResult.completed_at || now,
      orderResult.completed_at || now,
      now
    ).run();
    if (!invoiceResult.success) {
      throw new Error("Failed to create invoice");
    }
    return new Response(JSON.stringify({
      success: true,
      invoiceId: invoiceResult.meta.last_row_id,
      invoiceNumber,
      message: "Invoice created successfully"
    }), {
      status: 201,
      headers: { "Content-Type": "application/json", ...corsHeaders }
    });
  } catch (error) {
    console.error("Error creating invoice:", error);
    return new Response(JSON.stringify({
      success: false,
      error: "Failed to create invoice"
    }), {
      status: 500,
      headers: { "Content-Type": "application/json", ...corsHeaders }
    });
  }
}
var init_orderId2 = __esm({
  "api/generate-invoice/[orderId].ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(onRequestPost20, "onRequestPost");
  }
});

// api/tickets/[id].ts
function json14(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var onRequestPatch2, onRequestPut15, onRequestDelete5, onRequestOptions47;
var init_id5 = __esm({
  "api/tickets/[id].ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_db();
    __name(json14, "json");
    onRequestPatch2 = /* @__PURE__ */ __name(async ({ request, params, env }) => {
      try {
        const ticketId = Number(params.id);
        const expressBase = env?.EXPRESS_API_BASE;
        if (expressBase) {
          const base = expressBase.replace(/\/$/, "");
          const url = `${base}/api/tickets/${ticketId}`;
          const headers = {};
          const cookie = request.headers.get("cookie");
          const ct = request.headers.get("content-type");
          const auth = request.headers.get("authorization");
          if (cookie) headers["cookie"] = cookie;
          if (ct) headers["content-type"] = ct;
          if (auth) headers["authorization"] = auth;
          const proxied = await fetch(url, { method: "PATCH", headers, body: request.body, redirect: "manual" });
          const respHeaders = new Headers(proxied.headers);
          const setCookie = respHeaders.get("set-cookie");
          if (setCookie) {
            const rewritten = setCookie.replace(/;\s*Domain=[^;]+/i, "");
            respHeaders.delete("set-cookie");
            respHeaders.append("set-cookie", rewritten);
          }
          return new Response(proxied.body, { status: proxied.status, headers: respHeaders });
        }
        const updates = await request.json();
        const storage2 = new TicketStorage(env.DB);
        const ticket = await storage2.getTicketById(ticketId);
        if (!ticket) return json14({ success: false, message: "Ticket not found" }, 404);
        if (updates.status) {
          await storage2.updateTicketStatus(ticketId, updates.status);
        }
        const updatedTicket = await storage2.getTicketById(ticketId);
        return json14({ success: true, ticket: updatedTicket });
      } catch (error) {
        console.error("Failed to update ticket:", error);
        const message = error instanceof Error ? error.message : "An unknown error occurred";
        return json14({ success: false, message }, 500);
      }
    }, "onRequestPatch");
    onRequestPut15 = /* @__PURE__ */ __name(async (ctx) => {
      return onRequestPatch2(ctx);
    }, "onRequestPut");
    onRequestDelete5 = /* @__PURE__ */ __name(async ({ request, params, env }) => {
      try {
        const ticketId = Number(params.id);
        const expressBase = env?.EXPRESS_API_BASE;
        if (expressBase) {
          const base = expressBase.replace(/\/$/, "");
          const url = `${base}/api/tickets/${ticketId}`;
          const headers = {};
          const cookie = request.headers.get("cookie");
          const auth = request.headers.get("authorization");
          if (cookie) headers["cookie"] = cookie;
          if (auth) headers["authorization"] = auth;
          const proxied = await fetch(url, { method: "DELETE", headers, redirect: "manual" });
          const respHeaders = new Headers(proxied.headers);
          const setCookie = respHeaders.get("set-cookie");
          if (setCookie) {
            const rewritten = setCookie.replace(/;\s*Domain=[^;]+/i, "");
            respHeaders.delete("set-cookie");
            respHeaders.append("set-cookie", rewritten);
          }
          return new Response(proxied.body, { status: proxied.status, headers: respHeaders });
        }
        const storage2 = new TicketStorage(env.DB);
        const ticket = await storage2.getTicketById(ticketId);
        if (!ticket) {
          return json14({ success: false, message: "Ticket not found" }, 404);
        }
        await storage2.deleteTicket(ticketId);
        return json14({ success: true, message: `Ticket ${ticketId} deleted` });
      } catch (error) {
        console.error("Failed to delete ticket:", error);
        const message = error instanceof Error ? error.message : "An unknown error occurred";
        return json14({ success: false, message }, 500);
      }
    }, "onRequestDelete");
    onRequestOptions47 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "PUT, PATCH, DELETE, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/auth-settings.ts
var defaultSettings, onRequestGet51, onRequestOptions48;
var init_auth_settings2 = __esm({
  "api/auth-settings.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    defaultSettings = {
      googleEnabled: false,
      facebookEnabled: false,
      githubEnabled: false,
      recaptchaEnabled: false,
      recaptchaCustomerEnabled: false,
      recaptchaAdminEnabled: false,
      recaptchaSiteKey: "",
      googleClientId: "",
      facebookAppId: "",
      githubClientId: ""
    };
    onRequestGet51 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        const dbQuery = "SELECT * FROM auth_settings WHERE id = 1";
        const dbSettings = await env.DB.prepare(dbQuery).first();
        const apiSettings = {
          ...defaultSettings,
          ...dbSettings && {
            googleEnabled: !!dbSettings.google_enabled,
            facebookEnabled: !!dbSettings.facebook_enabled,
            githubEnabled: !!dbSettings.github_enabled,
            recaptchaEnabled: !!dbSettings.recaptcha_enabled,
            recaptchaCustomerEnabled: !!dbSettings.recaptcha_customer_enabled,
            recaptchaAdminEnabled: !!dbSettings.recaptcha_admin_enabled,
            recaptchaSiteKey: dbSettings.recaptcha_site_key || "",
            googleClientId: dbSettings.google_client_id || "",
            facebookAppId: dbSettings.facebook_app_id || "",
            githubClientId: dbSettings.github_client_id || ""
          }
        };
        return new Response(JSON.stringify(apiSettings), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Failed to fetch auth settings:", error);
        return new Response(JSON.stringify(defaultSettings), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions48 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/chat.ts
var onRequestPost21, onRequestOptions49;
var init_chat = __esm({
  "api/chat.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_settings_storage();
    onRequestPost21 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const { message, history } = await request.json();
        let openaiApiKey = null;
        if (env.DB) {
          try {
            const settingsStorage = new SettingsStorage(env.DB);
            await settingsStorage.initializeSettings();
            openaiApiKey = await settingsStorage.getOpenAIApiKey();
          } catch (error) {
            console.error("Failed to get API key from settings:", error);
          }
        }
        if (!openaiApiKey) {
          openaiApiKey = env.OPENAI_API_KEY;
        }
        if (!openaiApiKey) {
          return new Response(JSON.stringify({
            success: false,
            response: "I'm currently not configured to respond. Please contact our support team for assistance."
          }), {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const conversationHistory = history?.map((msg) => ({
          role: msg.sender === "user" ? "user" : "assistant",
          content: msg.text
        })) || [];
        const systemPrompt = {
          role: "system",
          content: `You are a helpful AI assistant for the OCUS Job Hunter Chrome Extension. You help users with:
      
      - Understanding how to use the job hunting extension
      - Troubleshooting extension issues
      - Explaining features and benefits
      - Providing job search tips and strategies
      - Answering questions about pricing and subscriptions
      
      Keep responses helpful, concise, and focused on job hunting and the extension. If asked about unrelated topics, politely redirect to job hunting assistance.`
        };
        const openaiResponse = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${openaiApiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model: "gpt-4o-mini",
            messages: [
              systemPrompt,
              ...conversationHistory,
              { role: "user", content: message }
            ],
            max_tokens: 500,
            temperature: 0.7
          })
        });
        if (!openaiResponse.ok) {
          throw new Error(`OpenAI API error: ${openaiResponse.status}`);
        }
        const openaiData = await openaiResponse.json();
        const assistantResponse = openaiData.choices[0]?.message?.content || "I'm having trouble processing your request. Please try again or contact our support team.";
        return new Response(JSON.stringify({
          success: true,
          response: assistantResponse
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Chat API error:", error);
        return new Response(JSON.stringify({
          success: false,
          response: "I'm experiencing technical difficulties. Please contact our support team for immediate assistance."
        }), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
    onRequestOptions49 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
  }
});

// api/complete-stripe-payment.ts
function json15(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": false ? "https://jobhunter.one" : "*"
    }
  });
}
var onRequestPost22, onRequestOptions50;
var init_complete_stripe_payment = __esm({
  "api/complete-stripe-payment.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_storage();
    init_d1();
    init_schema();
    __name(json15, "json");
    onRequestPost22 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const body = await request.json();
        const { paymentIntentId, customerEmail, customerName } = body;
        if (!paymentIntentId || !customerEmail) {
          return json15({ success: false, message: "Missing required fields" }, 400);
        }
        console.log("Stripe payment completion request:", { paymentIntentId, customerEmail, customerName });
        if (!env.DB) {
          console.error("D1 database not available");
          return json15({ success: false, message: "Database not available" }, 500);
        }
        const db = drizzle(env.DB, { schema: schema_exports });
        const storage2 = new DatabaseStorage(db);
        const now = (/* @__PURE__ */ new Date()).getTime();
        const amount = 29.99;
        const currency = "USD";
        try {
          let customer = await storage2.getCustomerByEmail(customerEmail);
          if (!customer) {
            console.log(`Creating new customer: ${customerEmail}`);
            customer = await storage2.createCustomer({
              email: customerEmail,
              name: customerName || customerEmail,
              extensionActivated: true,
              subscriptionStatus: "active",
              totalSpent: amount.toString(),
              totalOrders: 1,
              lastOrderDate: now
            });
          } else {
            console.log(`Updating existing customer: ${customerEmail}`);
            await storage2.updateCustomer(customer.id, {
              extensionActivated: true,
              subscriptionStatus: "active",
              totalSpent: (parseFloat(customer.totalSpent) + amount).toString(),
              totalOrders: customer.totalOrders + 1,
              lastOrderDate: now,
              updatedAt: now
            });
          }
          const user = await storage2.getUserByEmail(customerEmail);
          if (user) {
            console.log(`Updating user premium status: ${customerEmail}`);
            await storage2.updateUser(user.id, {
              isPremium: true,
              extensionActivated: true,
              premiumActivatedAt: now.toString(),
              totalSpent: (parseFloat(user.totalSpent) + amount).toString(),
              totalOrders: user.totalOrders + 1
            });
          }
          const downloadToken = `download_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          const activationCode = `activation_${Date.now()}_${Math.random().toString(36).substr(2, 12)}`;
          console.log("Creating order record...");
          const order = await storage2.createOrder({
            userId: user?.id,
            customerEmail,
            customerName: customerName || customerEmail,
            originalAmount: amount.toString(),
            finalAmount: amount.toString(),
            currency: currency.toLowerCase(),
            status: "completed",
            paymentMethod: "stripe",
            paymentIntentId,
            downloadToken,
            activationCode,
            completedAt: now
          });
          console.log(`Order created with ID: ${order.id}`);
          const invoiceNumber = `INV-${order.id}-${Date.now()}`;
          console.log(`Creating invoice: ${invoiceNumber}`);
          const invoice = await storage2.createInvoice({
            orderId: order.id,
            invoiceNumber,
            customerId: customer.id,
            customerName: customerName || customerEmail,
            customerEmail,
            invoiceDate: now,
            dueDate: now,
            // Immediate payment
            subtotal: amount.toString(),
            taxAmount: "0.00",
            discountAmount: "0.00",
            totalAmount: amount.toString(),
            currency: currency.toUpperCase(),
            status: "paid",
            paidAt: now
          });
          await storage2.createInvoiceItem({
            invoiceId: invoice.id,
            productName: "OCUS Job Hunter Extension",
            description: "Premium Chrome Extension for OCUS Job Hunting",
            quantity: 1,
            unitPrice: amount.toString(),
            totalPrice: amount.toString()
          });
          const activationKey = await storage2.createActivationKey({
            activationKey: activationCode,
            orderId: order.id,
            userId: user?.id
          });
          console.log(`\u2705 Payment completed successfully for ${customerEmail}:`);
          console.log(`   - Customer ID: ${customer.id}`);
          console.log(`   - Order ID: ${order.id}`);
          console.log(`   - Invoice: ${invoiceNumber}`);
          console.log(`   - Activation Code: ${activationCode}`);
          console.log(`   - Amount: ${amount} ${currency}`);
          return json15({
            success: true,
            message: "Payment completed successfully - Premium access activated",
            data: {
              orderId: order.id,
              invoiceNumber,
              activationCode,
              downloadToken
            }
          });
        } catch (error) {
          console.error("Error in complete-stripe-payment:", error);
          return json15({
            success: false,
            message: `Payment completion failed: ${error.message}`
          }, 500);
        }
      } catch (error) {
        console.error("Error parsing request in complete-stripe-payment:", error);
        return json15({
          success: false,
          message: "Invalid request format"
        }, 400);
      }
    }, "onRequestPost");
    onRequestOptions50 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": false ? "https://jobhunter.one" : "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type",
          "Access-Control-Max-Age": "86400"
        }
      });
    }, "onRequestOptions");
  }
});

// api/create-user-payment-intent.ts
var onRequestPost23, onRequestOptions51;
var init_create_user_payment_intent = __esm({
  "api/create-user-payment-intent.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestPost23 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const body = await request.json();
        const { amount, currency = "usd", customerEmail, customerName, productId } = body;
        console.log("Payment intent request:", { amount, currency, customerEmail, productId });
        const numericAmount = typeof amount === "string" ? parseFloat(amount) : Number(amount);
        if (!numericAmount || isNaN(numericAmount) || numericAmount <= 0) {
          console.error("Invalid amount received:", { amount, numericAmount, type: typeof amount });
          return new Response(JSON.stringify({
            success: false,
            error: `Invalid amount: ${amount}. Must be a positive number.`
          }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const paymentSettings = await env.DB.prepare(`
      SELECT key, value FROM settings 
      WHERE key LIKE 'payment_%'
    `).all();
        const settings3 = {};
        paymentSettings.results?.forEach((row) => {
          const key = row.key.replace("payment_", "");
          let value = row.value;
          if (value === "true") value = true;
          if (value === "false") value = false;
          settings3[key] = value;
        });
        if (!settings3.stripeEnabled || !settings3.stripeSecretKey) {
          console.error("Stripe configuration missing:", {
            stripeEnabled: settings3.stripeEnabled,
            hasSecretKey: !!settings3.stripeSecretKey,
            hasPublicKey: !!settings3.stripePublicKey
          });
          return new Response(JSON.stringify({
            success: false,
            error: "Payment processing not configured. Please contact support.",
            details: "Stripe payment gateway is not properly configured"
          }), {
            status: 503,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        if (!settings3.stripeSecretKey.startsWith("sk_")) {
          console.error("Invalid Stripe secret key format");
          return new Response(JSON.stringify({
            success: false,
            error: "Invalid payment configuration"
          }), {
            status: 503,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const stripeResponse = await fetch("https://api.stripe.com/v1/payment_intents", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${settings3.stripeSecretKey}`,
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: new URLSearchParams({
            amount: Math.round(numericAmount * 100).toString(),
            // Convert to cents
            currency: currency.toLowerCase(),
            "automatic_payment_methods[enabled]": "true",
            ...customerEmail && { receipt_email: customerEmail },
            ...productId && { "metadata[productId]": productId, "metadata[customerName]": customerName || "" }
          })
        });
        if (!stripeResponse.ok) {
          const errorData = await stripeResponse.text();
          console.error("Stripe API error:", {
            status: stripeResponse.status,
            statusText: stripeResponse.statusText,
            errorData,
            requestData: {
              amount: Math.round(numericAmount * 100),
              currency: currency.toLowerCase(),
              hasSecretKey: !!settings3.stripeSecretKey,
              secretKeyPrefix: settings3.stripeSecretKey?.substring(0, 12) + "..."
            }
          });
          let stripeError;
          try {
            stripeError = JSON.parse(errorData);
          } catch {
            stripeError = { message: errorData };
          }
          return new Response(JSON.stringify({
            success: false,
            error: "Failed to create payment intent",
            details: stripeError.error?.message || stripeError.message || "Unknown Stripe error",
            stripeErrorType: stripeError.error?.type,
            stripeErrorCode: stripeError.error?.code
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const paymentIntent = await stripeResponse.json();
        try {
          await env.DB.prepare(`
        INSERT INTO settings (key, value) 
        VALUES (?, ?)
      `).bind(
            `payment_intent_${paymentIntent.id}`,
            JSON.stringify({
              id: paymentIntent.id,
              amount: numericAmount,
              currency,
              customerEmail,
              customerName,
              productId,
              status: "created",
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            })
          ).run();
        } catch (dbError) {
          console.warn("Failed to store payment intent in database:", dbError);
        }
        return new Response(JSON.stringify({
          success: true,
          clientSecret: paymentIntent.client_secret,
          paymentIntentId: paymentIntent.id,
          publishableKey: settings3.stripePublicKey
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Payment intent creation error:", error);
        return new Response(JSON.stringify({
          success: false,
          error: "Internal server error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
    onRequestOptions51 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/download-premium.ts
function json16(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var onRequestPost24, onRequestGet52, onRequestOptions52;
var init_download_premium = __esm({
  "api/download-premium.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json16, "json");
    onRequestPost24 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const body = await request.json();
        const { customerId, customerEmail, activationCode, email } = body;
        const finalEmail = customerEmail || email;
        if (!customerId && !finalEmail && !activationCode) {
          return json16({
            success: false,
            message: "Customer identification required"
          }, 400);
        }
        if (!env.DB) {
          console.error("D1 database not available");
          return json16({ success: false, message: "Database not available" }, 500);
        }
        try {
          let account = null;
          let accountType = null;
          if (customerId) {
            try {
              account = await env.DB.prepare(`
            SELECT id, email, name, is_premium, extension_activated, total_spent 
            FROM customers WHERE id = ?
          `).bind(customerId).first();
              if (account) accountType = "customer";
            } catch (e) {
              console.log("Customer query failed, trying fallback");
            }
          } else if (finalEmail) {
            try {
              account = await env.DB.prepare(`
            SELECT id, email, name, is_premium, extension_activated, total_spent 
            FROM customers WHERE email = ?
          `).bind(finalEmail).first();
              if (account) accountType = "customer";
            } catch (e) {
              console.log("Customer email query failed, trying fallback");
            }
          } else if (activationCode) {
            try {
              const codeResult = await env.DB.prepare(`
            SELECT c.id, c.email, c.name, c.is_premium, c.extension_activated, c.total_spent
            FROM customers c
            JOIN activation_codes ac ON c.id = ac.customer_id
            WHERE ac.code = ? AND ac.isActive = 1
          `).bind(activationCode).first();
              account = codeResult;
              if (account) accountType = "customer";
            } catch (e) {
              console.log("Activation code query failed:", e);
            }
          }
          if (!account && finalEmail) {
            try {
              const user = await env.DB.prepare(`
            SELECT id, email, name, is_premium, extension_activated
            FROM users WHERE email = ?
          `).bind(finalEmail).first();
              if (user) {
                account = { ...user, total_spent: 0 };
                accountType = "user";
              }
            } catch (e) {
              console.log("User email query failed:", e);
            }
          }
          if (!account) {
            return json16({
              success: false,
              message: "Account not found or invalid credentials"
            }, 404);
          }
          const hasBasicAccess = account.is_premium && account.extension_activated;
          if (!hasBasicAccess) {
            return json16({
              success: false,
              message: "Premium access not activated. Please complete your purchase first.",
              accountStatus: {
                isPremium: account.is_premium,
                extensionActivated: account.extension_activated,
                totalSpent: account.total_spent
              }
            }, 403);
          }
          let hasValidOrders = false;
          try {
            const orderCheck = await env.DB.prepare(`
          SELECT COUNT(*) as orderCount FROM orders 
          WHERE (customer_id = ? OR customer_email = ?) AND status = 'completed' AND final_amount > 0
        `).bind(account.id, account.email).first();
            hasValidOrders = orderCheck?.orderCount > 0;
            console.log(`Order check for ${accountType} '${account.email}':`, { hasValidOrders });
          } catch (e) {
            console.log("Order check failed:", e);
            hasValidOrders = account.is_premium && account.extension_activated;
            console.error("Database order check failed, falling back to premium flags. This should be investigated.", e);
          }
          if (!hasValidOrders) {
            return json16({
              success: false,
              message: "No valid premium purchases found. Premium download requires completed payment.",
              accountStatus: {
                isPremium: account.is_premium,
                extensionActivated: account.extension_activated,
                totalSpent: account.total_spent,
                requiresPayment: true
              }
            }, 403);
          }
          const downloadToken = `download_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          const now = (/* @__PURE__ */ new Date()).toISOString();
          try {
            await env.DB.prepare(`
          INSERT INTO extension_downloads (
            customer_id, download_token, downloaded_at, ip_address, user_agent, created_at
          ) VALUES (?, ?, ?, ?, ?, ?)
        `).bind(
              account.id,
              // Use account.id, which exists for both users and customers
              downloadToken,
              now,
              request.headers.get("CF-Connecting-IP") || "unknown",
              request.headers.get("User-Agent") || "unknown",
              now
            ).run();
          } catch (e) {
            console.log("Failed to log download, continuing anyway:", e);
          }
          let activationCodeResult = `TEMP_${Date.now()}_${account.id}`;
          if (accountType === "customer") {
            try {
              const result = await env.DB.prepare(`SELECT code FROM activation_codes WHERE customer_id = ? AND isActive = 1 ORDER BY created_at DESC LIMIT 1`).bind(account.id).first();
              if (result) activationCodeResult = result.code;
            } catch (e) {
              console.log("Failed to get activation code:", e);
            }
          }
          return json16({
            success: true,
            message: "Download access granted",
            downloadEnabled: true,
            downloadToken,
            activationCode: activationCodeResult,
            account: {
              id: account.id,
              email: account.email,
              name: account.name
            }
          });
        } catch (dbError) {
          console.error("Database error during download validation:", dbError);
          return json16({
            success: false,
            message: "Failed to validate download access",
            error: dbError.message
          }, 500);
        }
      } catch (error) {
        console.error("Download validation error:", error);
        return json16({
          success: false,
          message: "Internal server error",
          error: error.message
        }, 500);
      }
    }, "onRequestPost");
    onRequestGet52 = /* @__PURE__ */ __name(async ({ request, env }) => {
      const url = new URL(request.url);
      const customerId = url.searchParams.get("customerId");
      const customerEmail = url.searchParams.get("customerEmail");
      if (!customerId && !customerEmail) {
        return json16({ success: false, message: "Customer identification required" }, 400);
      }
      if (!env.DB) {
        return json16({ success: false, message: "Database not available" }, 500);
      }
      try {
        let customer = null;
        if (customerId) {
          customer = await env.DB.prepare(`
        SELECT id, email, name, is_premium, extension_activated, total_spent 
        FROM customers WHERE id = ?
      `).bind(parseInt(customerId)).first();
        } else if (customerEmail) {
          customer = await env.DB.prepare(`
        SELECT id, email, name, is_premium, extension_activated, total_spent 
        FROM customers WHERE email = ?
      `).bind(customerEmail).first();
        }
        if (!customer) {
          return json16({ success: false, downloadEnabled: false, message: "Customer not found" });
        }
        const hasAccess = customer.is_premium && customer.extension_activated;
        return json16({
          success: true,
          downloadEnabled: hasAccess,
          customer: {
            id: customer.id,
            email: customer.email,
            name: customer.name,
            totalSpent: customer.total_spent,
            isPremium: customer.is_premium,
            extensionActivated: customer.extension_activated
          }
        });
      } catch (error) {
        console.error("Download status check error:", error);
        return json16({ success: false, downloadEnabled: false, error: error.message }, 500);
      }
    }, "onRequestGet");
    onRequestOptions52 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/init-db.ts
var onRequestGet53, onRequestOptions53;
var init_init_db = __esm({
  "api/init-db.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet53 = /* @__PURE__ */ __name(async ({ env }) => {
      try {
        if (!env.DB) {
          return new Response(JSON.stringify({
            success: false,
            message: "Database not available"
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        await env.DB.prepare(`
      CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        name TEXT NOT NULL,
        role TEXT DEFAULT 'customer',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `).run();
        await env.DB.prepare(`
      CREATE TABLE IF NOT EXISTS customers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT UNIQUE NOT NULL,
        name TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        is_premium BOOLEAN DEFAULT 0,
        extension_activated BOOLEAN DEFAULT 0,
        total_spent DECIMAL(10,2) DEFAULT 0,
        total_orders INTEGER DEFAULT 0
      )
    `).run();
        await env.DB.prepare(`
      CREATE TABLE IF NOT EXISTS invoices (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        invoice_number TEXT UNIQUE NOT NULL,
        customer_id INTEGER NOT NULL,
        customer_name TEXT NOT NULL,
        customer_email TEXT NOT NULL,
        invoice_date TEXT NOT NULL,
        due_date TEXT NOT NULL,
        subtotal TEXT NOT NULL,
        total_amount TEXT NOT NULL,
        currency TEXT DEFAULT 'USD',
        status TEXT DEFAULT 'pending',
        paid_at DATETIME,
        notes TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `).run();
        await env.DB.prepare(`
      CREATE TABLE IF NOT EXISTS orders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        customer_id INTEGER NOT NULL,
        product_name TEXT NOT NULL,
        amount DECIMAL(10,2) NOT NULL,
        status TEXT DEFAULT 'completed',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `).run();
        const now = (/* @__PURE__ */ new Date()).toISOString();
        await env.DB.prepare(`
      INSERT OR REPLACE INTO users (id, email, password, name, role, created_at)
      VALUES (1, 'demo@example.com', 'demo123', 'Demo User', 'customer', ?)
    `).bind(now).run();
        await env.DB.prepare(`
      INSERT OR REPLACE INTO customers (id, email, name, created_at, is_premium, extension_activated, total_spent, total_orders)
      VALUES (1, 'demo@example.com', 'Demo User', ?, 1, 1, 29.99, 1)
    `).bind(now).run();
        await env.DB.prepare(`
      INSERT OR REPLACE INTO invoices (id, invoice_number, customer_id, customer_name, customer_email, invoice_date, due_date, subtotal, total_amount, currency, status, paid_at, notes, created_at)
      VALUES (1, 'INV-2025-000001', 1, 'Demo User', 'demo@example.com', '2025-08-25', '2025-08-25', '29.99', '29.99', 'USD', 'paid', ?, 'Premium extension purchase', ?)
    `).bind(now, now).run();
        await env.DB.prepare(`
      INSERT OR REPLACE INTO orders (id, customer_id, product_name, amount, status, created_at)
      VALUES (1, 1, 'Premium Extension', 29.99, 'completed', ?)
    `).bind(now).run();
        const userCount = await env.DB.prepare("SELECT COUNT(*) as count FROM users").first();
        const customerCount = await env.DB.prepare("SELECT COUNT(*) as count FROM customers").first();
        const invoiceCount = await env.DB.prepare("SELECT COUNT(*) as count FROM invoices").first();
        const orderCount = await env.DB.prepare("SELECT COUNT(*) as count FROM orders").first();
        return new Response(JSON.stringify({
          success: true,
          message: "Database initialized successfully",
          tables: {
            users: userCount?.count || 0,
            customers: customerCount?.count || 0,
            invoices: invoiceCount?.count || 0,
            orders: orderCount?.count || 0
          }
        }), {
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      } catch (error) {
        console.error("Database initialization error:", error);
        return new Response(JSON.stringify({
          success: false,
          message: "Database initialization failed: " + error.message
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestGet");
    onRequestOptions53 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
  }
});

// api/invoice-settings.ts
function getSettingsStore() {
  const g = globalThis;
  if (!g.__INVOICE_SETTINGS__) {
    g.__INVOICE_SETTINGS__ = {
      id: 1,
      companyName: "OCUS Job Hunter",
      companyAddress: "",
      companyPhone: "",
      companyEmail: "",
      companyWebsite: "",
      taxNumber: "",
      invoicePrefix: "INV",
      receiptPrefix: "REC",
      invoiceNotes: "",
      termsAndConditions: "",
      footerText: "Thank you for your business!",
      primaryColor: "#007bff",
      secondaryColor: "#6c757d",
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  return g.__INVOICE_SETTINGS__;
}
function json17(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var onRequestGet54, onRequestPut16, onRequestOptions54;
var init_invoice_settings = __esm({
  "api/invoice-settings.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(getSettingsStore, "getSettingsStore");
    __name(json17, "json");
    onRequestGet54 = /* @__PURE__ */ __name(async () => {
      const settings3 = getSettingsStore();
      const ui = {
        id: settings3.id,
        companyName: settings3.companyName,
        companyAddress: settings3.companyAddress,
        companyPhone: settings3.companyPhone,
        companyEmail: settings3.companyEmail,
        companyWebsite: settings3.companyWebsite,
        taxNumber: settings3.taxNumber,
        invoicePrefix: settings3.invoicePrefix,
        receiptPrefix: settings3.receiptPrefix,
        invoiceNotes: settings3.invoiceNotes,
        termsAndConditions: settings3.termsAndConditions,
        footerText: settings3.footerText,
        primaryColor: settings3.primaryColor,
        secondaryColor: settings3.secondaryColor
      };
      return json17(ui);
    }, "onRequestGet");
    onRequestPut16 = /* @__PURE__ */ __name(async ({ request }) => {
      try {
        const body = await request.json().catch(() => ({}));
        const store = getSettingsStore();
        const allowedKeys = [
          "companyName",
          "companyAddress",
          "companyPhone",
          "companyEmail",
          "companyWebsite",
          "taxNumber",
          "invoicePrefix",
          "receiptPrefix",
          "invoiceNotes",
          "termsAndConditions",
          "footerText",
          "primaryColor",
          "secondaryColor"
        ];
        for (const k of allowedKeys) {
          if (k in body) store[k] = body[k];
        }
        store.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
        return json17({ ...store });
      } catch (e) {
        return json17({ success: false, message: "Failed to update settings" }, 500);
      }
    }, "onRequestPut");
    onRequestOptions54 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, PUT, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// api/invoices.ts
function json18(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
var onRequestGet55;
var init_invoices4 = __esm({
  "api/invoices.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json18, "json");
    onRequestGet55 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const authHeader = request.headers.get("Authorization");
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          return json18([]);
        }
        const token = authHeader.substring(7);
        if (token === "demo-jwt-token") {
          const demoInvoice = {
            id: 1,
            invoiceNumber: "INV-2025-000001",
            customerId: 1,
            customerName: "Demo User",
            customerEmail: "demo@example.com",
            invoiceDate: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
            dueDate: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
            subtotal: "29.99",
            totalAmount: "29.99",
            currency: "USD",
            status: "paid",
            paidAt: (/* @__PURE__ */ new Date()).toISOString(),
            notes: "Premium extension purchase"
          };
          return json18([demoInvoice]);
        }
        if (token.startsWith("jwt-token-")) {
          const parts = token.split("-");
          if (parts.length < 3) {
            return json18([]);
          }
          const userEmail = parts[2];
          if (!env.DB) {
            return json18({ error: "Database not available" }, 500);
          }
          try {
            const query = `
          SELECT 
            i.id,
            i.invoice_number,
            i.order_id,
            i.customer_name,
            i.customer_email,
            i.invoice_date,
            i.due_date,
            i.subtotal,
            i.tax_amount,
            i.discount_amount,
            i.total_amount,
            i.currency,
            i.status,
            i.paid_at,
            i.notes,
            i.created_at,
            i.updated_at,
            o.payment_method
          FROM invoices i
          LEFT JOIN orders o ON o.id = i.order_id
          WHERE i.customer_email = ?
          ORDER BY i.created_at DESC
        `;
            const result = await env.DB.prepare(query).bind(userEmail).all();
            const rows = result.results || [];
            const invoices2 = rows.map((r) => ({
              id: r.id,
              invoiceNumber: r.invoice_number,
              orderId: r.order_id,
              customerName: r.customer_name,
              customerEmail: r.customer_email,
              invoiceDate: r.invoice_date,
              dueDate: r.due_date,
              subtotal: r.subtotal,
              taxAmount: r.tax_amount,
              discountAmount: r.discount_amount,
              totalAmount: r.total_amount,
              currency: r.currency,
              status: r.status,
              paidAt: r.paid_at,
              notes: r.notes,
              createdAt: r.created_at,
              updatedAt: r.updated_at,
              paymentMethod: r.payment_method
            }));
            return json18(invoices2);
          } catch (dbError) {
            console.error("DB error in /api/invoices:", dbError);
            return json18([]);
          }
        }
        return json18([]);
      } catch (error) {
        return json18({
          error: error.message
        }, 500);
      }
    }, "onRequestGet");
  }
});

// api/me.ts
function json19(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
var onRequestGet56;
var init_me = __esm({
  "api/me.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json19, "json");
    onRequestGet56 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const authHeader = request.headers.get("Authorization");
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          return json19({
            error: "Unauthorized"
          }, 401);
        }
        const token = authHeader.substring(7);
        if (token === "demo-jwt-token") {
          return json19({
            id: 1,
            email: "demo@example.com",
            name: "Demo User",
            role: "customer",
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            isPremium: true,
            extensionActivated: true,
            totalSpent: 29.99,
            totalOrders: 1,
            isAuthenticated: true
          });
        }
        if (token.startsWith("jwt-token-")) {
          const parts = token.split("-");
          if (parts.length >= 3) {
            const userId = parts[2];
            console.log("Parsed userId from token:", userId, "from token:", token);
            if (!env.DB) {
              return json19({ error: "Database not available" }, 500);
            }
            try {
              const session = env.DB.withSession("first-primary");
              console.log("Token parts:", parts);
              const userEmail = parts[2];
              const user = await session.prepare(`
            SELECT id, email, name, role, created_at, is_premium, extension_activated, 
                   premium_activated_at, total_spent, total_orders
            FROM users WHERE email = ?
          `).bind(userEmail).first();
              console.log("User lookup result:", user);
              if (user) {
                let cust = null;
                try {
                  cust = await session.prepare(`
                SELECT subscription_status, extension_activated
                FROM customers WHERE email = ?
              `).bind(userEmail).first();
                } catch (e) {
                  console.error("Customer lookup for user failed:", e);
                }
                const customerIsPremium = cust ? String(cust.subscription_status || "").toLowerCase() === "active" || Boolean(cust.extension_activated) : false;
                const computedIsPremium = Boolean(user.is_premium) || customerIsPremium;
                const computedExtensionActivated = Boolean(user.extension_activated) || Boolean(cust?.extension_activated);
                return json19({
                  id: user.id,
                  email: user.email,
                  name: user.name,
                  role: user.role || "customer",
                  createdAt: user.created_at,
                  isPremium: computedIsPremium,
                  extensionActivated: computedExtensionActivated,
                  premiumActivatedAt: user.premium_activated_at,
                  totalSpent: parseFloat(String(user.total_spent || "0")),
                  totalOrders: parseInt(String(user.total_orders || "0")),
                  isAuthenticated: true
                });
              }
              const customer = await session.prepare(`
            SELECT id, email, name, subscription_status, extension_activated, created_at,
                   total_spent, total_orders
            FROM customers WHERE email = ?
          `).bind(userEmail).first();
              console.log("Customer lookup result:", customer);
              if (customer) {
                return json19({
                  id: customer.id,
                  email: customer.email,
                  name: customer.name,
                  role: "customer",
                  createdAt: customer.created_at,
                  isPremium: String(customer.subscription_status || "").toLowerCase() === "active" || Boolean(customer.extension_activated),
                  extensionActivated: Boolean(customer.extension_activated),
                  totalSpent: parseFloat(String(customer.total_spent || "0")),
                  totalOrders: parseInt(String(customer.total_orders || "0")),
                  isAuthenticated: true
                });
              }
              const userSettingsKey = `user_${userEmail.replace("@", "_at_").replace(".", "_dot_")}`;
              const userSetting = await session.prepare(`
            SELECT value FROM settings WHERE key = ?
          `).bind(userSettingsKey).first();
              console.log("User setting lookup result:", userSetting);
              if (userSetting && typeof userSetting.value === "string") {
                try {
                  const userData = JSON.parse(userSetting.value);
                  if (userData.isPremium) {
                    return json19({
                      id: userData.id || userEmail,
                      // Fallback id
                      email: userData.email,
                      name: userData.name,
                      role: "customer",
                      createdAt: userData.updatedAt,
                      // Use updatedAt as a proxy for creation
                      isPremium: true,
                      extensionActivated: true,
                      // Assume activated if premium
                      totalSpent: 0,
                      // Not tracked in this fallback
                      totalOrders: 0,
                      // Not tracked in this fallback
                      isAuthenticated: true
                    });
                  }
                } catch (parseError) {
                  console.error("Failed to parse user data from settings:", parseError);
                }
              }
            } catch (dbError) {
              console.error("Database error in /api/me:", dbError);
            }
          }
        }
        return json19({
          error: "Invalid token"
        }, 401);
      } catch (error) {
        return json19({
          error: error.message
        }, 500);
      }
    }, "onRequestGet");
  }
});

// api/migrate-db.ts
function json20(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var onRequestGet57, onRequestOptions55;
var init_migrate_db = __esm({
  "api/migrate-db.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json20, "json");
    onRequestGet57 = /* @__PURE__ */ __name(async ({ env }) => {
      if (!env.DB) {
        return json20({ success: false, message: "Database not available" }, 500);
      }
      try {
        const alterStmt = `ALTER TABLE tickets ADD COLUMN customer_id INTEGER;`;
        await env.DB.prepare(alterStmt).run();
        const backfillStmt = `
      UPDATE tickets
      SET customer_id = (SELECT id FROM customers WHERE email = tickets.customer_email)
      WHERE customer_id IS NULL;
    `;
        const backfillResult = await env.DB.prepare(backfillStmt).run();
        return json20({
          success: true,
          message: "Database migration successful: customer_id added and backfilled.",
          backfillDetails: backfillResult.meta
        });
      } catch (e) {
        if (e.message.includes("duplicate column name")) {
          return json20({
            success: true,
            message: "Migration not needed: customer_id column already exists."
          });
        }
        console.error("Migration failed:", e);
        return json20({ success: false, message: e.message }, 500);
      }
    }, "onRequestGet");
    onRequestOptions55 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
  }
});

// api/purchase-complete.ts
function json21(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var onRequestPost25, onRequestOptions56;
var init_purchase_complete = __esm({
  "api/purchase-complete.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json21, "json");
    onRequestPost25 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const body = await request.json();
        const {
          paymentIntentId,
          customerEmail,
          customerName,
          customerId,
          amount,
          currency = "USD",
          productType = "premium_extension"
        } = body;
        if (!paymentIntentId || !customerEmail || !amount) {
          return json21({ success: false, message: "Missing required fields" }, 400);
        }
        if (!env.DB) {
          console.error("D1 database not available");
          return json21({ success: false, message: "Database not available" }, 500);
        }
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const nowDate = /* @__PURE__ */ new Date();
        try {
          let finalCustomerId = customerId;
          if (customerEmail) {
            const userUpdateResult = await env.DB.prepare(`
          UPDATE users 
          SET is_premium = 1,
              extension_activated = 1,
              premium_activated_at = ?,
              total_spent = COALESCE(total_spent, 0) + ?,
              total_orders = COALESCE(total_orders, 0) + 1
          WHERE email = ?
        `).bind(now, amount, customerEmail).run();
            console.log("User table update result for", customerEmail, ":", userUpdateResult);
            if (userUpdateResult.meta?.changes === 0) {
              console.log("No user found with email", customerEmail, "in users table");
            }
          }
          if (customerId) {
            await env.DB.prepare(`
          UPDATE customers 
          SET is_premium = 1,
              extension_activated = 1,
              total_spent = COALESCE(total_spent, 0) + ?,
              total_orders = COALESCE(total_orders, 0) + 1,
              updated_at = ?
          WHERE id = ?
        `).bind(amount, now, customerId).run();
          } else {
            const existingCustomer = await env.DB.prepare(`
          SELECT id FROM customers WHERE email = ?
        `).bind(customerEmail).first();
            if (existingCustomer) {
              finalCustomerId = existingCustomer.id;
              await env.DB.prepare(`
            UPDATE customers 
            SET is_premium = 1,
                extension_activated = 1,
                updated_at = ?
            WHERE id = ?
          `).bind(now, finalCustomerId).run();
            } else {
              const result = await env.DB.prepare(`
            INSERT INTO customers (
              email, name, is_premium, extension_activated, 
              created_at, updated_at
            ) VALUES (?, ?, 1, 1, ?, ?)
          `).bind(
                customerEmail,
                customerName || customerEmail,
                now,
                now
              ).run();
              finalCustomerId = result.meta?.last_row_id;
            }
          }
          if (!finalCustomerId) {
            const existingCustomer = await env.DB.prepare(`
          SELECT id FROM customers WHERE email = ?
        `).bind(customerEmail).first();
            if (existingCustomer) {
              finalCustomerId = existingCustomer.id;
              await env.DB.prepare(`
            UPDATE customers 
            SET is_premium = 1,
                extension_activated = 1,
                total_spent = COALESCE(total_spent, 0) + ?,
                total_orders = COALESCE(total_orders, 0) + 1,
                updated_at = ?
            WHERE id = ?
          `).bind(amount, now, finalCustomerId).run();
            } else {
              const result = await env.DB.prepare(`
            INSERT INTO customers (
              email, name, is_premium, extension_activated, 
              total_spent, total_orders, created_at, updated_at
            ) VALUES (?, ?, 1, 1, ?, 1, ?, ?)
          `).bind(
                customerEmail,
                customerName || customerEmail,
                amount,
                now,
                now
              ).run();
              finalCustomerId = result.meta?.last_row_id;
            }
          }
          console.log("Final customer ID for orders/invoices:", finalCustomerId);
          const downloadToken = `download_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          const orderResult = await env.DB.prepare(`
        INSERT INTO orders (
          customer_id, customer_email, customer_name, 
          original_amount, final_amount, currency, status, payment_method,
          payment_intent_id, download_token, created_at, completed_at
        ) VALUES (?, ?, ?, ?, ?, ?, 'completed', 'stripe', ?, ?, ?, ?)
      `).bind(
            finalCustomerId,
            customerEmail,
            customerName || customerEmail,
            amount,
            amount,
            currency.toLowerCase(),
            paymentIntentId,
            downloadToken,
            now,
            now
          ).run();
          const orderId = orderResult.meta?.last_row_id;
          const activationCode = `OCUS_${Date.now()}_${Math.random().toString(36).substr(2, 9).toUpperCase()}`;
          await env.DB.prepare(`
        INSERT INTO activation_codes (
          code, order_id, created_at
        ) VALUES (?, ?, ?)
      `).bind(activationCode, orderId, now).run();
          const invoiceNumber = `INV-${Date.now()}-${Math.random().toString(36).substr(2, 6).toUpperCase()}`;
          const invoiceDate = nowDate;
          const dueDate = new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3);
          const invoiceResult = await env.DB.prepare(`
        INSERT INTO invoices (
          invoice_number, order_id, customer_id, customer_name, customer_email,
          invoice_date, due_date, subtotal, tax_amount, discount_amount, 
          total_amount, currency, status, paid_at, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0.00, 0.00, ?, ?, 'paid', ?, ?, ?)
      `).bind(
            invoiceNumber,
            orderId,
            finalCustomerId,
            customerName || customerEmail,
            customerEmail,
            invoiceDate.toISOString(),
            dueDate.toISOString(),
            amount,
            amount,
            "USD",
            invoiceDate.toISOString(),
            invoiceDate.toISOString(),
            invoiceDate.toISOString()
          ).run();
          const invoiceId = invoiceResult.meta?.last_row_id;
          await env.DB.prepare(`
        INSERT INTO invoice_items (
          invoice_id, product_name, description, quantity, unit_price, total_price, created_at
        ) VALUES (?, ?, ?, 1, ?, ?, ?)
      `).bind(
            invoiceId,
            "OCUS Job Hunter Premium",
            "Premium access to OCUS Job Hunter extension with unlimited job applications",
            amount,
            amount,
            invoiceDate.toISOString()
          ).run();
          console.log("Invoice created successfully:", { invoiceId, invoiceNumber });
          console.log("Purchase completed successfully:", {
            customerId: finalCustomerId,
            orderId,
            paymentIntentId,
            amount,
            activationCode
          });
          return json21({
            success: true,
            message: "Purchase completed successfully",
            data: {
              customerId: finalCustomerId,
              orderId,
              activationCode,
              downloadEnabled: true
            }
          });
        } catch (dbError) {
          console.error("Database error during purchase completion:", dbError);
          return json21({
            success: false,
            message: "Failed to process purchase completion",
            error: dbError.message
          }, 500);
        }
      } catch (error) {
        console.error("Purchase completion error:", error);
        return json21({
          success: false,
          message: "Internal server error",
          error: error.message
        }, 500);
      }
    }, "onRequestPost");
    onRequestOptions56 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
  }
});

// ../node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "../node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = Object;
  }
});

// ../node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "../node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = Error;
  }
});

// ../node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "../node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = EvalError;
  }
});

// ../node_modules/es-errors/range.js
var require_range = __commonJS({
  "../node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = RangeError;
  }
});

// ../node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "../node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = ReferenceError;
  }
});

// ../node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "../node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = SyntaxError;
  }
});

// ../node_modules/es-errors/type.js
var require_type = __commonJS({
  "../node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = TypeError;
  }
});

// ../node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "../node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = URIError;
  }
});

// ../node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "../node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = Math.abs;
  }
});

// ../node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "../node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = Math.floor;
  }
});

// ../node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "../node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = Math.max;
  }
});

// ../node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "../node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = Math.min;
  }
});

// ../node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "../node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = Math.pow;
  }
});

// ../node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "../node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = Math.round;
  }
});

// ../node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "../node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = Number.isNaN || /* @__PURE__ */ __name(function isNaN2(a) {
      return a !== a;
    }, "isNaN");
  }
});

// ../node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "../node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var $isNaN = require_isNaN();
    module.exports = /* @__PURE__ */ __name(function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    }, "sign");
  }
});

// ../node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "../node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// ../node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../node_modules/gopd/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// ../node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "../node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// ../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = /* @__PURE__ */ __name(function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    }, "hasSymbols");
  }
});

// ../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = /* @__PURE__ */ __name(function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    }, "hasNativeSymbols");
  }
});

// ../node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "../node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// ../node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "../node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// ../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = /* @__PURE__ */ __name(function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    }, "concatty");
    var slicy = /* @__PURE__ */ __name(function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    }, "slicy");
    var joiny = /* @__PURE__ */ __name(function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    }, "joiny");
    module.exports = /* @__PURE__ */ __name(function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = /* @__PURE__ */ __name(function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      }, "binder");
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = /* @__PURE__ */ __name(function Empty2() {
        }, "Empty");
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    }, "bind");
  }
});

// ../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// ../node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "../node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = Function.prototype.call;
  }
});

// ../node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "../node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = Function.prototype.apply;
  }
});

// ../node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "../node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// ../node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "../node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// ../node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "../node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = /* @__PURE__ */ __name(function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    }, "callBindBasic");
  }
});

// ../node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "../node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc2 = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc2 && typeof desc2.get === "function" ? callBind([desc2.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      /* @__PURE__ */ __name(function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }, "getDunder")
    ) : false;
  }
});

// ../node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "../node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? /* @__PURE__ */ __name(function getProto(O) {
      return reflectGetProto(O);
    }, "getProto") : originalGetProto ? /* @__PURE__ */ __name(function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    }, "getProto") : getDunderProto ? /* @__PURE__ */ __name(function getProto(O) {
      return getDunderProto(O);
    }, "getProto") : null;
  }
});

// ../node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../node_modules/hasown/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// ../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = /* @__PURE__ */ __name(function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    }, "getEvalledConstructor");
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = /* @__PURE__ */ __name(function() {
      throw new $TypeError();
    }, "throwTypeError");
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = /* @__PURE__ */ __name(function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    }, "doEval");
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = /* @__PURE__ */ __name(function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match2, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
      });
      return result;
    }, "stringToPath");
    var getBaseIntrinsic = /* @__PURE__ */ __name(function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    }, "getBaseIntrinsic");
    module.exports = /* @__PURE__ */ __name(function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc2 = $gOPD(value, part);
            isOwn = !!desc2;
            if (isOwn && "get" in desc2 && !("originalValue" in desc2.get)) {
              value = desc2.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    }, "GetIntrinsic");
  }
});

// ../node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "../node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = /* @__PURE__ */ __name(function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc2 = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc2 ? desc2.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc2 ? desc2.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc2 ? desc2.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    }, "defineDataProperty");
  }
});

// ../node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "../node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = /* @__PURE__ */ __name(function hasPropertyDescriptors2() {
      return !!$defineProperty;
    }, "hasPropertyDescriptors");
    hasPropertyDescriptors.hasArrayLengthDefineBug = /* @__PURE__ */ __name(function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    }, "hasArrayLengthDefineBug");
    module.exports = hasPropertyDescriptors;
  }
});

// ../node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "../node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var GetIntrinsic = require_get_intrinsic();
    var define = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = /* @__PURE__ */ __name(function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc2 = gOPD(fn, "length");
        if (desc2 && !desc2.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc2 && !desc2.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    }, "setFunctionLength");
  }
});

// ../node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = require_type();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = require_es_define_property();
    var $max = GetIntrinsic("%Math.max%");
    module.exports = /* @__PURE__ */ __name(function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    }, "callBind");
    var applyBind = /* @__PURE__ */ __name(function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    }, "applyBind");
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// ../node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = /* @__PURE__ */ __name(function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    }, "callBoundIntrinsic");
  }
});

// (disabled):../node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):../node_modules/object-inspect/util.inspect"() {
    init_functionsRoutes_0_8044054200943971();
  }
});

// ../node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../node_modules/object-inspect/index.js"(exports, module) {
    init_functionsRoutes_0_8044054200943971();
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    __name(addNumericSeparator, "addNumericSeparator");
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module.exports = /* @__PURE__ */ __name(function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      __name(inspect, "inspect");
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    }, "inspect_");
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    __name(wrapQuotes, "wrapQuotes");
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    __name(quote, "quote");
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isArray, "isArray");
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isDate, "isDate");
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isRegExp, "isRegExp");
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isError, "isError");
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isString, "isString");
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isNumber, "isNumber");
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isBoolean, "isBoolean");
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isSymbol, "isSymbol");
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isBigInt, "isBigInt");
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    __name(has, "has");
    function toStr(obj) {
      return objectToString.call(obj);
    }
    __name(toStr, "toStr");
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    __name(nameOf, "nameOf");
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    __name(indexOf, "indexOf");
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    __name(isMap, "isMap");
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    __name(isWeakMap, "isWeakMap");
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isWeakRef, "isWeakRef");
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    __name(isSet, "isSet");
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    __name(isWeakSet, "isWeakSet");
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    __name(isElement, "isElement");
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    __name(inspectString, "inspectString");
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    __name(lowbyte, "lowbyte");
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    __name(markBoxed, "markBoxed");
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    __name(weakCollectionOf, "weakCollectionOf");
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    __name(collectionOf, "collectionOf");
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    __name(singleLineValues, "singleLineValues");
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    __name(getIndent, "getIndent");
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    __name(indentedJoin, "indentedJoin");
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
    __name(arrObjKeys, "arrObjKeys");
  }
});

// ../node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = /* @__PURE__ */ __name(function(list, key) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
          return curr;
        }
      }
    }, "listGetNode");
    var listGet = /* @__PURE__ */ __name(function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    }, "listGet");
    var listSet = /* @__PURE__ */ __name(function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('.').ListNode<typeof value>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    }, "listSet");
    var listHas = /* @__PURE__ */ __name(function(objects, key) {
      return !!listGetNode(objects, key);
    }, "listHas");
    module.exports = /* @__PURE__ */ __name(function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: /* @__PURE__ */ __name(function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        }, "assert"),
        get: /* @__PURE__ */ __name(function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        }, "get"),
        has: /* @__PURE__ */ __name(function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        }, "has"),
        set: /* @__PURE__ */ __name(function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }, "set")
      };
      return channel;
    }, "getSideChannel");
  }
});

// ../node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "../node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: /* @__PURE__ */ __name(function(value) {
          return replace.call(value, percentTwenties, "+");
        }, "RFC1738"),
        RFC3986: /* @__PURE__ */ __name(function(value) {
          return String(value);
        }, "RFC3986")
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// ../node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "../node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = /* @__PURE__ */ __name(function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    }, "compactQueue");
    var arrayToObject = /* @__PURE__ */ __name(function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    }, "arrayToObject");
    var merge = /* @__PURE__ */ __name(function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    }, "merge");
    var assign = /* @__PURE__ */ __name(function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    }, "assignSingleSource");
    var decode = /* @__PURE__ */ __name(function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    }, "decode");
    var limit = 1024;
    var encode = /* @__PURE__ */ __name(function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    }, "encode");
    var compact = /* @__PURE__ */ __name(function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    }, "compact");
    var isRegExp = /* @__PURE__ */ __name(function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    }, "isRegExp");
    var isBuffer = /* @__PURE__ */ __name(function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    }, "isBuffer");
    var combine = /* @__PURE__ */ __name(function combine2(a, b) {
      return [].concat(a, b);
    }, "combine");
    var maybeMap = /* @__PURE__ */ __name(function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    }, "maybeMap");
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// ../node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "../node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: /* @__PURE__ */ __name(function brackets(prefix) {
        return prefix + "[]";
      }, "brackets"),
      comma: "comma",
      indices: /* @__PURE__ */ __name(function indices(prefix, key) {
        return prefix + "[" + key + "]";
      }, "indices"),
      repeat: /* @__PURE__ */ __name(function repeat(prefix) {
        return prefix;
      }, "repeat")
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = /* @__PURE__ */ __name(function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    }, "pushToArray");
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: /* @__PURE__ */ __name(function serializeDate(date) {
        return toISO.call(date);
      }, "serializeDate"),
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = /* @__PURE__ */ __name(function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    }, "isNonNullishPrimitive");
    var sentinel = {};
    var stringify2 = /* @__PURE__ */ __name(function stringify3(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, "%2E") : prefix;
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify3(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    }, "stringify");
    var normalizeStringifyOptions = /* @__PURE__ */ __name(function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    }, "normalizeStringifyOptions");
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify2(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// ../node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "../node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = /* @__PURE__ */ __name(function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    }, "interpretNumericEntities");
    var parseArrayValue = /* @__PURE__ */ __name(function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    }, "parseArrayValue");
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = /* @__PURE__ */ __name(function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    }, "parseQueryStringValues");
    var parseObject = /* @__PURE__ */ __name(function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    }, "parseObject");
    var parseKeys = /* @__PURE__ */ __name(function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
        }
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    }, "parseQueryStringKeys");
    var normalizeParseOptions = /* @__PURE__ */ __name(function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    }, "normalizeParseOptions");
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// ../node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "../node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    var stringify2 = require_stringify();
    var parse2 = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse: parse2,
      stringify: stringify2
    };
  }
});

// ../node_modules/stripe/esm/utils.js
function isOptionsHash(o) {
  return o && typeof o === "object" && OPTIONS_KEYS.some((prop) => Object.prototype.hasOwnProperty.call(o, prop));
}
function queryStringifyRequestData(data, apiMode) {
  return qs.stringify(data, {
    serializeDate: /* @__PURE__ */ __name((d) => Math.floor(d.getTime() / 1e3).toString(), "serializeDate"),
    arrayFormat: apiMode == "v2" ? "repeat" : "indices"
  }).replace(/%5B/g, "[").replace(/%5D/g, "]");
}
function isValidEncodeUriComponentType(value) {
  return ["number", "string", "boolean"].includes(typeof value);
}
function extractUrlParams(path) {
  const params = path.match(/\{\w+\}/g);
  if (!params) {
    return [];
  }
  return params.map((param) => param.replace(/[{}]/g, ""));
}
function getDataFromArgs(args) {
  if (!Array.isArray(args) || !args[0] || typeof args[0] !== "object") {
    return {};
  }
  if (!isOptionsHash(args[0])) {
    return args.shift();
  }
  const argKeys = Object.keys(args[0]);
  const optionKeysInArgs = argKeys.filter((key) => OPTIONS_KEYS.includes(key));
  if (optionKeysInArgs.length > 0 && optionKeysInArgs.length !== argKeys.length) {
    emitWarning(`Options found in arguments (${optionKeysInArgs.join(", ")}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options.`);
  }
  return {};
}
function getOptionsFromArgs(args) {
  const opts = {
    host: null,
    headers: {},
    settings: {},
    streaming: false
  };
  if (args.length > 0) {
    const arg = args[args.length - 1];
    if (typeof arg === "string") {
      opts.authenticator = createApiKeyAuthenticator(args.pop());
    } else if (isOptionsHash(arg)) {
      const params = Object.assign({}, args.pop());
      const extraKeys = Object.keys(params).filter((key) => !OPTIONS_KEYS.includes(key));
      if (extraKeys.length) {
        emitWarning(`Invalid options found (${extraKeys.join(", ")}); ignoring.`);
      }
      if (params.apiKey) {
        opts.authenticator = createApiKeyAuthenticator(params.apiKey);
      }
      if (params.idempotencyKey) {
        opts.headers["Idempotency-Key"] = params.idempotencyKey;
      }
      if (params.stripeAccount) {
        opts.headers["Stripe-Account"] = params.stripeAccount;
      }
      if (params.stripeContext) {
        if (opts.headers["Stripe-Account"]) {
          throw new Error("Can't specify both stripeAccount and stripeContext.");
        }
        opts.headers["Stripe-Context"] = params.stripeContext;
      }
      if (params.apiVersion) {
        opts.headers["Stripe-Version"] = params.apiVersion;
      }
      if (Number.isInteger(params.maxNetworkRetries)) {
        opts.settings.maxNetworkRetries = params.maxNetworkRetries;
      }
      if (Number.isInteger(params.timeout)) {
        opts.settings.timeout = params.timeout;
      }
      if (params.host) {
        opts.host = params.host;
      }
      if (params.authenticator) {
        if (params.apiKey) {
          throw new Error("Can't specify both apiKey and authenticator.");
        }
        if (typeof params.authenticator !== "function") {
          throw new Error("The authenticator must be a function receiving a request as the first parameter.");
        }
        opts.authenticator = params.authenticator;
      }
      if (params.additionalHeaders) {
        opts.headers = params.additionalHeaders;
      }
      if (params.streaming) {
        opts.streaming = true;
      }
    }
  }
  return opts;
}
function protoExtend(sub) {
  const Super = this;
  const Constructor = Object.prototype.hasOwnProperty.call(sub, "constructor") ? sub.constructor : function(...args) {
    Super.apply(this, args);
  };
  Object.assign(Constructor, Super);
  Constructor.prototype = Object.create(Super.prototype);
  Object.assign(Constructor.prototype, sub);
  return Constructor;
}
function removeNullish(obj) {
  if (typeof obj !== "object") {
    throw new Error("Argument must be an object");
  }
  return Object.keys(obj).reduce((result, key) => {
    if (obj[key] != null) {
      result[key] = obj[key];
    }
    return result;
  }, {});
}
function normalizeHeaders(obj) {
  if (!(obj && typeof obj === "object")) {
    return obj;
  }
  return Object.keys(obj).reduce((result, header) => {
    result[normalizeHeader(header)] = obj[header];
    return result;
  }, {});
}
function normalizeHeader(header) {
  return header.split("-").map((text2) => text2.charAt(0).toUpperCase() + text2.substr(1).toLowerCase()).join("-");
}
function callbackifyPromiseWithTimeout(promise, callback) {
  if (callback) {
    return promise.then((res) => {
      setTimeout(() => {
        callback(null, res);
      }, 0);
    }, (err) => {
      setTimeout(() => {
        callback(err, null);
      }, 0);
    });
  }
  return promise;
}
function pascalToCamelCase(name) {
  if (name === "OAuth") {
    return "oauth";
  } else {
    return name[0].toLowerCase() + name.substring(1);
  }
}
function emitWarning(warning) {
  if (typeof process.emitWarning !== "function") {
    return console.warn(`Stripe: ${warning}`);
  }
  return process.emitWarning(warning, "Stripe");
}
function isObject(obj) {
  const type = typeof obj;
  return (type === "function" || type === "object") && !!obj;
}
function flattenAndStringify(data) {
  const result = {};
  const step = /* @__PURE__ */ __name((obj, prevKey) => {
    Object.entries(obj).forEach(([key, value]) => {
      const newKey = prevKey ? `${prevKey}[${key}]` : key;
      if (isObject(value)) {
        if (!(value instanceof Uint8Array) && !Object.prototype.hasOwnProperty.call(value, "data")) {
          return step(value, newKey);
        } else {
          result[newKey] = value;
        }
      } else {
        result[newKey] = String(value);
      }
    });
  }, "step");
  step(data, null);
  return result;
}
function validateInteger(name, n, defaultVal) {
  if (!Number.isInteger(n)) {
    if (defaultVal !== void 0) {
      return defaultVal;
    } else {
      throw new Error(`${name} must be an integer`);
    }
  }
  return n;
}
function determineProcessUserAgentProperties() {
  return typeof process === "undefined" ? {} : {
    lang_version: process.version,
    platform: process.platform
  };
}
function createApiKeyAuthenticator(apiKey) {
  const authenticator = /* @__PURE__ */ __name((request) => {
    request.headers.Authorization = "Bearer " + apiKey;
    return Promise.resolve();
  }, "authenticator");
  authenticator._apiKey = apiKey;
  return authenticator;
}
function dateTimeReplacer(key, value) {
  if (this[key] instanceof Date) {
    return Math.floor(this[key].getTime() / 1e3).toString();
  }
  return value;
}
function jsonStringifyRequestData(data) {
  return JSON.stringify(data, dateTimeReplacer);
}
function getAPIMode(path) {
  if (!path) {
    return "v1";
  }
  return path.startsWith("/v2") ? "v2" : "v1";
}
function parseHttpHeaderAsString(header) {
  if (Array.isArray(header)) {
    return header.join(", ");
  }
  return String(header);
}
function parseHttpHeaderAsNumber(header) {
  const number = Array.isArray(header) ? header[0] : header;
  return Number(number);
}
function parseHeadersForFetch(headers) {
  return Object.entries(headers).map(([key, value]) => {
    return [key, parseHttpHeaderAsString(value)];
  });
}
var qs, OPTIONS_KEYS, makeURLInterpolator;
var init_utils3 = __esm({
  "../node_modules/stripe/esm/utils.js"() {
    init_functionsRoutes_0_8044054200943971();
    qs = __toESM(require_lib(), 1);
    OPTIONS_KEYS = [
      "apiKey",
      "idempotencyKey",
      "stripeAccount",
      "apiVersion",
      "maxNetworkRetries",
      "timeout",
      "host",
      "authenticator",
      "stripeContext",
      "additionalHeaders",
      "streaming"
    ];
    __name(isOptionsHash, "isOptionsHash");
    __name(queryStringifyRequestData, "queryStringifyRequestData");
    makeURLInterpolator = /* @__PURE__ */ (() => {
      const rc = {
        "\n": "\\n",
        '"': '\\"',
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      };
      return (str) => {
        const cleanString = str.replace(/["\n\r\u2028\u2029]/g, ($0) => rc[$0]);
        return (outputs) => {
          return cleanString.replace(/\{([\s\S]+?)\}/g, ($0, $1) => {
            const output = outputs[$1];
            if (isValidEncodeUriComponentType(output))
              return encodeURIComponent(output);
            return "";
          });
        };
      };
    })();
    __name(isValidEncodeUriComponentType, "isValidEncodeUriComponentType");
    __name(extractUrlParams, "extractUrlParams");
    __name(getDataFromArgs, "getDataFromArgs");
    __name(getOptionsFromArgs, "getOptionsFromArgs");
    __name(protoExtend, "protoExtend");
    __name(removeNullish, "removeNullish");
    __name(normalizeHeaders, "normalizeHeaders");
    __name(normalizeHeader, "normalizeHeader");
    __name(callbackifyPromiseWithTimeout, "callbackifyPromiseWithTimeout");
    __name(pascalToCamelCase, "pascalToCamelCase");
    __name(emitWarning, "emitWarning");
    __name(isObject, "isObject");
    __name(flattenAndStringify, "flattenAndStringify");
    __name(validateInteger, "validateInteger");
    __name(determineProcessUserAgentProperties, "determineProcessUserAgentProperties");
    __name(createApiKeyAuthenticator, "createApiKeyAuthenticator");
    __name(dateTimeReplacer, "dateTimeReplacer");
    __name(jsonStringifyRequestData, "jsonStringifyRequestData");
    __name(getAPIMode, "getAPIMode");
    __name(parseHttpHeaderAsString, "parseHttpHeaderAsString");
    __name(parseHttpHeaderAsNumber, "parseHttpHeaderAsNumber");
    __name(parseHeadersForFetch, "parseHeadersForFetch");
  }
});

// ../node_modules/stripe/esm/net/HttpClient.js
var HttpClient, HttpClientResponse;
var init_HttpClient = __esm({
  "../node_modules/stripe/esm/net/HttpClient.js"() {
    init_functionsRoutes_0_8044054200943971();
    HttpClient = class _HttpClient {
      static {
        __name(this, "HttpClient");
      }
      /** The client name used for diagnostics. */
      getClientName() {
        throw new Error("getClientName not implemented.");
      }
      makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
        throw new Error("makeRequest not implemented.");
      }
      /** Helper to make a consistent timeout error across implementations. */
      static makeTimeoutError() {
        const timeoutErr = new TypeError(_HttpClient.TIMEOUT_ERROR_CODE);
        timeoutErr.code = _HttpClient.TIMEOUT_ERROR_CODE;
        return timeoutErr;
      }
    };
    HttpClient.CONNECTION_CLOSED_ERROR_CODES = ["ECONNRESET", "EPIPE"];
    HttpClient.TIMEOUT_ERROR_CODE = "ETIMEDOUT";
    HttpClientResponse = class {
      static {
        __name(this, "HttpClientResponse");
      }
      constructor(statusCode, headers) {
        this._statusCode = statusCode;
        this._headers = headers;
      }
      getStatusCode() {
        return this._statusCode;
      }
      getHeaders() {
        return this._headers;
      }
      getRawResponse() {
        throw new Error("getRawResponse not implemented.");
      }
      toStream(streamCompleteCallback) {
        throw new Error("toStream not implemented.");
      }
      toJSON() {
        throw new Error("toJSON not implemented.");
      }
    };
  }
});

// ../node_modules/stripe/esm/net/FetchHttpClient.js
var FetchHttpClient, FetchHttpClientResponse;
var init_FetchHttpClient = __esm({
  "../node_modules/stripe/esm/net/FetchHttpClient.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_utils3();
    init_HttpClient();
    FetchHttpClient = class _FetchHttpClient extends HttpClient {
      static {
        __name(this, "FetchHttpClient");
      }
      constructor(fetchFn) {
        super();
        if (!fetchFn) {
          if (!globalThis.fetch) {
            throw new Error("fetch() function not provided and is not defined in the global scope. You must provide a fetch implementation.");
          }
          fetchFn = globalThis.fetch;
        }
        if (globalThis.AbortController) {
          this._fetchFn = _FetchHttpClient.makeFetchWithAbortTimeout(fetchFn);
        } else {
          this._fetchFn = _FetchHttpClient.makeFetchWithRaceTimeout(fetchFn);
        }
      }
      static makeFetchWithRaceTimeout(fetchFn) {
        return (url, init, timeout) => {
          let pendingTimeoutId;
          const timeoutPromise = new Promise((_, reject) => {
            pendingTimeoutId = setTimeout(() => {
              pendingTimeoutId = null;
              reject(HttpClient.makeTimeoutError());
            }, timeout);
          });
          const fetchPromise = fetchFn(url, init);
          return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
            if (pendingTimeoutId) {
              clearTimeout(pendingTimeoutId);
            }
          });
        };
      }
      static makeFetchWithAbortTimeout(fetchFn) {
        return async (url, init, timeout) => {
          const abort = new AbortController();
          let timeoutId = setTimeout(() => {
            timeoutId = null;
            abort.abort(HttpClient.makeTimeoutError());
          }, timeout);
          try {
            return await fetchFn(url, Object.assign(Object.assign({}, init), { signal: abort.signal }));
          } catch (err) {
            if (err.name === "AbortError") {
              throw HttpClient.makeTimeoutError();
            } else {
              throw err;
            }
          } finally {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
          }
        };
      }
      /** @override. */
      getClientName() {
        return "fetch";
      }
      async makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
        const isInsecureConnection = protocol === "http";
        const url = new URL(path, `${isInsecureConnection ? "http" : "https"}://${host}`);
        url.port = port;
        const methodHasPayload = method == "POST" || method == "PUT" || method == "PATCH";
        const body = requestData || (methodHasPayload ? "" : void 0);
        const res = await this._fetchFn(url.toString(), {
          method,
          headers: parseHeadersForFetch(headers),
          body: typeof body === "object" ? JSON.stringify(body) : body
        }, timeout);
        return new FetchHttpClientResponse(res);
      }
    };
    FetchHttpClientResponse = class _FetchHttpClientResponse extends HttpClientResponse {
      static {
        __name(this, "FetchHttpClientResponse");
      }
      constructor(res) {
        super(res.status, _FetchHttpClientResponse._transformHeadersToObject(res.headers));
        this._res = res;
      }
      getRawResponse() {
        return this._res;
      }
      toStream(streamCompleteCallback) {
        streamCompleteCallback();
        return this._res.body;
      }
      toJSON() {
        return this._res.json();
      }
      static _transformHeadersToObject(headers) {
        const headersObj = {};
        for (const entry of headers) {
          if (!Array.isArray(entry) || entry.length != 2) {
            throw new Error("Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.");
          }
          headersObj[entry[0]] = entry[1];
        }
        return headersObj;
      }
    };
  }
});

// ../node_modules/stripe/esm/crypto/CryptoProvider.js
var CryptoProvider, CryptoProviderOnlySupportsAsyncError;
var init_CryptoProvider = __esm({
  "../node_modules/stripe/esm/crypto/CryptoProvider.js"() {
    init_functionsRoutes_0_8044054200943971();
    CryptoProvider = class {
      static {
        __name(this, "CryptoProvider");
      }
      /**
       * Computes a SHA-256 HMAC given a secret and a payload (encoded in UTF-8).
       * The output HMAC should be encoded in hexadecimal.
       *
       * Sample values for implementations:
       * - computeHMACSignature('', 'test_secret') => 'f7f9bd47fb987337b5796fdc1fdb9ba221d0d5396814bfcaf9521f43fd8927fd'
       * - computeHMACSignature('\ud83d\ude00', 'test_secret') => '837da296d05c4fe31f61d5d7ead035099d9585a5bcde87de952012a78f0b0c43
       */
      computeHMACSignature(payload, secret) {
        throw new Error("computeHMACSignature not implemented.");
      }
      /**
       * Asynchronous version of `computeHMACSignature`. Some implementations may
       * only allow support async signature computation.
       *
       * Computes a SHA-256 HMAC given a secret and a payload (encoded in UTF-8).
       * The output HMAC should be encoded in hexadecimal.
       *
       * Sample values for implementations:
       * - computeHMACSignature('', 'test_secret') => 'f7f9bd47fb987337b5796fdc1fdb9ba221d0d5396814bfcaf9521f43fd8927fd'
       * - computeHMACSignature('\ud83d\ude00', 'test_secret') => '837da296d05c4fe31f61d5d7ead035099d9585a5bcde87de952012a78f0b0c43
       */
      computeHMACSignatureAsync(payload, secret) {
        throw new Error("computeHMACSignatureAsync not implemented.");
      }
      /**
       * Computes a SHA-256 hash of the data.
       */
      computeSHA256Async(data) {
        throw new Error("computeSHA256 not implemented.");
      }
    };
    CryptoProviderOnlySupportsAsyncError = class extends Error {
      static {
        __name(this, "CryptoProviderOnlySupportsAsyncError");
      }
    };
  }
});

// ../node_modules/stripe/esm/crypto/SubtleCryptoProvider.js
var SubtleCryptoProvider, byteHexMapping;
var init_SubtleCryptoProvider = __esm({
  "../node_modules/stripe/esm/crypto/SubtleCryptoProvider.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_CryptoProvider();
    SubtleCryptoProvider = class extends CryptoProvider {
      static {
        __name(this, "SubtleCryptoProvider");
      }
      constructor(subtleCrypto) {
        super();
        this.subtleCrypto = subtleCrypto || crypto.subtle;
      }
      /** @override */
      computeHMACSignature(payload, secret) {
        throw new CryptoProviderOnlySupportsAsyncError("SubtleCryptoProvider cannot be used in a synchronous context.");
      }
      /** @override */
      async computeHMACSignatureAsync(payload, secret) {
        const encoder = new TextEncoder();
        const key = await this.subtleCrypto.importKey("raw", encoder.encode(secret), {
          name: "HMAC",
          hash: { name: "SHA-256" }
        }, false, ["sign"]);
        const signatureBuffer = await this.subtleCrypto.sign("hmac", key, encoder.encode(payload));
        const signatureBytes = new Uint8Array(signatureBuffer);
        const signatureHexCodes = new Array(signatureBytes.length);
        for (let i = 0; i < signatureBytes.length; i++) {
          signatureHexCodes[i] = byteHexMapping[signatureBytes[i]];
        }
        return signatureHexCodes.join("");
      }
      /** @override */
      async computeSHA256Async(data) {
        return new Uint8Array(await this.subtleCrypto.digest("SHA-256", data));
      }
    };
    byteHexMapping = new Array(256);
    for (let i = 0; i < byteHexMapping.length; i++) {
      byteHexMapping[i] = i.toString(16).padStart(2, "0");
    }
  }
});

// ../node_modules/stripe/esm/platform/PlatformFunctions.js
var PlatformFunctions;
var init_PlatformFunctions = __esm({
  "../node_modules/stripe/esm/platform/PlatformFunctions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_FetchHttpClient();
    init_SubtleCryptoProvider();
    PlatformFunctions = class {
      static {
        __name(this, "PlatformFunctions");
      }
      constructor() {
        this._fetchFn = null;
        this._agent = null;
      }
      /**
       * Gets uname with Node's built-in `exec` function, if available.
       */
      getUname() {
        throw new Error("getUname not implemented.");
      }
      /**
       * Generates a v4 UUID. See https://stackoverflow.com/a/2117523
       */
      uuid4() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
          const r = Math.random() * 16 | 0;
          const v = c === "x" ? r : r & 3 | 8;
          return v.toString(16);
        });
      }
      /**
       * Compares strings in constant time.
       */
      secureCompare(a, b) {
        if (a.length !== b.length) {
          return false;
        }
        const len = a.length;
        let result = 0;
        for (let i = 0; i < len; ++i) {
          result |= a.charCodeAt(i) ^ b.charCodeAt(i);
        }
        return result === 0;
      }
      /**
       * Creates an event emitter.
       */
      createEmitter() {
        throw new Error("createEmitter not implemented.");
      }
      /**
       * Checks if the request data is a stream. If so, read the entire stream
       * to a buffer and return the buffer.
       */
      tryBufferData(data) {
        throw new Error("tryBufferData not implemented.");
      }
      /**
       * Creates an HTTP client which uses the Node `http` and `https` packages
       * to issue requests.
       */
      createNodeHttpClient(agent) {
        throw new Error("createNodeHttpClient not implemented.");
      }
      /**
       * Creates an HTTP client for issuing Stripe API requests which uses the Web
       * Fetch API.
       *
       * A fetch function can optionally be passed in as a parameter. If none is
       * passed, will default to the default `fetch` function in the global scope.
       */
      createFetchHttpClient(fetchFn) {
        return new FetchHttpClient(fetchFn);
      }
      /**
       * Creates an HTTP client using runtime-specific APIs.
       */
      createDefaultHttpClient() {
        throw new Error("createDefaultHttpClient not implemented.");
      }
      /**
       * Creates a CryptoProvider which uses the Node `crypto` package for its computations.
       */
      createNodeCryptoProvider() {
        throw new Error("createNodeCryptoProvider not implemented.");
      }
      /**
       * Creates a CryptoProvider which uses the SubtleCrypto interface of the Web Crypto API.
       */
      createSubtleCryptoProvider(subtleCrypto) {
        return new SubtleCryptoProvider(subtleCrypto);
      }
      createDefaultCryptoProvider() {
        throw new Error("createDefaultCryptoProvider not implemented.");
      }
    };
  }
});

// ../node_modules/stripe/esm/StripeEmitter.js
var _StripeEvent, StripeEmitter;
var init_StripeEmitter = __esm({
  "../node_modules/stripe/esm/StripeEmitter.js"() {
    init_functionsRoutes_0_8044054200943971();
    _StripeEvent = class extends Event {
      static {
        __name(this, "_StripeEvent");
      }
      constructor(eventName, data) {
        super(eventName);
        this.data = data;
      }
    };
    StripeEmitter = class {
      static {
        __name(this, "StripeEmitter");
      }
      constructor() {
        this.eventTarget = new EventTarget();
        this.listenerMapping = /* @__PURE__ */ new Map();
      }
      on(eventName, listener) {
        const listenerWrapper = /* @__PURE__ */ __name((event) => {
          listener(event.data);
        }, "listenerWrapper");
        this.listenerMapping.set(listener, listenerWrapper);
        return this.eventTarget.addEventListener(eventName, listenerWrapper);
      }
      removeListener(eventName, listener) {
        const listenerWrapper = this.listenerMapping.get(listener);
        this.listenerMapping.delete(listener);
        return this.eventTarget.removeEventListener(eventName, listenerWrapper);
      }
      once(eventName, listener) {
        const listenerWrapper = /* @__PURE__ */ __name((event) => {
          listener(event.data);
        }, "listenerWrapper");
        this.listenerMapping.set(listener, listenerWrapper);
        return this.eventTarget.addEventListener(eventName, listenerWrapper, {
          once: true
        });
      }
      emit(eventName, data) {
        return this.eventTarget.dispatchEvent(new _StripeEvent(eventName, data));
      }
    };
  }
});

// ../node_modules/stripe/esm/platform/WebPlatformFunctions.js
var WebPlatformFunctions;
var init_WebPlatformFunctions = __esm({
  "../node_modules/stripe/esm/platform/WebPlatformFunctions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_PlatformFunctions();
    init_StripeEmitter();
    WebPlatformFunctions = class extends PlatformFunctions {
      static {
        __name(this, "WebPlatformFunctions");
      }
      /** @override */
      getUname() {
        return Promise.resolve(null);
      }
      /** @override */
      createEmitter() {
        return new StripeEmitter();
      }
      /** @override */
      tryBufferData(data) {
        if (data.file.data instanceof ReadableStream) {
          throw new Error("Uploading a file as a stream is not supported in non-Node environments. Please open or upvote an issue at github.com/stripe/stripe-node if you use this, detailing your use-case.");
        }
        return Promise.resolve(data);
      }
      /** @override */
      createNodeHttpClient() {
        throw new Error("Stripe: `createNodeHttpClient()` is not available in non-Node environments. Please use `createFetchHttpClient()` instead.");
      }
      /** @override */
      createDefaultHttpClient() {
        return super.createFetchHttpClient();
      }
      /** @override */
      createNodeCryptoProvider() {
        throw new Error("Stripe: `createNodeCryptoProvider()` is not available in non-Node environments. Please use `createSubtleCryptoProvider()` instead.");
      }
      /** @override */
      createDefaultCryptoProvider() {
        return this.createSubtleCryptoProvider();
      }
    };
  }
});

// ../node_modules/stripe/esm/Error.js
var Error_exports = {};
__export(Error_exports, {
  StripeAPIError: () => StripeAPIError,
  StripeAuthenticationError: () => StripeAuthenticationError,
  StripeCardError: () => StripeCardError,
  StripeConnectionError: () => StripeConnectionError,
  StripeError: () => StripeError,
  StripeIdempotencyError: () => StripeIdempotencyError,
  StripeInvalidGrantError: () => StripeInvalidGrantError,
  StripeInvalidRequestError: () => StripeInvalidRequestError,
  StripePermissionError: () => StripePermissionError,
  StripeRateLimitError: () => StripeRateLimitError,
  StripeSignatureVerificationError: () => StripeSignatureVerificationError,
  StripeUnknownError: () => StripeUnknownError,
  TemporarySessionExpiredError: () => TemporarySessionExpiredError,
  generateV1Error: () => generateV1Error,
  generateV2Error: () => generateV2Error
});
var generateV1Error, generateV2Error, StripeError, StripeCardError, StripeInvalidRequestError, StripeAPIError, StripeAuthenticationError, StripePermissionError, StripeRateLimitError, StripeConnectionError, StripeSignatureVerificationError, StripeIdempotencyError, StripeInvalidGrantError, StripeUnknownError, TemporarySessionExpiredError;
var init_Error = __esm({
  "../node_modules/stripe/esm/Error.js"() {
    init_functionsRoutes_0_8044054200943971();
    generateV1Error = /* @__PURE__ */ __name((rawStripeError) => {
      switch (rawStripeError.type) {
        case "card_error":
          return new StripeCardError(rawStripeError);
        case "invalid_request_error":
          return new StripeInvalidRequestError(rawStripeError);
        case "api_error":
          return new StripeAPIError(rawStripeError);
        case "authentication_error":
          return new StripeAuthenticationError(rawStripeError);
        case "rate_limit_error":
          return new StripeRateLimitError(rawStripeError);
        case "idempotency_error":
          return new StripeIdempotencyError(rawStripeError);
        case "invalid_grant":
          return new StripeInvalidGrantError(rawStripeError);
        default:
          return new StripeUnknownError(rawStripeError);
      }
    }, "generateV1Error");
    generateV2Error = /* @__PURE__ */ __name((rawStripeError) => {
      switch (rawStripeError.type) {
        // switchCases: The beginning of the section generated from our OpenAPI spec
        case "temporary_session_expired":
          return new TemporarySessionExpiredError(rawStripeError);
      }
      switch (rawStripeError.code) {
        case "invalid_fields":
          return new StripeInvalidRequestError(rawStripeError);
      }
      return generateV1Error(rawStripeError);
    }, "generateV2Error");
    StripeError = class extends Error {
      static {
        __name(this, "StripeError");
      }
      constructor(raw = {}, type = null) {
        var _a;
        super(raw.message);
        this.type = type || this.constructor.name;
        this.raw = raw;
        this.rawType = raw.type;
        this.code = raw.code;
        this.doc_url = raw.doc_url;
        this.param = raw.param;
        this.detail = raw.detail;
        this.headers = raw.headers;
        this.requestId = raw.requestId;
        this.statusCode = raw.statusCode;
        this.message = (_a = raw.message) !== null && _a !== void 0 ? _a : "";
        this.userMessage = raw.user_message;
        this.charge = raw.charge;
        this.decline_code = raw.decline_code;
        this.payment_intent = raw.payment_intent;
        this.payment_method = raw.payment_method;
        this.payment_method_type = raw.payment_method_type;
        this.setup_intent = raw.setup_intent;
        this.source = raw.source;
      }
    };
    StripeError.generate = generateV1Error;
    StripeCardError = class extends StripeError {
      static {
        __name(this, "StripeCardError");
      }
      constructor(raw = {}) {
        super(raw, "StripeCardError");
      }
    };
    StripeInvalidRequestError = class extends StripeError {
      static {
        __name(this, "StripeInvalidRequestError");
      }
      constructor(raw = {}) {
        super(raw, "StripeInvalidRequestError");
      }
    };
    StripeAPIError = class extends StripeError {
      static {
        __name(this, "StripeAPIError");
      }
      constructor(raw = {}) {
        super(raw, "StripeAPIError");
      }
    };
    StripeAuthenticationError = class extends StripeError {
      static {
        __name(this, "StripeAuthenticationError");
      }
      constructor(raw = {}) {
        super(raw, "StripeAuthenticationError");
      }
    };
    StripePermissionError = class extends StripeError {
      static {
        __name(this, "StripePermissionError");
      }
      constructor(raw = {}) {
        super(raw, "StripePermissionError");
      }
    };
    StripeRateLimitError = class extends StripeError {
      static {
        __name(this, "StripeRateLimitError");
      }
      constructor(raw = {}) {
        super(raw, "StripeRateLimitError");
      }
    };
    StripeConnectionError = class extends StripeError {
      static {
        __name(this, "StripeConnectionError");
      }
      constructor(raw = {}) {
        super(raw, "StripeConnectionError");
      }
    };
    StripeSignatureVerificationError = class extends StripeError {
      static {
        __name(this, "StripeSignatureVerificationError");
      }
      constructor(header, payload, raw = {}) {
        super(raw, "StripeSignatureVerificationError");
        this.header = header;
        this.payload = payload;
      }
    };
    StripeIdempotencyError = class extends StripeError {
      static {
        __name(this, "StripeIdempotencyError");
      }
      constructor(raw = {}) {
        super(raw, "StripeIdempotencyError");
      }
    };
    StripeInvalidGrantError = class extends StripeError {
      static {
        __name(this, "StripeInvalidGrantError");
      }
      constructor(raw = {}) {
        super(raw, "StripeInvalidGrantError");
      }
    };
    StripeUnknownError = class extends StripeError {
      static {
        __name(this, "StripeUnknownError");
      }
      constructor(raw = {}) {
        super(raw, "StripeUnknownError");
      }
    };
    TemporarySessionExpiredError = class extends StripeError {
      static {
        __name(this, "TemporarySessionExpiredError");
      }
      constructor(rawStripeError = {}) {
        super(rawStripeError, "TemporarySessionExpiredError");
      }
    };
  }
});

// ../node_modules/stripe/esm/RequestSender.js
var MAX_RETRY_AFTER_WAIT, RequestSender;
var init_RequestSender = __esm({
  "../node_modules/stripe/esm/RequestSender.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_Error();
    init_HttpClient();
    init_utils3();
    MAX_RETRY_AFTER_WAIT = 60;
    RequestSender = class _RequestSender {
      static {
        __name(this, "RequestSender");
      }
      constructor(stripe, maxBufferedRequestMetric) {
        this._stripe = stripe;
        this._maxBufferedRequestMetric = maxBufferedRequestMetric;
      }
      _addHeadersDirectlyToObject(obj, headers) {
        obj.requestId = headers["request-id"];
        obj.stripeAccount = obj.stripeAccount || headers["stripe-account"];
        obj.apiVersion = obj.apiVersion || headers["stripe-version"];
        obj.idempotencyKey = obj.idempotencyKey || headers["idempotency-key"];
      }
      _makeResponseEvent(requestEvent, statusCode, headers) {
        const requestEndTime = Date.now();
        const requestDurationMs = requestEndTime - requestEvent.request_start_time;
        return removeNullish({
          api_version: headers["stripe-version"],
          account: headers["stripe-account"],
          idempotency_key: headers["idempotency-key"],
          method: requestEvent.method,
          path: requestEvent.path,
          status: statusCode,
          request_id: this._getRequestId(headers),
          elapsed: requestDurationMs,
          request_start_time: requestEvent.request_start_time,
          request_end_time: requestEndTime
        });
      }
      _getRequestId(headers) {
        return headers["request-id"];
      }
      /**
       * Used by methods with spec.streaming === true. For these methods, we do not
       * buffer successful responses into memory or do parse them into stripe
       * objects, we delegate that all of that to the user and pass back the raw
       * http.Response object to the callback.
       *
       * (Unsuccessful responses shouldn't make it here, they should
       * still be buffered/parsed and handled by _jsonResponseHandler -- see
       * makeRequest)
       */
      _streamingResponseHandler(requestEvent, usage, callback) {
        return (res) => {
          const headers = res.getHeaders();
          const streamCompleteCallback = /* @__PURE__ */ __name(() => {
            const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);
            this._stripe._emitter.emit("response", responseEvent);
            this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed, usage);
          }, "streamCompleteCallback");
          const stream = res.toStream(streamCompleteCallback);
          this._addHeadersDirectlyToObject(stream, headers);
          return callback(null, stream);
        };
      }
      /**
       * Default handler for Stripe responses. Buffers the response into memory,
       * parses the JSON and returns it (i.e. passes it to the callback) if there
       * is no "error" field. Otherwise constructs/passes an appropriate Error.
       */
      _jsonResponseHandler(requestEvent, apiMode, usage, callback) {
        return (res) => {
          const headers = res.getHeaders();
          const requestId = this._getRequestId(headers);
          const statusCode = res.getStatusCode();
          const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);
          this._stripe._emitter.emit("response", responseEvent);
          res.toJSON().then((jsonResponse2) => {
            if (jsonResponse2.error) {
              let err;
              if (typeof jsonResponse2.error === "string") {
                jsonResponse2.error = {
                  type: jsonResponse2.error,
                  message: jsonResponse2.error_description
                };
              }
              jsonResponse2.error.headers = headers;
              jsonResponse2.error.statusCode = statusCode;
              jsonResponse2.error.requestId = requestId;
              if (statusCode === 401) {
                err = new StripeAuthenticationError(jsonResponse2.error);
              } else if (statusCode === 403) {
                err = new StripePermissionError(jsonResponse2.error);
              } else if (statusCode === 429) {
                err = new StripeRateLimitError(jsonResponse2.error);
              } else if (apiMode === "v2") {
                err = generateV2Error(jsonResponse2.error);
              } else {
                err = generateV1Error(jsonResponse2.error);
              }
              throw err;
            }
            return jsonResponse2;
          }, (e) => {
            throw new StripeAPIError({
              message: "Invalid JSON received from the Stripe API",
              exception: e,
              requestId: headers["request-id"]
            });
          }).then((jsonResponse2) => {
            this._recordRequestMetrics(requestId, responseEvent.elapsed, usage);
            const rawResponse = res.getRawResponse();
            this._addHeadersDirectlyToObject(rawResponse, headers);
            Object.defineProperty(jsonResponse2, "lastResponse", {
              enumerable: false,
              writable: false,
              value: rawResponse
            });
            callback(null, jsonResponse2);
          }, (e) => callback(e, null));
        };
      }
      static _generateConnectionErrorMessage(requestRetries) {
        return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ""}`;
      }
      // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency
      static _shouldRetry(res, numRetries, maxRetries, error) {
        if (error && numRetries === 0 && HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {
          return true;
        }
        if (numRetries >= maxRetries) {
          return false;
        }
        if (!res) {
          return true;
        }
        if (res.getHeaders()["stripe-should-retry"] === "false") {
          return false;
        }
        if (res.getHeaders()["stripe-should-retry"] === "true") {
          return true;
        }
        if (res.getStatusCode() === 409) {
          return true;
        }
        if (res.getStatusCode() >= 500) {
          return true;
        }
        return false;
      }
      _getSleepTimeInMS(numRetries, retryAfter = null) {
        const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();
        const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();
        let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(2, numRetries - 1), maxNetworkRetryDelay);
        sleepSeconds *= 0.5 * (1 + Math.random());
        sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);
        if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {
          sleepSeconds = Math.max(sleepSeconds, retryAfter);
        }
        return sleepSeconds * 1e3;
      }
      // Max retries can be set on a per request basis. Favor those over the global setting
      _getMaxNetworkRetries(settings3 = {}) {
        return settings3.maxNetworkRetries !== void 0 && Number.isInteger(settings3.maxNetworkRetries) ? settings3.maxNetworkRetries : this._stripe.getMaxNetworkRetries();
      }
      _defaultIdempotencyKey(method, settings3, apiMode) {
        const maxRetries = this._getMaxNetworkRetries(settings3);
        const genKey = /* @__PURE__ */ __name(() => `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`, "genKey");
        if (apiMode === "v2") {
          if (method === "POST" || method === "DELETE") {
            return genKey();
          }
        } else if (apiMode === "v1") {
          if (method === "POST" && maxRetries > 0) {
            return genKey();
          }
        }
        return null;
      }
      _makeHeaders({ contentType, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings, stripeAccount, stripeContext, apiMode }) {
        const defaultHeaders = {
          Accept: "application/json",
          "Content-Type": contentType,
          "User-Agent": this._getUserAgentString(apiMode),
          "X-Stripe-Client-User-Agent": clientUserAgent,
          "X-Stripe-Client-Telemetry": this._getTelemetryHeader(),
          "Stripe-Version": apiVersion,
          "Stripe-Account": stripeAccount,
          "Stripe-Context": stripeContext,
          "Idempotency-Key": this._defaultIdempotencyKey(method, userSuppliedSettings, apiMode)
        };
        const methodHasPayload = method == "POST" || method == "PUT" || method == "PATCH";
        if (methodHasPayload || contentLength) {
          if (!methodHasPayload) {
            emitWarning(`${method} method had non-zero contentLength but no payload is expected for this verb`);
          }
          defaultHeaders["Content-Length"] = contentLength;
        }
        return Object.assign(
          removeNullish(defaultHeaders),
          // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.
          normalizeHeaders(userSuppliedHeaders)
        );
      }
      _getUserAgentString(apiMode) {
        const packageVersion = this._stripe.getConstant("PACKAGE_VERSION");
        const appInfo = this._stripe._appInfo ? this._stripe.getAppInfoAsString() : "";
        return `Stripe/${apiMode} NodeBindings/${packageVersion} ${appInfo}`.trim();
      }
      _getTelemetryHeader() {
        if (this._stripe.getTelemetryEnabled() && this._stripe._prevRequestMetrics.length > 0) {
          const metrics = this._stripe._prevRequestMetrics.shift();
          return JSON.stringify({
            last_request_metrics: metrics
          });
        }
      }
      _recordRequestMetrics(requestId, requestDurationMs, usage) {
        if (this._stripe.getTelemetryEnabled() && requestId) {
          if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {
            emitWarning("Request metrics buffer is full, dropping telemetry message.");
          } else {
            const m = {
              request_id: requestId,
              request_duration_ms: requestDurationMs
            };
            if (usage && usage.length > 0) {
              m.usage = usage;
            }
            this._stripe._prevRequestMetrics.push(m);
          }
        }
      }
      _rawRequest(method, path, params, options) {
        const requestPromise = new Promise((resolve, reject) => {
          let opts;
          try {
            const requestMethod = method.toUpperCase();
            if (requestMethod !== "POST" && params && Object.keys(params).length !== 0) {
              throw new Error("rawRequest only supports params on POST requests. Please pass null and add your parameters to path.");
            }
            const args = [].slice.call([params, options]);
            const dataFromArgs = getDataFromArgs(args);
            const data = requestMethod === "POST" ? Object.assign({}, dataFromArgs) : null;
            const calculatedOptions = getOptionsFromArgs(args);
            const headers2 = calculatedOptions.headers;
            const authenticator2 = calculatedOptions.authenticator;
            opts = {
              requestMethod,
              requestPath: path,
              bodyData: data,
              queryData: {},
              authenticator: authenticator2,
              headers: headers2,
              host: calculatedOptions.host,
              streaming: !!calculatedOptions.streaming,
              settings: {},
              usage: ["raw_request"]
            };
          } catch (err) {
            reject(err);
            return;
          }
          function requestCallback(err, response) {
            if (err) {
              reject(err);
            } else {
              resolve(response);
            }
          }
          __name(requestCallback, "requestCallback");
          const { headers, settings: settings3 } = opts;
          const authenticator = opts.authenticator;
          this._request(opts.requestMethod, opts.host, path, opts.bodyData, authenticator, { headers, settings: settings3, streaming: opts.streaming }, opts.usage, requestCallback);
        });
        return requestPromise;
      }
      _request(method, host, path, data, authenticator, options, usage = [], callback, requestDataProcessor = null) {
        var _a;
        let requestData;
        authenticator = (_a = authenticator !== null && authenticator !== void 0 ? authenticator : this._stripe._authenticator) !== null && _a !== void 0 ? _a : null;
        const apiMode = getAPIMode(path);
        const retryRequest = /* @__PURE__ */ __name((requestFn, apiVersion, headers, requestRetries, retryAfter) => {
          return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);
        }, "retryRequest");
        const makeRequest = /* @__PURE__ */ __name((apiVersion, headers, numRetries) => {
          const timeout = options.settings && options.settings.timeout && Number.isInteger(options.settings.timeout) && options.settings.timeout >= 0 ? options.settings.timeout : this._stripe.getApiField("timeout");
          const request = {
            host: host || this._stripe.getApiField("host"),
            port: this._stripe.getApiField("port"),
            path,
            method,
            headers: Object.assign({}, headers),
            body: requestData,
            protocol: this._stripe.getApiField("protocol")
          };
          authenticator(request).then(() => {
            const req = this._stripe.getApiField("httpClient").makeRequest(request.host, request.port, request.path, request.method, request.headers, request.body, request.protocol, timeout);
            const requestStartTime = Date.now();
            const requestEvent = removeNullish({
              api_version: apiVersion,
              account: parseHttpHeaderAsString(headers["Stripe-Account"]),
              idempotency_key: parseHttpHeaderAsString(headers["Idempotency-Key"]),
              method,
              path,
              request_start_time: requestStartTime
            });
            const requestRetries = numRetries || 0;
            const maxRetries = this._getMaxNetworkRetries(options.settings || {});
            this._stripe._emitter.emit("request", requestEvent);
            req.then((res) => {
              if (_RequestSender._shouldRetry(res, requestRetries, maxRetries)) {
                return retryRequest(makeRequest, apiVersion, headers, requestRetries, parseHttpHeaderAsNumber(res.getHeaders()["retry-after"]));
              } else if (options.streaming && res.getStatusCode() < 400) {
                return this._streamingResponseHandler(requestEvent, usage, callback)(res);
              } else {
                return this._jsonResponseHandler(requestEvent, apiMode, usage, callback)(res);
              }
            }).catch((error) => {
              if (_RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {
                return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);
              } else {
                const isTimeoutError = error.code && error.code === HttpClient.TIMEOUT_ERROR_CODE;
                return callback(new StripeConnectionError({
                  message: isTimeoutError ? `Request aborted due to timeout being reached (${timeout}ms)` : _RequestSender._generateConnectionErrorMessage(requestRetries),
                  detail: error
                }));
              }
            });
          }).catch((e) => {
            throw new StripeError({
              message: "Unable to authenticate the request",
              exception: e
            });
          });
        }, "makeRequest");
        const prepareAndMakeRequest = /* @__PURE__ */ __name((error, data2) => {
          if (error) {
            return callback(error);
          }
          requestData = data2;
          this._stripe.getClientUserAgent((clientUserAgent) => {
            const apiVersion = this._stripe.getApiField("version");
            const headers = this._makeHeaders({
              contentType: apiMode == "v2" ? "application/json" : "application/x-www-form-urlencoded",
              contentLength: requestData.length,
              apiVersion,
              clientUserAgent,
              method,
              userSuppliedHeaders: options.headers,
              userSuppliedSettings: options.settings,
              stripeAccount: apiMode == "v2" ? null : this._stripe.getApiField("stripeAccount"),
              stripeContext: apiMode == "v2" ? this._stripe.getApiField("stripeContext") : null,
              apiMode
            });
            makeRequest(apiVersion, headers, 0);
          });
        }, "prepareAndMakeRequest");
        if (requestDataProcessor) {
          requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);
        } else {
          let stringifiedData;
          if (apiMode == "v2") {
            stringifiedData = data ? jsonStringifyRequestData(data) : "";
          } else {
            stringifiedData = queryStringifyRequestData(data || {}, apiMode);
          }
          prepareAndMakeRequest(null, stringifiedData);
        }
      }
    };
  }
});

// ../node_modules/stripe/esm/autoPagination.js
function getAsyncIteratorSymbol() {
  if (typeof Symbol !== "undefined" && Symbol.asyncIterator) {
    return Symbol.asyncIterator;
  }
  return "@@asyncIterator";
}
function getDoneCallback(args) {
  if (args.length < 2) {
    return null;
  }
  const onDone = args[1];
  if (typeof onDone !== "function") {
    throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);
  }
  return onDone;
}
function getItemCallback(args) {
  if (args.length === 0) {
    return void 0;
  }
  const onItem = args[0];
  if (typeof onItem !== "function") {
    throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);
  }
  if (onItem.length === 2) {
    return onItem;
  }
  if (onItem.length > 2) {
    throw Error(`The \`onItem\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);
  }
  return /* @__PURE__ */ __name(function _onItem(item, next) {
    const shouldContinue = onItem(item);
    next(shouldContinue);
  }, "_onItem");
}
function getLastId(listResult, reverseIteration) {
  const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;
  const lastItem = listResult.data[lastIdx];
  const lastId = lastItem && lastItem.id;
  if (!lastId) {
    throw Error("Unexpected: No `id` found on the last item while auto-paging a list.");
  }
  return lastId;
}
function makeAutoPagingEach(asyncIteratorNext) {
  return /* @__PURE__ */ __name(function autoPagingEach() {
    const args = [].slice.call(arguments);
    const onItem = getItemCallback(args);
    const onDone = getDoneCallback(args);
    if (args.length > 2) {
      throw Error(`autoPagingEach takes up to two arguments; received ${args}`);
    }
    const autoPagePromise = wrapAsyncIteratorWithCallback(
      asyncIteratorNext,
      // @ts-ignore we might need a null check
      onItem
    );
    return callbackifyPromiseWithTimeout(autoPagePromise, onDone);
  }, "autoPagingEach");
}
function makeAutoPagingToArray(autoPagingEach) {
  return /* @__PURE__ */ __name(function autoPagingToArray(opts, onDone) {
    const limit = opts && opts.limit;
    if (!limit) {
      throw Error("You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.");
    }
    if (limit > 1e4) {
      throw Error("You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.");
    }
    const promise = new Promise((resolve, reject) => {
      const items = [];
      autoPagingEach((item) => {
        items.push(item);
        if (items.length >= limit) {
          return false;
        }
      }).then(() => {
        resolve(items);
      }).catch(reject);
    });
    return callbackifyPromiseWithTimeout(promise, onDone);
  }, "autoPagingToArray");
}
function wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {
  return new Promise((resolve, reject) => {
    function handleIteration(iterResult) {
      if (iterResult.done) {
        resolve();
        return;
      }
      const item = iterResult.value;
      return new Promise((next) => {
        onItem(item, next);
      }).then((shouldContinue) => {
        if (shouldContinue === false) {
          return handleIteration({ done: true, value: void 0 });
        } else {
          return asyncIteratorNext().then(handleIteration);
        }
      });
    }
    __name(handleIteration, "handleIteration");
    asyncIteratorNext().then(handleIteration).catch(reject);
  });
}
function isReverseIteration(requestArgs) {
  const args = [].slice.call(requestArgs);
  const dataFromArgs = getDataFromArgs(args);
  return !!dataFromArgs.ending_before;
}
var V1Iterator, V1ListIterator, V1SearchIterator, V2ListIterator, makeAutoPaginationMethods, makeAutoPaginationMethodsFromIterator;
var init_autoPagination = __esm({
  "../node_modules/stripe/esm/autoPagination.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_utils3();
    V1Iterator = class {
      static {
        __name(this, "V1Iterator");
      }
      constructor(firstPagePromise, requestArgs, spec, stripeResource) {
        this.index = 0;
        this.pagePromise = firstPagePromise;
        this.promiseCache = { currentPromise: null };
        this.requestArgs = requestArgs;
        this.spec = spec;
        this.stripeResource = stripeResource;
      }
      async iterate(pageResult) {
        if (!(pageResult && pageResult.data && typeof pageResult.data.length === "number")) {
          throw Error("Unexpected: Stripe API response does not have a well-formed `data` array.");
        }
        const reverseIteration = isReverseIteration(this.requestArgs);
        if (this.index < pageResult.data.length) {
          const idx = reverseIteration ? pageResult.data.length - 1 - this.index : this.index;
          const value = pageResult.data[idx];
          this.index += 1;
          return { value, done: false };
        } else if (pageResult.has_more) {
          this.index = 0;
          this.pagePromise = this.getNextPage(pageResult);
          const nextPageResult = await this.pagePromise;
          return this.iterate(nextPageResult);
        }
        return { done: true, value: void 0 };
      }
      /** @abstract */
      getNextPage(_pageResult) {
        throw new Error("Unimplemented");
      }
      async _next() {
        return this.iterate(await this.pagePromise);
      }
      next() {
        if (this.promiseCache.currentPromise) {
          return this.promiseCache.currentPromise;
        }
        const nextPromise = (async () => {
          const ret = await this._next();
          this.promiseCache.currentPromise = null;
          return ret;
        })();
        this.promiseCache.currentPromise = nextPromise;
        return nextPromise;
      }
    };
    V1ListIterator = class extends V1Iterator {
      static {
        __name(this, "V1ListIterator");
      }
      getNextPage(pageResult) {
        const reverseIteration = isReverseIteration(this.requestArgs);
        const lastId = getLastId(pageResult, reverseIteration);
        return this.stripeResource._makeRequest(this.requestArgs, this.spec, {
          [reverseIteration ? "ending_before" : "starting_after"]: lastId
        });
      }
    };
    V1SearchIterator = class extends V1Iterator {
      static {
        __name(this, "V1SearchIterator");
      }
      getNextPage(pageResult) {
        if (!pageResult.next_page) {
          throw Error("Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.");
        }
        return this.stripeResource._makeRequest(this.requestArgs, this.spec, {
          page: pageResult.next_page
        });
      }
    };
    V2ListIterator = class {
      static {
        __name(this, "V2ListIterator");
      }
      constructor(firstPagePromise, requestArgs, spec, stripeResource) {
        this.currentPageIterator = (async () => {
          const page = await firstPagePromise;
          return page.data[Symbol.iterator]();
        })();
        this.nextPageUrl = (async () => {
          const page = await firstPagePromise;
          return page.next_page_url || null;
        })();
        this.requestArgs = requestArgs;
        this.spec = spec;
        this.stripeResource = stripeResource;
      }
      async turnPage() {
        const nextPageUrl = await this.nextPageUrl;
        if (!nextPageUrl)
          return null;
        this.spec.fullPath = nextPageUrl;
        const page = await this.stripeResource._makeRequest([], this.spec, {});
        this.nextPageUrl = Promise.resolve(page.next_page_url);
        this.currentPageIterator = Promise.resolve(page.data[Symbol.iterator]());
        return this.currentPageIterator;
      }
      async next() {
        {
          const result2 = (await this.currentPageIterator).next();
          if (!result2.done)
            return { done: false, value: result2.value };
        }
        const nextPageIterator = await this.turnPage();
        if (!nextPageIterator) {
          return { done: true, value: void 0 };
        }
        const result = nextPageIterator.next();
        if (!result.done)
          return { done: false, value: result.value };
        return { done: true, value: void 0 };
      }
    };
    makeAutoPaginationMethods = /* @__PURE__ */ __name((stripeResource, requestArgs, spec, firstPagePromise) => {
      const apiMode = getAPIMode(spec.fullPath || spec.path);
      if (apiMode !== "v2" && spec.methodType === "search") {
        return makeAutoPaginationMethodsFromIterator(new V1SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));
      }
      if (apiMode !== "v2" && spec.methodType === "list") {
        return makeAutoPaginationMethodsFromIterator(new V1ListIterator(firstPagePromise, requestArgs, spec, stripeResource));
      }
      if (apiMode === "v2" && spec.methodType === "list") {
        return makeAutoPaginationMethodsFromIterator(new V2ListIterator(firstPagePromise, requestArgs, spec, stripeResource));
      }
      return null;
    }, "makeAutoPaginationMethods");
    makeAutoPaginationMethodsFromIterator = /* @__PURE__ */ __name((iterator) => {
      const autoPagingEach = makeAutoPagingEach((...args) => iterator.next(...args));
      const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);
      const autoPaginationMethods = {
        autoPagingEach,
        autoPagingToArray,
        // Async iterator functions:
        next: /* @__PURE__ */ __name(() => iterator.next(), "next"),
        return: /* @__PURE__ */ __name(() => {
          return {};
        }, "return"),
        [getAsyncIteratorSymbol()]: () => {
          return autoPaginationMethods;
        }
      };
      return autoPaginationMethods;
    }, "makeAutoPaginationMethodsFromIterator");
    __name(getAsyncIteratorSymbol, "getAsyncIteratorSymbol");
    __name(getDoneCallback, "getDoneCallback");
    __name(getItemCallback, "getItemCallback");
    __name(getLastId, "getLastId");
    __name(makeAutoPagingEach, "makeAutoPagingEach");
    __name(makeAutoPagingToArray, "makeAutoPagingToArray");
    __name(wrapAsyncIteratorWithCallback, "wrapAsyncIteratorWithCallback");
    __name(isReverseIteration, "isReverseIteration");
  }
});

// ../node_modules/stripe/esm/StripeMethod.js
function stripeMethod(spec) {
  if (spec.path !== void 0 && spec.fullPath !== void 0) {
    throw new Error(`Method spec specified both a 'path' (${spec.path}) and a 'fullPath' (${spec.fullPath}).`);
  }
  return function(...args) {
    const callback = typeof args[args.length - 1] == "function" && args.pop();
    spec.urlParams = extractUrlParams(spec.fullPath || this.createResourcePathWithSymbols(spec.path || ""));
    const requestPromise = callbackifyPromiseWithTimeout(this._makeRequest(args, spec, {}), callback);
    Object.assign(requestPromise, makeAutoPaginationMethods(this, args, spec, requestPromise));
    return requestPromise;
  };
}
var init_StripeMethod = __esm({
  "../node_modules/stripe/esm/StripeMethod.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_utils3();
    init_autoPagination();
    __name(stripeMethod, "stripeMethod");
  }
});

// ../node_modules/stripe/esm/StripeResource.js
function StripeResource(stripe, deprecatedUrlData) {
  this._stripe = stripe;
  if (deprecatedUrlData) {
    throw new Error("Support for curried url params was dropped in stripe-node v7.0.0. Instead, pass two ids.");
  }
  this.basePath = makeURLInterpolator(
    // @ts-ignore changing type of basePath
    this.basePath || stripe.getApiField("basePath")
  );
  this.resourcePath = this.path;
  this.path = makeURLInterpolator(this.path);
  this.initialize(...arguments);
}
var init_StripeResource = __esm({
  "../node_modules/stripe/esm/StripeResource.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_utils3();
    init_StripeMethod();
    StripeResource.extend = protoExtend;
    StripeResource.method = stripeMethod;
    StripeResource.MAX_BUFFERED_REQUEST_METRICS = 100;
    __name(StripeResource, "StripeResource");
    StripeResource.prototype = {
      _stripe: null,
      // @ts-ignore the type of path changes in ctor
      path: "",
      resourcePath: "",
      // Methods that don't use the API's default '/v1' path can override it with this setting.
      basePath: null,
      initialize() {
      },
      // Function to override the default data processor. This allows full control
      // over how a StripeResource's request data will get converted into an HTTP
      // body. This is useful for non-standard HTTP requests. The function should
      // take method name, data, and headers as arguments.
      requestDataProcessor: null,
      // Function to add a validation checks before sending the request, errors should
      // be thrown, and they will be passed to the callback/promise.
      validateRequest: null,
      createFullPath(commandPath, urlData) {
        const urlParts = [this.basePath(urlData), this.path(urlData)];
        if (typeof commandPath === "function") {
          const computedCommandPath = commandPath(urlData);
          if (computedCommandPath) {
            urlParts.push(computedCommandPath);
          }
        } else {
          urlParts.push(commandPath);
        }
        return this._joinUrlParts(urlParts);
      },
      // Creates a relative resource path with symbols left in (unlike
      // createFullPath which takes some data to replace them with). For example it
      // might produce: /invoices/{id}
      createResourcePathWithSymbols(pathWithSymbols) {
        if (pathWithSymbols) {
          return `/${this._joinUrlParts([this.resourcePath, pathWithSymbols])}`;
        } else {
          return `/${this.resourcePath}`;
        }
      },
      _joinUrlParts(parts) {
        return parts.join("/").replace(/\/{2,}/g, "/");
      },
      _getRequestOpts(requestArgs, spec, overrideData) {
        var _a;
        const requestMethod = (spec.method || "GET").toUpperCase();
        const usage = spec.usage || [];
        const urlParams = spec.urlParams || [];
        const encode = spec.encode || ((data2) => data2);
        const isUsingFullPath = !!spec.fullPath;
        const commandPath = makeURLInterpolator(isUsingFullPath ? spec.fullPath : spec.path || "");
        const path = isUsingFullPath ? spec.fullPath : this.createResourcePathWithSymbols(spec.path);
        const args = [].slice.call(requestArgs);
        const urlData = urlParams.reduce((urlData2, param) => {
          const arg = args.shift();
          if (typeof arg !== "string") {
            throw new Error(`Stripe: Argument "${param}" must be a string, but got: ${arg} (on API request to \`${requestMethod} ${path}\`)`);
          }
          urlData2[param] = arg;
          return urlData2;
        }, {});
        const dataFromArgs = getDataFromArgs(args);
        const data = encode(Object.assign({}, dataFromArgs, overrideData));
        const options = getOptionsFromArgs(args);
        const host = options.host || spec.host;
        const streaming = !!spec.streaming || !!options.streaming;
        if (args.filter((x) => x != null).length) {
          throw new Error(`Stripe: Unknown arguments (${args}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options. (on API request to ${requestMethod} \`${path}\`)`);
        }
        const requestPath = isUsingFullPath ? commandPath(urlData) : this.createFullPath(commandPath, urlData);
        const headers = Object.assign(options.headers, spec.headers);
        if (spec.validator) {
          spec.validator(data, { headers });
        }
        const dataInQuery = spec.method === "GET" || spec.method === "DELETE";
        const bodyData = dataInQuery ? null : data;
        const queryData = dataInQuery ? data : {};
        return {
          requestMethod,
          requestPath,
          bodyData,
          queryData,
          authenticator: (_a = options.authenticator) !== null && _a !== void 0 ? _a : null,
          headers,
          host: host !== null && host !== void 0 ? host : null,
          streaming,
          settings: options.settings,
          usage
        };
      },
      _makeRequest(requestArgs, spec, overrideData) {
        return new Promise((resolve, reject) => {
          var _a;
          let opts;
          try {
            opts = this._getRequestOpts(requestArgs, spec, overrideData);
          } catch (err) {
            reject(err);
            return;
          }
          function requestCallback(err, response) {
            if (err) {
              reject(err);
            } else {
              resolve(spec.transformResponseData ? spec.transformResponseData(response) : response);
            }
          }
          __name(requestCallback, "requestCallback");
          const emptyQuery = Object.keys(opts.queryData).length === 0;
          const path = [
            opts.requestPath,
            emptyQuery ? "" : "?",
            queryStringifyRequestData(opts.queryData, getAPIMode(opts.requestPath))
          ].join("");
          const { headers, settings: settings3 } = opts;
          this._stripe._requestSender._request(opts.requestMethod, opts.host, path, opts.bodyData, opts.authenticator, {
            headers,
            settings: settings3,
            streaming: opts.streaming
          }, opts.usage, requestCallback, (_a = this.requestDataProcessor) === null || _a === void 0 ? void 0 : _a.bind(this));
        });
      }
    };
  }
});

// ../node_modules/stripe/esm/Webhooks.js
function createWebhooks(platformFunctions) {
  const Webhook = {
    DEFAULT_TOLERANCE: 300,
    signature: null,
    constructEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
      try {
        if (!this.signature) {
          throw new Error("ERR: missing signature helper, unable to verify");
        }
        this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);
      } catch (e) {
        if (e instanceof CryptoProviderOnlySupportsAsyncError) {
          e.message += "\nUse `await constructEventAsync(...)` instead of `constructEvent(...)`";
        }
        throw e;
      }
      const jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder("utf8").decode(payload)) : JSON.parse(payload);
      return jsonPayload;
    },
    async constructEventAsync(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
      if (!this.signature) {
        throw new Error("ERR: missing signature helper, unable to verify");
      }
      await this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);
      const jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder("utf8").decode(payload)) : JSON.parse(payload);
      return jsonPayload;
    },
    /**
     * Generates a header to be used for webhook mocking
     *
     * @typedef {object} opts
     * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()
     * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters
     * @property {string} secret - Stripe webhook secret 'whsec_...'
     * @property {string} scheme - Version of API to hit. Defaults to 'v1'.
     * @property {string} signature - Computed webhook signature
     * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.
     */
    generateTestHeaderString: /* @__PURE__ */ __name(function(opts) {
      const preparedOpts = prepareOptions(opts);
      const signature2 = preparedOpts.signature || preparedOpts.cryptoProvider.computeHMACSignature(preparedOpts.payloadString, preparedOpts.secret);
      return preparedOpts.generateHeaderString(signature2);
    }, "generateTestHeaderString"),
    generateTestHeaderStringAsync: /* @__PURE__ */ __name(async function(opts) {
      const preparedOpts = prepareOptions(opts);
      const signature2 = preparedOpts.signature || await preparedOpts.cryptoProvider.computeHMACSignatureAsync(preparedOpts.payloadString, preparedOpts.secret);
      return preparedOpts.generateHeaderString(signature2);
    }, "generateTestHeaderStringAsync")
  };
  const signature = {
    EXPECTED_SCHEME: "v1",
    verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {
      const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);
      const secretContainsWhitespace = /\s/.test(secret);
      cryptoProvider = cryptoProvider || getCryptoProvider();
      const expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);
      validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);
      return true;
    },
    async verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {
      const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);
      const secretContainsWhitespace = /\s/.test(secret);
      cryptoProvider = cryptoProvider || getCryptoProvider();
      const expectedSignature = await cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);
      return validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);
    }
  };
  function makeHMACContent(payload, details) {
    return `${details.timestamp}.${payload}`;
  }
  __name(makeHMACContent, "makeHMACContent");
  function parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {
    if (!encodedPayload) {
      throw new StripeSignatureVerificationError(encodedHeader, encodedPayload, {
        message: "No webhook payload was provided."
      });
    }
    const suspectPayloadType = typeof encodedPayload != "string" && !(encodedPayload instanceof Uint8Array);
    const textDecoder = new TextDecoder("utf8");
    const decodedPayload = encodedPayload instanceof Uint8Array ? textDecoder.decode(encodedPayload) : encodedPayload;
    if (Array.isArray(encodedHeader)) {
      throw new Error("Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.");
    }
    if (encodedHeader == null || encodedHeader == "") {
      throw new StripeSignatureVerificationError(encodedHeader, encodedPayload, {
        message: "No stripe-signature header value was provided."
      });
    }
    const decodedHeader = encodedHeader instanceof Uint8Array ? textDecoder.decode(encodedHeader) : encodedHeader;
    const details = parseHeader(decodedHeader, expectedScheme);
    if (!details || details.timestamp === -1) {
      throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {
        message: "Unable to extract timestamp and signatures from header"
      });
    }
    if (!details.signatures.length) {
      throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {
        message: "No signatures found with expected scheme"
      });
    }
    return {
      decodedPayload,
      decodedHeader,
      details,
      suspectPayloadType
    };
  }
  __name(parseEventDetails, "parseEventDetails");
  function validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt) {
    const signatureFound = !!details.signatures.filter(platformFunctions.secureCompare.bind(platformFunctions, expectedSignature)).length;
    const docsLocation = "\nLearn more about webhook signing and explore webhook integration examples for various frameworks at https://docs.stripe.com/webhooks/signature";
    const whitespaceMessage = secretContainsWhitespace ? "\n\nNote: The provided signing secret contains whitespace. This often indicates an extra newline or space is in the value" : "";
    if (!signatureFound) {
      if (suspectPayloadType) {
        throw new StripeSignatureVerificationError(header, payload, {
          message: "Webhook payload must be provided as a string or a Buffer (https://nodejs.org/api/buffer.html) instance representing the _raw_ request body.Payload was provided as a parsed JavaScript object instead. \nSignature verification is impossible without access to the original signed material. \n" + docsLocation + "\n" + whitespaceMessage
        });
      }
      throw new StripeSignatureVerificationError(header, payload, {
        message: "No signatures found matching the expected signature for payload. Are you passing the raw request body you received from Stripe? \n If a webhook request is being forwarded by a third-party tool, ensure that the exact request body, including JSON formatting and new line style, is preserved.\n" + docsLocation + "\n" + whitespaceMessage
      });
    }
    const timestampAge = Math.floor((typeof receivedAt === "number" ? receivedAt : Date.now()) / 1e3) - details.timestamp;
    if (tolerance > 0 && timestampAge > tolerance) {
      throw new StripeSignatureVerificationError(header, payload, {
        message: "Timestamp outside the tolerance zone"
      });
    }
    return true;
  }
  __name(validateComputedSignature, "validateComputedSignature");
  function parseHeader(header, scheme) {
    if (typeof header !== "string") {
      return null;
    }
    return header.split(",").reduce((accum, item) => {
      const kv = item.split("=");
      if (kv[0] === "t") {
        accum.timestamp = parseInt(kv[1], 10);
      }
      if (kv[0] === scheme) {
        accum.signatures.push(kv[1]);
      }
      return accum;
    }, {
      timestamp: -1,
      signatures: []
    });
  }
  __name(parseHeader, "parseHeader");
  let webhooksCryptoProviderInstance = null;
  function getCryptoProvider() {
    if (!webhooksCryptoProviderInstance) {
      webhooksCryptoProviderInstance = platformFunctions.createDefaultCryptoProvider();
    }
    return webhooksCryptoProviderInstance;
  }
  __name(getCryptoProvider, "getCryptoProvider");
  function prepareOptions(opts) {
    if (!opts) {
      throw new StripeError({
        message: "Options are required"
      });
    }
    const timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1e3);
    const scheme = opts.scheme || signature.EXPECTED_SCHEME;
    const cryptoProvider = opts.cryptoProvider || getCryptoProvider();
    const payloadString = `${timestamp}.${opts.payload}`;
    const generateHeaderString = /* @__PURE__ */ __name((signature2) => {
      return `t=${timestamp},${scheme}=${signature2}`;
    }, "generateHeaderString");
    return Object.assign(Object.assign({}, opts), {
      timestamp,
      scheme,
      cryptoProvider,
      payloadString,
      generateHeaderString
    });
  }
  __name(prepareOptions, "prepareOptions");
  Webhook.signature = signature;
  return Webhook;
}
var init_Webhooks = __esm({
  "../node_modules/stripe/esm/Webhooks.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_Error();
    init_CryptoProvider();
    __name(createWebhooks, "createWebhooks");
  }
});

// ../node_modules/stripe/esm/apiVersion.js
var ApiVersion;
var init_apiVersion = __esm({
  "../node_modules/stripe/esm/apiVersion.js"() {
    init_functionsRoutes_0_8044054200943971();
    ApiVersion = "2025-07-30.basil";
  }
});

// ../node_modules/stripe/esm/ResourceNamespace.js
function ResourceNamespace(stripe, resources) {
  for (const name in resources) {
    if (!Object.prototype.hasOwnProperty.call(resources, name)) {
      continue;
    }
    const camelCaseName = name[0].toLowerCase() + name.substring(1);
    const resource = new resources[name](stripe);
    this[camelCaseName] = resource;
  }
}
function resourceNamespace(namespace, resources) {
  return function(stripe) {
    return new ResourceNamespace(stripe, resources);
  };
}
var init_ResourceNamespace = __esm({
  "../node_modules/stripe/esm/ResourceNamespace.js"() {
    init_functionsRoutes_0_8044054200943971();
    __name(ResourceNamespace, "ResourceNamespace");
    __name(resourceNamespace, "resourceNamespace");
  }
});

// ../node_modules/stripe/esm/resources/FinancialConnections/Accounts.js
var stripeMethod2, Accounts;
var init_Accounts = __esm({
  "../node_modules/stripe/esm/resources/FinancialConnections/Accounts.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod2 = StripeResource.method;
    Accounts = StripeResource.extend({
      retrieve: stripeMethod2({
        method: "GET",
        fullPath: "/v1/financial_connections/accounts/{account}"
      }),
      list: stripeMethod2({
        method: "GET",
        fullPath: "/v1/financial_connections/accounts",
        methodType: "list"
      }),
      disconnect: stripeMethod2({
        method: "POST",
        fullPath: "/v1/financial_connections/accounts/{account}/disconnect"
      }),
      listOwners: stripeMethod2({
        method: "GET",
        fullPath: "/v1/financial_connections/accounts/{account}/owners",
        methodType: "list"
      }),
      refresh: stripeMethod2({
        method: "POST",
        fullPath: "/v1/financial_connections/accounts/{account}/refresh"
      }),
      subscribe: stripeMethod2({
        method: "POST",
        fullPath: "/v1/financial_connections/accounts/{account}/subscribe"
      }),
      unsubscribe: stripeMethod2({
        method: "POST",
        fullPath: "/v1/financial_connections/accounts/{account}/unsubscribe"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Entitlements/ActiveEntitlements.js
var stripeMethod3, ActiveEntitlements;
var init_ActiveEntitlements = __esm({
  "../node_modules/stripe/esm/resources/Entitlements/ActiveEntitlements.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod3 = StripeResource.method;
    ActiveEntitlements = StripeResource.extend({
      retrieve: stripeMethod3({
        method: "GET",
        fullPath: "/v1/entitlements/active_entitlements/{id}"
      }),
      list: stripeMethod3({
        method: "GET",
        fullPath: "/v1/entitlements/active_entitlements",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Billing/Alerts.js
var stripeMethod4, Alerts;
var init_Alerts = __esm({
  "../node_modules/stripe/esm/resources/Billing/Alerts.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod4 = StripeResource.method;
    Alerts = StripeResource.extend({
      create: stripeMethod4({ method: "POST", fullPath: "/v1/billing/alerts" }),
      retrieve: stripeMethod4({ method: "GET", fullPath: "/v1/billing/alerts/{id}" }),
      list: stripeMethod4({
        method: "GET",
        fullPath: "/v1/billing/alerts",
        methodType: "list"
      }),
      activate: stripeMethod4({
        method: "POST",
        fullPath: "/v1/billing/alerts/{id}/activate"
      }),
      archive: stripeMethod4({
        method: "POST",
        fullPath: "/v1/billing/alerts/{id}/archive"
      }),
      deactivate: stripeMethod4({
        method: "POST",
        fullPath: "/v1/billing/alerts/{id}/deactivate"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/Issuing/Authorizations.js
var stripeMethod5, Authorizations;
var init_Authorizations = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/Issuing/Authorizations.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod5 = StripeResource.method;
    Authorizations = StripeResource.extend({
      create: stripeMethod5({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/authorizations"
      }),
      capture: stripeMethod5({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/capture"
      }),
      expire: stripeMethod5({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/expire"
      }),
      finalizeAmount: stripeMethod5({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/finalize_amount"
      }),
      increment: stripeMethod5({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/increment"
      }),
      respond: stripeMethod5({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/fraud_challenges/respond"
      }),
      reverse: stripeMethod5({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/reverse"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Issuing/Authorizations.js
var stripeMethod6, Authorizations2;
var init_Authorizations2 = __esm({
  "../node_modules/stripe/esm/resources/Issuing/Authorizations.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod6 = StripeResource.method;
    Authorizations2 = StripeResource.extend({
      retrieve: stripeMethod6({
        method: "GET",
        fullPath: "/v1/issuing/authorizations/{authorization}"
      }),
      update: stripeMethod6({
        method: "POST",
        fullPath: "/v1/issuing/authorizations/{authorization}"
      }),
      list: stripeMethod6({
        method: "GET",
        fullPath: "/v1/issuing/authorizations",
        methodType: "list"
      }),
      approve: stripeMethod6({
        method: "POST",
        fullPath: "/v1/issuing/authorizations/{authorization}/approve"
      }),
      decline: stripeMethod6({
        method: "POST",
        fullPath: "/v1/issuing/authorizations/{authorization}/decline"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Tax/Calculations.js
var stripeMethod7, Calculations;
var init_Calculations = __esm({
  "../node_modules/stripe/esm/resources/Tax/Calculations.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod7 = StripeResource.method;
    Calculations = StripeResource.extend({
      create: stripeMethod7({ method: "POST", fullPath: "/v1/tax/calculations" }),
      retrieve: stripeMethod7({
        method: "GET",
        fullPath: "/v1/tax/calculations/{calculation}"
      }),
      listLineItems: stripeMethod7({
        method: "GET",
        fullPath: "/v1/tax/calculations/{calculation}/line_items",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Issuing/Cardholders.js
var stripeMethod8, Cardholders;
var init_Cardholders = __esm({
  "../node_modules/stripe/esm/resources/Issuing/Cardholders.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod8 = StripeResource.method;
    Cardholders = StripeResource.extend({
      create: stripeMethod8({ method: "POST", fullPath: "/v1/issuing/cardholders" }),
      retrieve: stripeMethod8({
        method: "GET",
        fullPath: "/v1/issuing/cardholders/{cardholder}"
      }),
      update: stripeMethod8({
        method: "POST",
        fullPath: "/v1/issuing/cardholders/{cardholder}"
      }),
      list: stripeMethod8({
        method: "GET",
        fullPath: "/v1/issuing/cardholders",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/Issuing/Cards.js
var stripeMethod9, Cards;
var init_Cards = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/Issuing/Cards.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod9 = StripeResource.method;
    Cards = StripeResource.extend({
      deliverCard: stripeMethod9({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/deliver"
      }),
      failCard: stripeMethod9({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/fail"
      }),
      returnCard: stripeMethod9({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/return"
      }),
      shipCard: stripeMethod9({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/ship"
      }),
      submitCard: stripeMethod9({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/submit"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Issuing/Cards.js
var stripeMethod10, Cards2;
var init_Cards2 = __esm({
  "../node_modules/stripe/esm/resources/Issuing/Cards.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod10 = StripeResource.method;
    Cards2 = StripeResource.extend({
      create: stripeMethod10({ method: "POST", fullPath: "/v1/issuing/cards" }),
      retrieve: stripeMethod10({ method: "GET", fullPath: "/v1/issuing/cards/{card}" }),
      update: stripeMethod10({ method: "POST", fullPath: "/v1/issuing/cards/{card}" }),
      list: stripeMethod10({
        method: "GET",
        fullPath: "/v1/issuing/cards",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/BillingPortal/Configurations.js
var stripeMethod11, Configurations;
var init_Configurations = __esm({
  "../node_modules/stripe/esm/resources/BillingPortal/Configurations.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod11 = StripeResource.method;
    Configurations = StripeResource.extend({
      create: stripeMethod11({
        method: "POST",
        fullPath: "/v1/billing_portal/configurations"
      }),
      retrieve: stripeMethod11({
        method: "GET",
        fullPath: "/v1/billing_portal/configurations/{configuration}"
      }),
      update: stripeMethod11({
        method: "POST",
        fullPath: "/v1/billing_portal/configurations/{configuration}"
      }),
      list: stripeMethod11({
        method: "GET",
        fullPath: "/v1/billing_portal/configurations",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Terminal/Configurations.js
var stripeMethod12, Configurations2;
var init_Configurations2 = __esm({
  "../node_modules/stripe/esm/resources/Terminal/Configurations.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod12 = StripeResource.method;
    Configurations2 = StripeResource.extend({
      create: stripeMethod12({
        method: "POST",
        fullPath: "/v1/terminal/configurations"
      }),
      retrieve: stripeMethod12({
        method: "GET",
        fullPath: "/v1/terminal/configurations/{configuration}"
      }),
      update: stripeMethod12({
        method: "POST",
        fullPath: "/v1/terminal/configurations/{configuration}"
      }),
      list: stripeMethod12({
        method: "GET",
        fullPath: "/v1/terminal/configurations",
        methodType: "list"
      }),
      del: stripeMethod12({
        method: "DELETE",
        fullPath: "/v1/terminal/configurations/{configuration}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/ConfirmationTokens.js
var stripeMethod13, ConfirmationTokens;
var init_ConfirmationTokens = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/ConfirmationTokens.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod13 = StripeResource.method;
    ConfirmationTokens = StripeResource.extend({
      create: stripeMethod13({
        method: "POST",
        fullPath: "/v1/test_helpers/confirmation_tokens"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Terminal/ConnectionTokens.js
var stripeMethod14, ConnectionTokens;
var init_ConnectionTokens = __esm({
  "../node_modules/stripe/esm/resources/Terminal/ConnectionTokens.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod14 = StripeResource.method;
    ConnectionTokens = StripeResource.extend({
      create: stripeMethod14({
        method: "POST",
        fullPath: "/v1/terminal/connection_tokens"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Billing/CreditBalanceSummary.js
var stripeMethod15, CreditBalanceSummary;
var init_CreditBalanceSummary = __esm({
  "../node_modules/stripe/esm/resources/Billing/CreditBalanceSummary.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod15 = StripeResource.method;
    CreditBalanceSummary = StripeResource.extend({
      retrieve: stripeMethod15({
        method: "GET",
        fullPath: "/v1/billing/credit_balance_summary"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Billing/CreditBalanceTransactions.js
var stripeMethod16, CreditBalanceTransactions;
var init_CreditBalanceTransactions = __esm({
  "../node_modules/stripe/esm/resources/Billing/CreditBalanceTransactions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod16 = StripeResource.method;
    CreditBalanceTransactions = StripeResource.extend({
      retrieve: stripeMethod16({
        method: "GET",
        fullPath: "/v1/billing/credit_balance_transactions/{id}"
      }),
      list: stripeMethod16({
        method: "GET",
        fullPath: "/v1/billing/credit_balance_transactions",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Billing/CreditGrants.js
var stripeMethod17, CreditGrants;
var init_CreditGrants = __esm({
  "../node_modules/stripe/esm/resources/Billing/CreditGrants.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod17 = StripeResource.method;
    CreditGrants = StripeResource.extend({
      create: stripeMethod17({ method: "POST", fullPath: "/v1/billing/credit_grants" }),
      retrieve: stripeMethod17({
        method: "GET",
        fullPath: "/v1/billing/credit_grants/{id}"
      }),
      update: stripeMethod17({
        method: "POST",
        fullPath: "/v1/billing/credit_grants/{id}"
      }),
      list: stripeMethod17({
        method: "GET",
        fullPath: "/v1/billing/credit_grants",
        methodType: "list"
      }),
      expire: stripeMethod17({
        method: "POST",
        fullPath: "/v1/billing/credit_grants/{id}/expire"
      }),
      voidGrant: stripeMethod17({
        method: "POST",
        fullPath: "/v1/billing/credit_grants/{id}/void"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Treasury/CreditReversals.js
var stripeMethod18, CreditReversals;
var init_CreditReversals = __esm({
  "../node_modules/stripe/esm/resources/Treasury/CreditReversals.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod18 = StripeResource.method;
    CreditReversals = StripeResource.extend({
      create: stripeMethod18({
        method: "POST",
        fullPath: "/v1/treasury/credit_reversals"
      }),
      retrieve: stripeMethod18({
        method: "GET",
        fullPath: "/v1/treasury/credit_reversals/{credit_reversal}"
      }),
      list: stripeMethod18({
        method: "GET",
        fullPath: "/v1/treasury/credit_reversals",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/Customers.js
var stripeMethod19, Customers;
var init_Customers = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/Customers.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod19 = StripeResource.method;
    Customers = StripeResource.extend({
      fundCashBalance: stripeMethod19({
        method: "POST",
        fullPath: "/v1/test_helpers/customers/{customer}/fund_cash_balance"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Treasury/DebitReversals.js
var stripeMethod20, DebitReversals;
var init_DebitReversals = __esm({
  "../node_modules/stripe/esm/resources/Treasury/DebitReversals.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod20 = StripeResource.method;
    DebitReversals = StripeResource.extend({
      create: stripeMethod20({
        method: "POST",
        fullPath: "/v1/treasury/debit_reversals"
      }),
      retrieve: stripeMethod20({
        method: "GET",
        fullPath: "/v1/treasury/debit_reversals/{debit_reversal}"
      }),
      list: stripeMethod20({
        method: "GET",
        fullPath: "/v1/treasury/debit_reversals",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Issuing/Disputes.js
var stripeMethod21, Disputes;
var init_Disputes = __esm({
  "../node_modules/stripe/esm/resources/Issuing/Disputes.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod21 = StripeResource.method;
    Disputes = StripeResource.extend({
      create: stripeMethod21({ method: "POST", fullPath: "/v1/issuing/disputes" }),
      retrieve: stripeMethod21({
        method: "GET",
        fullPath: "/v1/issuing/disputes/{dispute}"
      }),
      update: stripeMethod21({
        method: "POST",
        fullPath: "/v1/issuing/disputes/{dispute}"
      }),
      list: stripeMethod21({
        method: "GET",
        fullPath: "/v1/issuing/disputes",
        methodType: "list"
      }),
      submit: stripeMethod21({
        method: "POST",
        fullPath: "/v1/issuing/disputes/{dispute}/submit"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Radar/EarlyFraudWarnings.js
var stripeMethod22, EarlyFraudWarnings;
var init_EarlyFraudWarnings = __esm({
  "../node_modules/stripe/esm/resources/Radar/EarlyFraudWarnings.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod22 = StripeResource.method;
    EarlyFraudWarnings = StripeResource.extend({
      retrieve: stripeMethod22({
        method: "GET",
        fullPath: "/v1/radar/early_fraud_warnings/{early_fraud_warning}"
      }),
      list: stripeMethod22({
        method: "GET",
        fullPath: "/v1/radar/early_fraud_warnings",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/V2/Core/EventDestinations.js
var stripeMethod23, EventDestinations;
var init_EventDestinations = __esm({
  "../node_modules/stripe/esm/resources/V2/Core/EventDestinations.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod23 = StripeResource.method;
    EventDestinations = StripeResource.extend({
      create: stripeMethod23({
        method: "POST",
        fullPath: "/v2/core/event_destinations"
      }),
      retrieve: stripeMethod23({
        method: "GET",
        fullPath: "/v2/core/event_destinations/{id}"
      }),
      update: stripeMethod23({
        method: "POST",
        fullPath: "/v2/core/event_destinations/{id}"
      }),
      list: stripeMethod23({
        method: "GET",
        fullPath: "/v2/core/event_destinations",
        methodType: "list"
      }),
      del: stripeMethod23({
        method: "DELETE",
        fullPath: "/v2/core/event_destinations/{id}"
      }),
      disable: stripeMethod23({
        method: "POST",
        fullPath: "/v2/core/event_destinations/{id}/disable"
      }),
      enable: stripeMethod23({
        method: "POST",
        fullPath: "/v2/core/event_destinations/{id}/enable"
      }),
      ping: stripeMethod23({
        method: "POST",
        fullPath: "/v2/core/event_destinations/{id}/ping"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/V2/Core/Events.js
var stripeMethod24, Events;
var init_Events = __esm({
  "../node_modules/stripe/esm/resources/V2/Core/Events.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod24 = StripeResource.method;
    Events = StripeResource.extend({
      retrieve(...args) {
        const transformResponseData = /* @__PURE__ */ __name((response) => {
          return this.addFetchRelatedObjectIfNeeded(response);
        }, "transformResponseData");
        return stripeMethod24({
          method: "GET",
          fullPath: "/v2/core/events/{id}",
          transformResponseData
        }).apply(this, args);
      },
      list(...args) {
        const transformResponseData = /* @__PURE__ */ __name((response) => {
          return Object.assign(Object.assign({}, response), { data: response.data.map(this.addFetchRelatedObjectIfNeeded.bind(this)) });
        }, "transformResponseData");
        return stripeMethod24({
          method: "GET",
          fullPath: "/v2/core/events",
          methodType: "list",
          transformResponseData
        }).apply(this, args);
      },
      /**
       * @private
       *
       * For internal use in stripe-node.
       *
       * @param pulledEvent The retrieved event object
       * @returns The retrieved event object with a fetchRelatedObject method,
       * if pulledEvent.related_object is valid (non-null and has a url)
       */
      addFetchRelatedObjectIfNeeded(pulledEvent) {
        if (!pulledEvent.related_object || !pulledEvent.related_object.url) {
          return pulledEvent;
        }
        return Object.assign(Object.assign({}, pulledEvent), { fetchRelatedObject: /* @__PURE__ */ __name(() => (
          // call stripeMethod with 'this' resource to fetch
          // the related object. 'this' is needed to construct
          // and send the request, but the method spec controls
          // the url endpoint and method, so it doesn't matter
          // that 'this' is an Events resource object here
          stripeMethod24({
            method: "GET",
            fullPath: pulledEvent.related_object.url
          }).apply(this, [
            {
              stripeAccount: pulledEvent.context
            }
          ])
        ), "fetchRelatedObject") });
      }
    });
  }
});

// ../node_modules/stripe/esm/resources/Entitlements/Features.js
var stripeMethod25, Features;
var init_Features = __esm({
  "../node_modules/stripe/esm/resources/Entitlements/Features.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod25 = StripeResource.method;
    Features = StripeResource.extend({
      create: stripeMethod25({ method: "POST", fullPath: "/v1/entitlements/features" }),
      retrieve: stripeMethod25({
        method: "GET",
        fullPath: "/v1/entitlements/features/{id}"
      }),
      update: stripeMethod25({
        method: "POST",
        fullPath: "/v1/entitlements/features/{id}"
      }),
      list: stripeMethod25({
        method: "GET",
        fullPath: "/v1/entitlements/features",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Treasury/FinancialAccounts.js
var stripeMethod26, FinancialAccounts;
var init_FinancialAccounts = __esm({
  "../node_modules/stripe/esm/resources/Treasury/FinancialAccounts.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod26 = StripeResource.method;
    FinancialAccounts = StripeResource.extend({
      create: stripeMethod26({
        method: "POST",
        fullPath: "/v1/treasury/financial_accounts"
      }),
      retrieve: stripeMethod26({
        method: "GET",
        fullPath: "/v1/treasury/financial_accounts/{financial_account}"
      }),
      update: stripeMethod26({
        method: "POST",
        fullPath: "/v1/treasury/financial_accounts/{financial_account}"
      }),
      list: stripeMethod26({
        method: "GET",
        fullPath: "/v1/treasury/financial_accounts",
        methodType: "list"
      }),
      close: stripeMethod26({
        method: "POST",
        fullPath: "/v1/treasury/financial_accounts/{financial_account}/close"
      }),
      retrieveFeatures: stripeMethod26({
        method: "GET",
        fullPath: "/v1/treasury/financial_accounts/{financial_account}/features"
      }),
      updateFeatures: stripeMethod26({
        method: "POST",
        fullPath: "/v1/treasury/financial_accounts/{financial_account}/features"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/Treasury/InboundTransfers.js
var stripeMethod27, InboundTransfers;
var init_InboundTransfers = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/Treasury/InboundTransfers.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod27 = StripeResource.method;
    InboundTransfers = StripeResource.extend({
      fail: stripeMethod27({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/inbound_transfers/{id}/fail"
      }),
      returnInboundTransfer: stripeMethod27({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/inbound_transfers/{id}/return"
      }),
      succeed: stripeMethod27({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/inbound_transfers/{id}/succeed"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Treasury/InboundTransfers.js
var stripeMethod28, InboundTransfers2;
var init_InboundTransfers2 = __esm({
  "../node_modules/stripe/esm/resources/Treasury/InboundTransfers.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod28 = StripeResource.method;
    InboundTransfers2 = StripeResource.extend({
      create: stripeMethod28({
        method: "POST",
        fullPath: "/v1/treasury/inbound_transfers"
      }),
      retrieve: stripeMethod28({
        method: "GET",
        fullPath: "/v1/treasury/inbound_transfers/{id}"
      }),
      list: stripeMethod28({
        method: "GET",
        fullPath: "/v1/treasury/inbound_transfers",
        methodType: "list"
      }),
      cancel: stripeMethod28({
        method: "POST",
        fullPath: "/v1/treasury/inbound_transfers/{inbound_transfer}/cancel"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Terminal/Locations.js
var stripeMethod29, Locations;
var init_Locations = __esm({
  "../node_modules/stripe/esm/resources/Terminal/Locations.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod29 = StripeResource.method;
    Locations = StripeResource.extend({
      create: stripeMethod29({ method: "POST", fullPath: "/v1/terminal/locations" }),
      retrieve: stripeMethod29({
        method: "GET",
        fullPath: "/v1/terminal/locations/{location}"
      }),
      update: stripeMethod29({
        method: "POST",
        fullPath: "/v1/terminal/locations/{location}"
      }),
      list: stripeMethod29({
        method: "GET",
        fullPath: "/v1/terminal/locations",
        methodType: "list"
      }),
      del: stripeMethod29({
        method: "DELETE",
        fullPath: "/v1/terminal/locations/{location}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Billing/MeterEventAdjustments.js
var stripeMethod30, MeterEventAdjustments;
var init_MeterEventAdjustments = __esm({
  "../node_modules/stripe/esm/resources/Billing/MeterEventAdjustments.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod30 = StripeResource.method;
    MeterEventAdjustments = StripeResource.extend({
      create: stripeMethod30({
        method: "POST",
        fullPath: "/v1/billing/meter_event_adjustments"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/V2/Billing/MeterEventAdjustments.js
var stripeMethod31, MeterEventAdjustments2;
var init_MeterEventAdjustments2 = __esm({
  "../node_modules/stripe/esm/resources/V2/Billing/MeterEventAdjustments.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod31 = StripeResource.method;
    MeterEventAdjustments2 = StripeResource.extend({
      create: stripeMethod31({
        method: "POST",
        fullPath: "/v2/billing/meter_event_adjustments"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/V2/Billing/MeterEventSession.js
var stripeMethod32, MeterEventSession;
var init_MeterEventSession = __esm({
  "../node_modules/stripe/esm/resources/V2/Billing/MeterEventSession.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod32 = StripeResource.method;
    MeterEventSession = StripeResource.extend({
      create: stripeMethod32({
        method: "POST",
        fullPath: "/v2/billing/meter_event_session"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/V2/Billing/MeterEventStream.js
var stripeMethod33, MeterEventStream;
var init_MeterEventStream = __esm({
  "../node_modules/stripe/esm/resources/V2/Billing/MeterEventStream.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod33 = StripeResource.method;
    MeterEventStream = StripeResource.extend({
      create: stripeMethod33({
        method: "POST",
        fullPath: "/v2/billing/meter_event_stream",
        host: "meter-events.stripe.com"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Billing/MeterEvents.js
var stripeMethod34, MeterEvents;
var init_MeterEvents = __esm({
  "../node_modules/stripe/esm/resources/Billing/MeterEvents.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod34 = StripeResource.method;
    MeterEvents = StripeResource.extend({
      create: stripeMethod34({ method: "POST", fullPath: "/v1/billing/meter_events" })
    });
  }
});

// ../node_modules/stripe/esm/resources/V2/Billing/MeterEvents.js
var stripeMethod35, MeterEvents2;
var init_MeterEvents2 = __esm({
  "../node_modules/stripe/esm/resources/V2/Billing/MeterEvents.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod35 = StripeResource.method;
    MeterEvents2 = StripeResource.extend({
      create: stripeMethod35({ method: "POST", fullPath: "/v2/billing/meter_events" })
    });
  }
});

// ../node_modules/stripe/esm/resources/Billing/Meters.js
var stripeMethod36, Meters;
var init_Meters = __esm({
  "../node_modules/stripe/esm/resources/Billing/Meters.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod36 = StripeResource.method;
    Meters = StripeResource.extend({
      create: stripeMethod36({ method: "POST", fullPath: "/v1/billing/meters" }),
      retrieve: stripeMethod36({ method: "GET", fullPath: "/v1/billing/meters/{id}" }),
      update: stripeMethod36({ method: "POST", fullPath: "/v1/billing/meters/{id}" }),
      list: stripeMethod36({
        method: "GET",
        fullPath: "/v1/billing/meters",
        methodType: "list"
      }),
      deactivate: stripeMethod36({
        method: "POST",
        fullPath: "/v1/billing/meters/{id}/deactivate"
      }),
      listEventSummaries: stripeMethod36({
        method: "GET",
        fullPath: "/v1/billing/meters/{id}/event_summaries",
        methodType: "list"
      }),
      reactivate: stripeMethod36({
        method: "POST",
        fullPath: "/v1/billing/meters/{id}/reactivate"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Climate/Orders.js
var stripeMethod37, Orders;
var init_Orders = __esm({
  "../node_modules/stripe/esm/resources/Climate/Orders.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod37 = StripeResource.method;
    Orders = StripeResource.extend({
      create: stripeMethod37({ method: "POST", fullPath: "/v1/climate/orders" }),
      retrieve: stripeMethod37({
        method: "GET",
        fullPath: "/v1/climate/orders/{order}"
      }),
      update: stripeMethod37({
        method: "POST",
        fullPath: "/v1/climate/orders/{order}"
      }),
      list: stripeMethod37({
        method: "GET",
        fullPath: "/v1/climate/orders",
        methodType: "list"
      }),
      cancel: stripeMethod37({
        method: "POST",
        fullPath: "/v1/climate/orders/{order}/cancel"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/Treasury/OutboundPayments.js
var stripeMethod38, OutboundPayments;
var init_OutboundPayments = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/Treasury/OutboundPayments.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod38 = StripeResource.method;
    OutboundPayments = StripeResource.extend({
      update: stripeMethod38({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}"
      }),
      fail: stripeMethod38({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}/fail"
      }),
      post: stripeMethod38({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}/post"
      }),
      returnOutboundPayment: stripeMethod38({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}/return"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Treasury/OutboundPayments.js
var stripeMethod39, OutboundPayments2;
var init_OutboundPayments2 = __esm({
  "../node_modules/stripe/esm/resources/Treasury/OutboundPayments.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod39 = StripeResource.method;
    OutboundPayments2 = StripeResource.extend({
      create: stripeMethod39({
        method: "POST",
        fullPath: "/v1/treasury/outbound_payments"
      }),
      retrieve: stripeMethod39({
        method: "GET",
        fullPath: "/v1/treasury/outbound_payments/{id}"
      }),
      list: stripeMethod39({
        method: "GET",
        fullPath: "/v1/treasury/outbound_payments",
        methodType: "list"
      }),
      cancel: stripeMethod39({
        method: "POST",
        fullPath: "/v1/treasury/outbound_payments/{id}/cancel"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/Treasury/OutboundTransfers.js
var stripeMethod40, OutboundTransfers;
var init_OutboundTransfers = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/Treasury/OutboundTransfers.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod40 = StripeResource.method;
    OutboundTransfers = StripeResource.extend({
      update: stripeMethod40({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}"
      }),
      fail: stripeMethod40({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/fail"
      }),
      post: stripeMethod40({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/post"
      }),
      returnOutboundTransfer: stripeMethod40({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/return"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Treasury/OutboundTransfers.js
var stripeMethod41, OutboundTransfers2;
var init_OutboundTransfers2 = __esm({
  "../node_modules/stripe/esm/resources/Treasury/OutboundTransfers.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod41 = StripeResource.method;
    OutboundTransfers2 = StripeResource.extend({
      create: stripeMethod41({
        method: "POST",
        fullPath: "/v1/treasury/outbound_transfers"
      }),
      retrieve: stripeMethod41({
        method: "GET",
        fullPath: "/v1/treasury/outbound_transfers/{outbound_transfer}"
      }),
      list: stripeMethod41({
        method: "GET",
        fullPath: "/v1/treasury/outbound_transfers",
        methodType: "list"
      }),
      cancel: stripeMethod41({
        method: "POST",
        fullPath: "/v1/treasury/outbound_transfers/{outbound_transfer}/cancel"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/Issuing/PersonalizationDesigns.js
var stripeMethod42, PersonalizationDesigns;
var init_PersonalizationDesigns = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/Issuing/PersonalizationDesigns.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod42 = StripeResource.method;
    PersonalizationDesigns = StripeResource.extend({
      activate: stripeMethod42({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/personalization_designs/{personalization_design}/activate"
      }),
      deactivate: stripeMethod42({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/personalization_designs/{personalization_design}/deactivate"
      }),
      reject: stripeMethod42({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/personalization_designs/{personalization_design}/reject"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Issuing/PersonalizationDesigns.js
var stripeMethod43, PersonalizationDesigns2;
var init_PersonalizationDesigns2 = __esm({
  "../node_modules/stripe/esm/resources/Issuing/PersonalizationDesigns.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod43 = StripeResource.method;
    PersonalizationDesigns2 = StripeResource.extend({
      create: stripeMethod43({
        method: "POST",
        fullPath: "/v1/issuing/personalization_designs"
      }),
      retrieve: stripeMethod43({
        method: "GET",
        fullPath: "/v1/issuing/personalization_designs/{personalization_design}"
      }),
      update: stripeMethod43({
        method: "POST",
        fullPath: "/v1/issuing/personalization_designs/{personalization_design}"
      }),
      list: stripeMethod43({
        method: "GET",
        fullPath: "/v1/issuing/personalization_designs",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Issuing/PhysicalBundles.js
var stripeMethod44, PhysicalBundles;
var init_PhysicalBundles = __esm({
  "../node_modules/stripe/esm/resources/Issuing/PhysicalBundles.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod44 = StripeResource.method;
    PhysicalBundles = StripeResource.extend({
      retrieve: stripeMethod44({
        method: "GET",
        fullPath: "/v1/issuing/physical_bundles/{physical_bundle}"
      }),
      list: stripeMethod44({
        method: "GET",
        fullPath: "/v1/issuing/physical_bundles",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Climate/Products.js
var stripeMethod45, Products;
var init_Products = __esm({
  "../node_modules/stripe/esm/resources/Climate/Products.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod45 = StripeResource.method;
    Products = StripeResource.extend({
      retrieve: stripeMethod45({
        method: "GET",
        fullPath: "/v1/climate/products/{product}"
      }),
      list: stripeMethod45({
        method: "GET",
        fullPath: "/v1/climate/products",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/Terminal/Readers.js
var stripeMethod46, Readers;
var init_Readers = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/Terminal/Readers.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod46 = StripeResource.method;
    Readers = StripeResource.extend({
      presentPaymentMethod: stripeMethod46({
        method: "POST",
        fullPath: "/v1/test_helpers/terminal/readers/{reader}/present_payment_method"
      }),
      succeedInputCollection: stripeMethod46({
        method: "POST",
        fullPath: "/v1/test_helpers/terminal/readers/{reader}/succeed_input_collection"
      }),
      timeoutInputCollection: stripeMethod46({
        method: "POST",
        fullPath: "/v1/test_helpers/terminal/readers/{reader}/timeout_input_collection"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Terminal/Readers.js
var stripeMethod47, Readers2;
var init_Readers2 = __esm({
  "../node_modules/stripe/esm/resources/Terminal/Readers.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod47 = StripeResource.method;
    Readers2 = StripeResource.extend({
      create: stripeMethod47({ method: "POST", fullPath: "/v1/terminal/readers" }),
      retrieve: stripeMethod47({
        method: "GET",
        fullPath: "/v1/terminal/readers/{reader}"
      }),
      update: stripeMethod47({
        method: "POST",
        fullPath: "/v1/terminal/readers/{reader}"
      }),
      list: stripeMethod47({
        method: "GET",
        fullPath: "/v1/terminal/readers",
        methodType: "list"
      }),
      del: stripeMethod47({
        method: "DELETE",
        fullPath: "/v1/terminal/readers/{reader}"
      }),
      cancelAction: stripeMethod47({
        method: "POST",
        fullPath: "/v1/terminal/readers/{reader}/cancel_action"
      }),
      collectInputs: stripeMethod47({
        method: "POST",
        fullPath: "/v1/terminal/readers/{reader}/collect_inputs"
      }),
      collectPaymentMethod: stripeMethod47({
        method: "POST",
        fullPath: "/v1/terminal/readers/{reader}/collect_payment_method"
      }),
      confirmPaymentIntent: stripeMethod47({
        method: "POST",
        fullPath: "/v1/terminal/readers/{reader}/confirm_payment_intent"
      }),
      processPaymentIntent: stripeMethod47({
        method: "POST",
        fullPath: "/v1/terminal/readers/{reader}/process_payment_intent"
      }),
      processSetupIntent: stripeMethod47({
        method: "POST",
        fullPath: "/v1/terminal/readers/{reader}/process_setup_intent"
      }),
      refundPayment: stripeMethod47({
        method: "POST",
        fullPath: "/v1/terminal/readers/{reader}/refund_payment"
      }),
      setReaderDisplay: stripeMethod47({
        method: "POST",
        fullPath: "/v1/terminal/readers/{reader}/set_reader_display"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/Treasury/ReceivedCredits.js
var stripeMethod48, ReceivedCredits;
var init_ReceivedCredits = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/Treasury/ReceivedCredits.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod48 = StripeResource.method;
    ReceivedCredits = StripeResource.extend({
      create: stripeMethod48({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/received_credits"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Treasury/ReceivedCredits.js
var stripeMethod49, ReceivedCredits2;
var init_ReceivedCredits2 = __esm({
  "../node_modules/stripe/esm/resources/Treasury/ReceivedCredits.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod49 = StripeResource.method;
    ReceivedCredits2 = StripeResource.extend({
      retrieve: stripeMethod49({
        method: "GET",
        fullPath: "/v1/treasury/received_credits/{id}"
      }),
      list: stripeMethod49({
        method: "GET",
        fullPath: "/v1/treasury/received_credits",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/Treasury/ReceivedDebits.js
var stripeMethod50, ReceivedDebits;
var init_ReceivedDebits = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/Treasury/ReceivedDebits.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod50 = StripeResource.method;
    ReceivedDebits = StripeResource.extend({
      create: stripeMethod50({
        method: "POST",
        fullPath: "/v1/test_helpers/treasury/received_debits"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Treasury/ReceivedDebits.js
var stripeMethod51, ReceivedDebits2;
var init_ReceivedDebits2 = __esm({
  "../node_modules/stripe/esm/resources/Treasury/ReceivedDebits.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod51 = StripeResource.method;
    ReceivedDebits2 = StripeResource.extend({
      retrieve: stripeMethod51({
        method: "GET",
        fullPath: "/v1/treasury/received_debits/{id}"
      }),
      list: stripeMethod51({
        method: "GET",
        fullPath: "/v1/treasury/received_debits",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/Refunds.js
var stripeMethod52, Refunds;
var init_Refunds = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/Refunds.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod52 = StripeResource.method;
    Refunds = StripeResource.extend({
      expire: stripeMethod52({
        method: "POST",
        fullPath: "/v1/test_helpers/refunds/{refund}/expire"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Tax/Registrations.js
var stripeMethod53, Registrations;
var init_Registrations = __esm({
  "../node_modules/stripe/esm/resources/Tax/Registrations.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod53 = StripeResource.method;
    Registrations = StripeResource.extend({
      create: stripeMethod53({ method: "POST", fullPath: "/v1/tax/registrations" }),
      retrieve: stripeMethod53({
        method: "GET",
        fullPath: "/v1/tax/registrations/{id}"
      }),
      update: stripeMethod53({
        method: "POST",
        fullPath: "/v1/tax/registrations/{id}"
      }),
      list: stripeMethod53({
        method: "GET",
        fullPath: "/v1/tax/registrations",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Reporting/ReportRuns.js
var stripeMethod54, ReportRuns;
var init_ReportRuns = __esm({
  "../node_modules/stripe/esm/resources/Reporting/ReportRuns.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod54 = StripeResource.method;
    ReportRuns = StripeResource.extend({
      create: stripeMethod54({ method: "POST", fullPath: "/v1/reporting/report_runs" }),
      retrieve: stripeMethod54({
        method: "GET",
        fullPath: "/v1/reporting/report_runs/{report_run}"
      }),
      list: stripeMethod54({
        method: "GET",
        fullPath: "/v1/reporting/report_runs",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Reporting/ReportTypes.js
var stripeMethod55, ReportTypes;
var init_ReportTypes = __esm({
  "../node_modules/stripe/esm/resources/Reporting/ReportTypes.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod55 = StripeResource.method;
    ReportTypes = StripeResource.extend({
      retrieve: stripeMethod55({
        method: "GET",
        fullPath: "/v1/reporting/report_types/{report_type}"
      }),
      list: stripeMethod55({
        method: "GET",
        fullPath: "/v1/reporting/report_types",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Forwarding/Requests.js
var stripeMethod56, Requests;
var init_Requests = __esm({
  "../node_modules/stripe/esm/resources/Forwarding/Requests.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod56 = StripeResource.method;
    Requests = StripeResource.extend({
      create: stripeMethod56({ method: "POST", fullPath: "/v1/forwarding/requests" }),
      retrieve: stripeMethod56({
        method: "GET",
        fullPath: "/v1/forwarding/requests/{id}"
      }),
      list: stripeMethod56({
        method: "GET",
        fullPath: "/v1/forwarding/requests",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Sigma/ScheduledQueryRuns.js
var stripeMethod57, ScheduledQueryRuns;
var init_ScheduledQueryRuns = __esm({
  "../node_modules/stripe/esm/resources/Sigma/ScheduledQueryRuns.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod57 = StripeResource.method;
    ScheduledQueryRuns = StripeResource.extend({
      retrieve: stripeMethod57({
        method: "GET",
        fullPath: "/v1/sigma/scheduled_query_runs/{scheduled_query_run}"
      }),
      list: stripeMethod57({
        method: "GET",
        fullPath: "/v1/sigma/scheduled_query_runs",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Apps/Secrets.js
var stripeMethod58, Secrets;
var init_Secrets = __esm({
  "../node_modules/stripe/esm/resources/Apps/Secrets.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod58 = StripeResource.method;
    Secrets = StripeResource.extend({
      create: stripeMethod58({ method: "POST", fullPath: "/v1/apps/secrets" }),
      list: stripeMethod58({
        method: "GET",
        fullPath: "/v1/apps/secrets",
        methodType: "list"
      }),
      deleteWhere: stripeMethod58({
        method: "POST",
        fullPath: "/v1/apps/secrets/delete"
      }),
      find: stripeMethod58({ method: "GET", fullPath: "/v1/apps/secrets/find" })
    });
  }
});

// ../node_modules/stripe/esm/resources/BillingPortal/Sessions.js
var stripeMethod59, Sessions;
var init_Sessions = __esm({
  "../node_modules/stripe/esm/resources/BillingPortal/Sessions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod59 = StripeResource.method;
    Sessions = StripeResource.extend({
      create: stripeMethod59({
        method: "POST",
        fullPath: "/v1/billing_portal/sessions"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Checkout/Sessions.js
var stripeMethod60, Sessions2;
var init_Sessions2 = __esm({
  "../node_modules/stripe/esm/resources/Checkout/Sessions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod60 = StripeResource.method;
    Sessions2 = StripeResource.extend({
      create: stripeMethod60({ method: "POST", fullPath: "/v1/checkout/sessions" }),
      retrieve: stripeMethod60({
        method: "GET",
        fullPath: "/v1/checkout/sessions/{session}"
      }),
      update: stripeMethod60({
        method: "POST",
        fullPath: "/v1/checkout/sessions/{session}"
      }),
      list: stripeMethod60({
        method: "GET",
        fullPath: "/v1/checkout/sessions",
        methodType: "list"
      }),
      expire: stripeMethod60({
        method: "POST",
        fullPath: "/v1/checkout/sessions/{session}/expire"
      }),
      listLineItems: stripeMethod60({
        method: "GET",
        fullPath: "/v1/checkout/sessions/{session}/line_items",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/FinancialConnections/Sessions.js
var stripeMethod61, Sessions3;
var init_Sessions3 = __esm({
  "../node_modules/stripe/esm/resources/FinancialConnections/Sessions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod61 = StripeResource.method;
    Sessions3 = StripeResource.extend({
      create: stripeMethod61({
        method: "POST",
        fullPath: "/v1/financial_connections/sessions"
      }),
      retrieve: stripeMethod61({
        method: "GET",
        fullPath: "/v1/financial_connections/sessions/{session}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Tax/Settings.js
var stripeMethod62, Settings;
var init_Settings = __esm({
  "../node_modules/stripe/esm/resources/Tax/Settings.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod62 = StripeResource.method;
    Settings = StripeResource.extend({
      retrieve: stripeMethod62({ method: "GET", fullPath: "/v1/tax/settings" }),
      update: stripeMethod62({ method: "POST", fullPath: "/v1/tax/settings" })
    });
  }
});

// ../node_modules/stripe/esm/resources/Climate/Suppliers.js
var stripeMethod63, Suppliers;
var init_Suppliers = __esm({
  "../node_modules/stripe/esm/resources/Climate/Suppliers.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod63 = StripeResource.method;
    Suppliers = StripeResource.extend({
      retrieve: stripeMethod63({
        method: "GET",
        fullPath: "/v1/climate/suppliers/{supplier}"
      }),
      list: stripeMethod63({
        method: "GET",
        fullPath: "/v1/climate/suppliers",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/TestClocks.js
var stripeMethod64, TestClocks;
var init_TestClocks = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/TestClocks.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod64 = StripeResource.method;
    TestClocks = StripeResource.extend({
      create: stripeMethod64({
        method: "POST",
        fullPath: "/v1/test_helpers/test_clocks"
      }),
      retrieve: stripeMethod64({
        method: "GET",
        fullPath: "/v1/test_helpers/test_clocks/{test_clock}"
      }),
      list: stripeMethod64({
        method: "GET",
        fullPath: "/v1/test_helpers/test_clocks",
        methodType: "list"
      }),
      del: stripeMethod64({
        method: "DELETE",
        fullPath: "/v1/test_helpers/test_clocks/{test_clock}"
      }),
      advance: stripeMethod64({
        method: "POST",
        fullPath: "/v1/test_helpers/test_clocks/{test_clock}/advance"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Issuing/Tokens.js
var stripeMethod65, Tokens;
var init_Tokens = __esm({
  "../node_modules/stripe/esm/resources/Issuing/Tokens.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod65 = StripeResource.method;
    Tokens = StripeResource.extend({
      retrieve: stripeMethod65({
        method: "GET",
        fullPath: "/v1/issuing/tokens/{token}"
      }),
      update: stripeMethod65({
        method: "POST",
        fullPath: "/v1/issuing/tokens/{token}"
      }),
      list: stripeMethod65({
        method: "GET",
        fullPath: "/v1/issuing/tokens",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Treasury/TransactionEntries.js
var stripeMethod66, TransactionEntries;
var init_TransactionEntries = __esm({
  "../node_modules/stripe/esm/resources/Treasury/TransactionEntries.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod66 = StripeResource.method;
    TransactionEntries = StripeResource.extend({
      retrieve: stripeMethod66({
        method: "GET",
        fullPath: "/v1/treasury/transaction_entries/{id}"
      }),
      list: stripeMethod66({
        method: "GET",
        fullPath: "/v1/treasury/transaction_entries",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TestHelpers/Issuing/Transactions.js
var stripeMethod67, Transactions;
var init_Transactions = __esm({
  "../node_modules/stripe/esm/resources/TestHelpers/Issuing/Transactions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod67 = StripeResource.method;
    Transactions = StripeResource.extend({
      createForceCapture: stripeMethod67({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/transactions/create_force_capture"
      }),
      createUnlinkedRefund: stripeMethod67({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/transactions/create_unlinked_refund"
      }),
      refund: stripeMethod67({
        method: "POST",
        fullPath: "/v1/test_helpers/issuing/transactions/{transaction}/refund"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/FinancialConnections/Transactions.js
var stripeMethod68, Transactions2;
var init_Transactions2 = __esm({
  "../node_modules/stripe/esm/resources/FinancialConnections/Transactions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod68 = StripeResource.method;
    Transactions2 = StripeResource.extend({
      retrieve: stripeMethod68({
        method: "GET",
        fullPath: "/v1/financial_connections/transactions/{transaction}"
      }),
      list: stripeMethod68({
        method: "GET",
        fullPath: "/v1/financial_connections/transactions",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Issuing/Transactions.js
var stripeMethod69, Transactions3;
var init_Transactions3 = __esm({
  "../node_modules/stripe/esm/resources/Issuing/Transactions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod69 = StripeResource.method;
    Transactions3 = StripeResource.extend({
      retrieve: stripeMethod69({
        method: "GET",
        fullPath: "/v1/issuing/transactions/{transaction}"
      }),
      update: stripeMethod69({
        method: "POST",
        fullPath: "/v1/issuing/transactions/{transaction}"
      }),
      list: stripeMethod69({
        method: "GET",
        fullPath: "/v1/issuing/transactions",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Tax/Transactions.js
var stripeMethod70, Transactions4;
var init_Transactions4 = __esm({
  "../node_modules/stripe/esm/resources/Tax/Transactions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod70 = StripeResource.method;
    Transactions4 = StripeResource.extend({
      retrieve: stripeMethod70({
        method: "GET",
        fullPath: "/v1/tax/transactions/{transaction}"
      }),
      createFromCalculation: stripeMethod70({
        method: "POST",
        fullPath: "/v1/tax/transactions/create_from_calculation"
      }),
      createReversal: stripeMethod70({
        method: "POST",
        fullPath: "/v1/tax/transactions/create_reversal"
      }),
      listLineItems: stripeMethod70({
        method: "GET",
        fullPath: "/v1/tax/transactions/{transaction}/line_items",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Treasury/Transactions.js
var stripeMethod71, Transactions5;
var init_Transactions5 = __esm({
  "../node_modules/stripe/esm/resources/Treasury/Transactions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod71 = StripeResource.method;
    Transactions5 = StripeResource.extend({
      retrieve: stripeMethod71({
        method: "GET",
        fullPath: "/v1/treasury/transactions/{id}"
      }),
      list: stripeMethod71({
        method: "GET",
        fullPath: "/v1/treasury/transactions",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Radar/ValueListItems.js
var stripeMethod72, ValueListItems;
var init_ValueListItems = __esm({
  "../node_modules/stripe/esm/resources/Radar/ValueListItems.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod72 = StripeResource.method;
    ValueListItems = StripeResource.extend({
      create: stripeMethod72({
        method: "POST",
        fullPath: "/v1/radar/value_list_items"
      }),
      retrieve: stripeMethod72({
        method: "GET",
        fullPath: "/v1/radar/value_list_items/{item}"
      }),
      list: stripeMethod72({
        method: "GET",
        fullPath: "/v1/radar/value_list_items",
        methodType: "list"
      }),
      del: stripeMethod72({
        method: "DELETE",
        fullPath: "/v1/radar/value_list_items/{item}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Radar/ValueLists.js
var stripeMethod73, ValueLists;
var init_ValueLists = __esm({
  "../node_modules/stripe/esm/resources/Radar/ValueLists.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod73 = StripeResource.method;
    ValueLists = StripeResource.extend({
      create: stripeMethod73({ method: "POST", fullPath: "/v1/radar/value_lists" }),
      retrieve: stripeMethod73({
        method: "GET",
        fullPath: "/v1/radar/value_lists/{value_list}"
      }),
      update: stripeMethod73({
        method: "POST",
        fullPath: "/v1/radar/value_lists/{value_list}"
      }),
      list: stripeMethod73({
        method: "GET",
        fullPath: "/v1/radar/value_lists",
        methodType: "list"
      }),
      del: stripeMethod73({
        method: "DELETE",
        fullPath: "/v1/radar/value_lists/{value_list}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Identity/VerificationReports.js
var stripeMethod74, VerificationReports;
var init_VerificationReports = __esm({
  "../node_modules/stripe/esm/resources/Identity/VerificationReports.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod74 = StripeResource.method;
    VerificationReports = StripeResource.extend({
      retrieve: stripeMethod74({
        method: "GET",
        fullPath: "/v1/identity/verification_reports/{report}"
      }),
      list: stripeMethod74({
        method: "GET",
        fullPath: "/v1/identity/verification_reports",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Identity/VerificationSessions.js
var stripeMethod75, VerificationSessions;
var init_VerificationSessions = __esm({
  "../node_modules/stripe/esm/resources/Identity/VerificationSessions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod75 = StripeResource.method;
    VerificationSessions = StripeResource.extend({
      create: stripeMethod75({
        method: "POST",
        fullPath: "/v1/identity/verification_sessions"
      }),
      retrieve: stripeMethod75({
        method: "GET",
        fullPath: "/v1/identity/verification_sessions/{session}"
      }),
      update: stripeMethod75({
        method: "POST",
        fullPath: "/v1/identity/verification_sessions/{session}"
      }),
      list: stripeMethod75({
        method: "GET",
        fullPath: "/v1/identity/verification_sessions",
        methodType: "list"
      }),
      cancel: stripeMethod75({
        method: "POST",
        fullPath: "/v1/identity/verification_sessions/{session}/cancel"
      }),
      redact: stripeMethod75({
        method: "POST",
        fullPath: "/v1/identity/verification_sessions/{session}/redact"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Accounts.js
var stripeMethod76, Accounts2;
var init_Accounts2 = __esm({
  "../node_modules/stripe/esm/resources/Accounts.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod76 = StripeResource.method;
    Accounts2 = StripeResource.extend({
      create: stripeMethod76({ method: "POST", fullPath: "/v1/accounts" }),
      retrieve(id, ...args) {
        if (typeof id === "string") {
          return stripeMethod76({
            method: "GET",
            fullPath: "/v1/accounts/{id}"
          }).apply(this, [id, ...args]);
        } else {
          if (id === null || id === void 0) {
            [].shift.apply([id, ...args]);
          }
          return stripeMethod76({
            method: "GET",
            fullPath: "/v1/account"
          }).apply(this, [id, ...args]);
        }
      },
      update: stripeMethod76({ method: "POST", fullPath: "/v1/accounts/{account}" }),
      list: stripeMethod76({
        method: "GET",
        fullPath: "/v1/accounts",
        methodType: "list"
      }),
      del: stripeMethod76({ method: "DELETE", fullPath: "/v1/accounts/{account}" }),
      createExternalAccount: stripeMethod76({
        method: "POST",
        fullPath: "/v1/accounts/{account}/external_accounts"
      }),
      createLoginLink: stripeMethod76({
        method: "POST",
        fullPath: "/v1/accounts/{account}/login_links"
      }),
      createPerson: stripeMethod76({
        method: "POST",
        fullPath: "/v1/accounts/{account}/persons"
      }),
      deleteExternalAccount: stripeMethod76({
        method: "DELETE",
        fullPath: "/v1/accounts/{account}/external_accounts/{id}"
      }),
      deletePerson: stripeMethod76({
        method: "DELETE",
        fullPath: "/v1/accounts/{account}/persons/{person}"
      }),
      listCapabilities: stripeMethod76({
        method: "GET",
        fullPath: "/v1/accounts/{account}/capabilities",
        methodType: "list"
      }),
      listExternalAccounts: stripeMethod76({
        method: "GET",
        fullPath: "/v1/accounts/{account}/external_accounts",
        methodType: "list"
      }),
      listPersons: stripeMethod76({
        method: "GET",
        fullPath: "/v1/accounts/{account}/persons",
        methodType: "list"
      }),
      reject: stripeMethod76({
        method: "POST",
        fullPath: "/v1/accounts/{account}/reject"
      }),
      retrieveCurrent: stripeMethod76({ method: "GET", fullPath: "/v1/account" }),
      retrieveCapability: stripeMethod76({
        method: "GET",
        fullPath: "/v1/accounts/{account}/capabilities/{capability}"
      }),
      retrieveExternalAccount: stripeMethod76({
        method: "GET",
        fullPath: "/v1/accounts/{account}/external_accounts/{id}"
      }),
      retrievePerson: stripeMethod76({
        method: "GET",
        fullPath: "/v1/accounts/{account}/persons/{person}"
      }),
      updateCapability: stripeMethod76({
        method: "POST",
        fullPath: "/v1/accounts/{account}/capabilities/{capability}"
      }),
      updateExternalAccount: stripeMethod76({
        method: "POST",
        fullPath: "/v1/accounts/{account}/external_accounts/{id}"
      }),
      updatePerson: stripeMethod76({
        method: "POST",
        fullPath: "/v1/accounts/{account}/persons/{person}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/AccountLinks.js
var stripeMethod77, AccountLinks;
var init_AccountLinks = __esm({
  "../node_modules/stripe/esm/resources/AccountLinks.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod77 = StripeResource.method;
    AccountLinks = StripeResource.extend({
      create: stripeMethod77({ method: "POST", fullPath: "/v1/account_links" })
    });
  }
});

// ../node_modules/stripe/esm/resources/AccountSessions.js
var stripeMethod78, AccountSessions;
var init_AccountSessions = __esm({
  "../node_modules/stripe/esm/resources/AccountSessions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod78 = StripeResource.method;
    AccountSessions = StripeResource.extend({
      create: stripeMethod78({ method: "POST", fullPath: "/v1/account_sessions" })
    });
  }
});

// ../node_modules/stripe/esm/resources/ApplePayDomains.js
var stripeMethod79, ApplePayDomains;
var init_ApplePayDomains = __esm({
  "../node_modules/stripe/esm/resources/ApplePayDomains.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod79 = StripeResource.method;
    ApplePayDomains = StripeResource.extend({
      create: stripeMethod79({ method: "POST", fullPath: "/v1/apple_pay/domains" }),
      retrieve: stripeMethod79({
        method: "GET",
        fullPath: "/v1/apple_pay/domains/{domain}"
      }),
      list: stripeMethod79({
        method: "GET",
        fullPath: "/v1/apple_pay/domains",
        methodType: "list"
      }),
      del: stripeMethod79({
        method: "DELETE",
        fullPath: "/v1/apple_pay/domains/{domain}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/ApplicationFees.js
var stripeMethod80, ApplicationFees;
var init_ApplicationFees = __esm({
  "../node_modules/stripe/esm/resources/ApplicationFees.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod80 = StripeResource.method;
    ApplicationFees = StripeResource.extend({
      retrieve: stripeMethod80({
        method: "GET",
        fullPath: "/v1/application_fees/{id}"
      }),
      list: stripeMethod80({
        method: "GET",
        fullPath: "/v1/application_fees",
        methodType: "list"
      }),
      createRefund: stripeMethod80({
        method: "POST",
        fullPath: "/v1/application_fees/{id}/refunds"
      }),
      listRefunds: stripeMethod80({
        method: "GET",
        fullPath: "/v1/application_fees/{id}/refunds",
        methodType: "list"
      }),
      retrieveRefund: stripeMethod80({
        method: "GET",
        fullPath: "/v1/application_fees/{fee}/refunds/{id}"
      }),
      updateRefund: stripeMethod80({
        method: "POST",
        fullPath: "/v1/application_fees/{fee}/refunds/{id}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Balance.js
var stripeMethod81, Balance;
var init_Balance = __esm({
  "../node_modules/stripe/esm/resources/Balance.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod81 = StripeResource.method;
    Balance = StripeResource.extend({
      retrieve: stripeMethod81({ method: "GET", fullPath: "/v1/balance" })
    });
  }
});

// ../node_modules/stripe/esm/resources/BalanceTransactions.js
var stripeMethod82, BalanceTransactions;
var init_BalanceTransactions = __esm({
  "../node_modules/stripe/esm/resources/BalanceTransactions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod82 = StripeResource.method;
    BalanceTransactions = StripeResource.extend({
      retrieve: stripeMethod82({
        method: "GET",
        fullPath: "/v1/balance_transactions/{id}"
      }),
      list: stripeMethod82({
        method: "GET",
        fullPath: "/v1/balance_transactions",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Charges.js
var stripeMethod83, Charges;
var init_Charges = __esm({
  "../node_modules/stripe/esm/resources/Charges.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod83 = StripeResource.method;
    Charges = StripeResource.extend({
      create: stripeMethod83({ method: "POST", fullPath: "/v1/charges" }),
      retrieve: stripeMethod83({ method: "GET", fullPath: "/v1/charges/{charge}" }),
      update: stripeMethod83({ method: "POST", fullPath: "/v1/charges/{charge}" }),
      list: stripeMethod83({
        method: "GET",
        fullPath: "/v1/charges",
        methodType: "list"
      }),
      capture: stripeMethod83({
        method: "POST",
        fullPath: "/v1/charges/{charge}/capture"
      }),
      search: stripeMethod83({
        method: "GET",
        fullPath: "/v1/charges/search",
        methodType: "search"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/ConfirmationTokens.js
var stripeMethod84, ConfirmationTokens2;
var init_ConfirmationTokens2 = __esm({
  "../node_modules/stripe/esm/resources/ConfirmationTokens.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod84 = StripeResource.method;
    ConfirmationTokens2 = StripeResource.extend({
      retrieve: stripeMethod84({
        method: "GET",
        fullPath: "/v1/confirmation_tokens/{confirmation_token}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/CountrySpecs.js
var stripeMethod85, CountrySpecs;
var init_CountrySpecs = __esm({
  "../node_modules/stripe/esm/resources/CountrySpecs.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod85 = StripeResource.method;
    CountrySpecs = StripeResource.extend({
      retrieve: stripeMethod85({
        method: "GET",
        fullPath: "/v1/country_specs/{country}"
      }),
      list: stripeMethod85({
        method: "GET",
        fullPath: "/v1/country_specs",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Coupons.js
var stripeMethod86, Coupons;
var init_Coupons = __esm({
  "../node_modules/stripe/esm/resources/Coupons.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod86 = StripeResource.method;
    Coupons = StripeResource.extend({
      create: stripeMethod86({ method: "POST", fullPath: "/v1/coupons" }),
      retrieve: stripeMethod86({ method: "GET", fullPath: "/v1/coupons/{coupon}" }),
      update: stripeMethod86({ method: "POST", fullPath: "/v1/coupons/{coupon}" }),
      list: stripeMethod86({
        method: "GET",
        fullPath: "/v1/coupons",
        methodType: "list"
      }),
      del: stripeMethod86({ method: "DELETE", fullPath: "/v1/coupons/{coupon}" })
    });
  }
});

// ../node_modules/stripe/esm/resources/CreditNotes.js
var stripeMethod87, CreditNotes;
var init_CreditNotes = __esm({
  "../node_modules/stripe/esm/resources/CreditNotes.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod87 = StripeResource.method;
    CreditNotes = StripeResource.extend({
      create: stripeMethod87({ method: "POST", fullPath: "/v1/credit_notes" }),
      retrieve: stripeMethod87({ method: "GET", fullPath: "/v1/credit_notes/{id}" }),
      update: stripeMethod87({ method: "POST", fullPath: "/v1/credit_notes/{id}" }),
      list: stripeMethod87({
        method: "GET",
        fullPath: "/v1/credit_notes",
        methodType: "list"
      }),
      listLineItems: stripeMethod87({
        method: "GET",
        fullPath: "/v1/credit_notes/{credit_note}/lines",
        methodType: "list"
      }),
      listPreviewLineItems: stripeMethod87({
        method: "GET",
        fullPath: "/v1/credit_notes/preview/lines",
        methodType: "list"
      }),
      preview: stripeMethod87({ method: "GET", fullPath: "/v1/credit_notes/preview" }),
      voidCreditNote: stripeMethod87({
        method: "POST",
        fullPath: "/v1/credit_notes/{id}/void"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/CustomerSessions.js
var stripeMethod88, CustomerSessions;
var init_CustomerSessions = __esm({
  "../node_modules/stripe/esm/resources/CustomerSessions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod88 = StripeResource.method;
    CustomerSessions = StripeResource.extend({
      create: stripeMethod88({ method: "POST", fullPath: "/v1/customer_sessions" })
    });
  }
});

// ../node_modules/stripe/esm/resources/Customers.js
var stripeMethod89, Customers2;
var init_Customers2 = __esm({
  "../node_modules/stripe/esm/resources/Customers.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod89 = StripeResource.method;
    Customers2 = StripeResource.extend({
      create: stripeMethod89({ method: "POST", fullPath: "/v1/customers" }),
      retrieve: stripeMethod89({ method: "GET", fullPath: "/v1/customers/{customer}" }),
      update: stripeMethod89({ method: "POST", fullPath: "/v1/customers/{customer}" }),
      list: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers",
        methodType: "list"
      }),
      del: stripeMethod89({ method: "DELETE", fullPath: "/v1/customers/{customer}" }),
      createBalanceTransaction: stripeMethod89({
        method: "POST",
        fullPath: "/v1/customers/{customer}/balance_transactions"
      }),
      createFundingInstructions: stripeMethod89({
        method: "POST",
        fullPath: "/v1/customers/{customer}/funding_instructions"
      }),
      createSource: stripeMethod89({
        method: "POST",
        fullPath: "/v1/customers/{customer}/sources"
      }),
      createTaxId: stripeMethod89({
        method: "POST",
        fullPath: "/v1/customers/{customer}/tax_ids"
      }),
      deleteDiscount: stripeMethod89({
        method: "DELETE",
        fullPath: "/v1/customers/{customer}/discount"
      }),
      deleteSource: stripeMethod89({
        method: "DELETE",
        fullPath: "/v1/customers/{customer}/sources/{id}"
      }),
      deleteTaxId: stripeMethod89({
        method: "DELETE",
        fullPath: "/v1/customers/{customer}/tax_ids/{id}"
      }),
      listBalanceTransactions: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers/{customer}/balance_transactions",
        methodType: "list"
      }),
      listCashBalanceTransactions: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers/{customer}/cash_balance_transactions",
        methodType: "list"
      }),
      listPaymentMethods: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers/{customer}/payment_methods",
        methodType: "list"
      }),
      listSources: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers/{customer}/sources",
        methodType: "list"
      }),
      listTaxIds: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers/{customer}/tax_ids",
        methodType: "list"
      }),
      retrieveBalanceTransaction: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers/{customer}/balance_transactions/{transaction}"
      }),
      retrieveCashBalance: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers/{customer}/cash_balance"
      }),
      retrieveCashBalanceTransaction: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers/{customer}/cash_balance_transactions/{transaction}"
      }),
      retrievePaymentMethod: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers/{customer}/payment_methods/{payment_method}"
      }),
      retrieveSource: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers/{customer}/sources/{id}"
      }),
      retrieveTaxId: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers/{customer}/tax_ids/{id}"
      }),
      search: stripeMethod89({
        method: "GET",
        fullPath: "/v1/customers/search",
        methodType: "search"
      }),
      updateBalanceTransaction: stripeMethod89({
        method: "POST",
        fullPath: "/v1/customers/{customer}/balance_transactions/{transaction}"
      }),
      updateCashBalance: stripeMethod89({
        method: "POST",
        fullPath: "/v1/customers/{customer}/cash_balance"
      }),
      updateSource: stripeMethod89({
        method: "POST",
        fullPath: "/v1/customers/{customer}/sources/{id}"
      }),
      verifySource: stripeMethod89({
        method: "POST",
        fullPath: "/v1/customers/{customer}/sources/{id}/verify"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Disputes.js
var stripeMethod90, Disputes2;
var init_Disputes2 = __esm({
  "../node_modules/stripe/esm/resources/Disputes.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod90 = StripeResource.method;
    Disputes2 = StripeResource.extend({
      retrieve: stripeMethod90({ method: "GET", fullPath: "/v1/disputes/{dispute}" }),
      update: stripeMethod90({ method: "POST", fullPath: "/v1/disputes/{dispute}" }),
      list: stripeMethod90({
        method: "GET",
        fullPath: "/v1/disputes",
        methodType: "list"
      }),
      close: stripeMethod90({
        method: "POST",
        fullPath: "/v1/disputes/{dispute}/close"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/EphemeralKeys.js
var stripeMethod91, EphemeralKeys;
var init_EphemeralKeys = __esm({
  "../node_modules/stripe/esm/resources/EphemeralKeys.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod91 = StripeResource.method;
    EphemeralKeys = StripeResource.extend({
      create: stripeMethod91({
        method: "POST",
        fullPath: "/v1/ephemeral_keys",
        validator: /* @__PURE__ */ __name((data, options) => {
          if (!options.headers || !options.headers["Stripe-Version"]) {
            throw new Error("Passing apiVersion in a separate options hash is required to create an ephemeral key. See https://stripe.com/docs/api/versioning?lang=node");
          }
        }, "validator")
      }),
      del: stripeMethod91({ method: "DELETE", fullPath: "/v1/ephemeral_keys/{key}" })
    });
  }
});

// ../node_modules/stripe/esm/resources/Events.js
var stripeMethod92, Events2;
var init_Events2 = __esm({
  "../node_modules/stripe/esm/resources/Events.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod92 = StripeResource.method;
    Events2 = StripeResource.extend({
      retrieve: stripeMethod92({ method: "GET", fullPath: "/v1/events/{id}" }),
      list: stripeMethod92({
        method: "GET",
        fullPath: "/v1/events",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/ExchangeRates.js
var stripeMethod93, ExchangeRates;
var init_ExchangeRates = __esm({
  "../node_modules/stripe/esm/resources/ExchangeRates.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod93 = StripeResource.method;
    ExchangeRates = StripeResource.extend({
      retrieve: stripeMethod93({
        method: "GET",
        fullPath: "/v1/exchange_rates/{rate_id}"
      }),
      list: stripeMethod93({
        method: "GET",
        fullPath: "/v1/exchange_rates",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/FileLinks.js
var stripeMethod94, FileLinks;
var init_FileLinks = __esm({
  "../node_modules/stripe/esm/resources/FileLinks.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod94 = StripeResource.method;
    FileLinks = StripeResource.extend({
      create: stripeMethod94({ method: "POST", fullPath: "/v1/file_links" }),
      retrieve: stripeMethod94({ method: "GET", fullPath: "/v1/file_links/{link}" }),
      update: stripeMethod94({ method: "POST", fullPath: "/v1/file_links/{link}" }),
      list: stripeMethod94({
        method: "GET",
        fullPath: "/v1/file_links",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/multipart.js
function multipartRequestDataProcessor(method, data, headers, callback) {
  data = data || {};
  if (method !== "POST") {
    return callback(null, queryStringifyRequestData(data));
  }
  this._stripe._platformFunctions.tryBufferData(data).then((bufferedData) => {
    const buffer = multipartDataGenerator(method, bufferedData, headers);
    return callback(null, buffer);
  }).catch((err) => callback(err, null));
}
var multipartDataGenerator;
var init_multipart = __esm({
  "../node_modules/stripe/esm/multipart.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_utils3();
    multipartDataGenerator = /* @__PURE__ */ __name((method, data, headers) => {
      const segno = (Math.round(Math.random() * 1e16) + Math.round(Math.random() * 1e16)).toString();
      headers["Content-Type"] = `multipart/form-data; boundary=${segno}`;
      const textEncoder = new TextEncoder();
      let buffer = new Uint8Array(0);
      const endBuffer = textEncoder.encode("\r\n");
      function push(l) {
        const prevBuffer = buffer;
        const newBuffer = l instanceof Uint8Array ? l : new Uint8Array(textEncoder.encode(l));
        buffer = new Uint8Array(prevBuffer.length + newBuffer.length + 2);
        buffer.set(prevBuffer);
        buffer.set(newBuffer, prevBuffer.length);
        buffer.set(endBuffer, buffer.length - 2);
      }
      __name(push, "push");
      function q(s) {
        return `"${s.replace(/"|"/g, "%22").replace(/\r\n|\r|\n/g, " ")}"`;
      }
      __name(q, "q");
      const flattenedData = flattenAndStringify(data);
      for (const k in flattenedData) {
        if (!Object.prototype.hasOwnProperty.call(flattenedData, k)) {
          continue;
        }
        const v = flattenedData[k];
        push(`--${segno}`);
        if (Object.prototype.hasOwnProperty.call(v, "data")) {
          const typedEntry = v;
          push(`Content-Disposition: form-data; name=${q(k)}; filename=${q(typedEntry.name || "blob")}`);
          push(`Content-Type: ${typedEntry.type || "application/octet-stream"}`);
          push("");
          push(typedEntry.data);
        } else {
          push(`Content-Disposition: form-data; name=${q(k)}`);
          push("");
          push(v);
        }
      }
      push(`--${segno}--`);
      return buffer;
    }, "multipartDataGenerator");
    __name(multipartRequestDataProcessor, "multipartRequestDataProcessor");
  }
});

// ../node_modules/stripe/esm/resources/Files.js
var stripeMethod95, Files;
var init_Files = __esm({
  "../node_modules/stripe/esm/resources/Files.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_multipart();
    init_StripeResource();
    stripeMethod95 = StripeResource.method;
    Files = StripeResource.extend({
      create: stripeMethod95({
        method: "POST",
        fullPath: "/v1/files",
        headers: {
          "Content-Type": "multipart/form-data"
        },
        host: "files.stripe.com"
      }),
      retrieve: stripeMethod95({ method: "GET", fullPath: "/v1/files/{file}" }),
      list: stripeMethod95({
        method: "GET",
        fullPath: "/v1/files",
        methodType: "list"
      }),
      requestDataProcessor: multipartRequestDataProcessor
    });
  }
});

// ../node_modules/stripe/esm/resources/InvoiceItems.js
var stripeMethod96, InvoiceItems;
var init_InvoiceItems = __esm({
  "../node_modules/stripe/esm/resources/InvoiceItems.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod96 = StripeResource.method;
    InvoiceItems = StripeResource.extend({
      create: stripeMethod96({ method: "POST", fullPath: "/v1/invoiceitems" }),
      retrieve: stripeMethod96({
        method: "GET",
        fullPath: "/v1/invoiceitems/{invoiceitem}"
      }),
      update: stripeMethod96({
        method: "POST",
        fullPath: "/v1/invoiceitems/{invoiceitem}"
      }),
      list: stripeMethod96({
        method: "GET",
        fullPath: "/v1/invoiceitems",
        methodType: "list"
      }),
      del: stripeMethod96({
        method: "DELETE",
        fullPath: "/v1/invoiceitems/{invoiceitem}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/InvoicePayments.js
var stripeMethod97, InvoicePayments;
var init_InvoicePayments = __esm({
  "../node_modules/stripe/esm/resources/InvoicePayments.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod97 = StripeResource.method;
    InvoicePayments = StripeResource.extend({
      retrieve: stripeMethod97({
        method: "GET",
        fullPath: "/v1/invoice_payments/{invoice_payment}"
      }),
      list: stripeMethod97({
        method: "GET",
        fullPath: "/v1/invoice_payments",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/InvoiceRenderingTemplates.js
var stripeMethod98, InvoiceRenderingTemplates;
var init_InvoiceRenderingTemplates = __esm({
  "../node_modules/stripe/esm/resources/InvoiceRenderingTemplates.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod98 = StripeResource.method;
    InvoiceRenderingTemplates = StripeResource.extend({
      retrieve: stripeMethod98({
        method: "GET",
        fullPath: "/v1/invoice_rendering_templates/{template}"
      }),
      list: stripeMethod98({
        method: "GET",
        fullPath: "/v1/invoice_rendering_templates",
        methodType: "list"
      }),
      archive: stripeMethod98({
        method: "POST",
        fullPath: "/v1/invoice_rendering_templates/{template}/archive"
      }),
      unarchive: stripeMethod98({
        method: "POST",
        fullPath: "/v1/invoice_rendering_templates/{template}/unarchive"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Invoices.js
var stripeMethod99, Invoices;
var init_Invoices = __esm({
  "../node_modules/stripe/esm/resources/Invoices.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod99 = StripeResource.method;
    Invoices = StripeResource.extend({
      create: stripeMethod99({ method: "POST", fullPath: "/v1/invoices" }),
      retrieve: stripeMethod99({ method: "GET", fullPath: "/v1/invoices/{invoice}" }),
      update: stripeMethod99({ method: "POST", fullPath: "/v1/invoices/{invoice}" }),
      list: stripeMethod99({
        method: "GET",
        fullPath: "/v1/invoices",
        methodType: "list"
      }),
      del: stripeMethod99({ method: "DELETE", fullPath: "/v1/invoices/{invoice}" }),
      addLines: stripeMethod99({
        method: "POST",
        fullPath: "/v1/invoices/{invoice}/add_lines"
      }),
      attachPayment: stripeMethod99({
        method: "POST",
        fullPath: "/v1/invoices/{invoice}/attach_payment"
      }),
      createPreview: stripeMethod99({
        method: "POST",
        fullPath: "/v1/invoices/create_preview"
      }),
      finalizeInvoice: stripeMethod99({
        method: "POST",
        fullPath: "/v1/invoices/{invoice}/finalize"
      }),
      listLineItems: stripeMethod99({
        method: "GET",
        fullPath: "/v1/invoices/{invoice}/lines",
        methodType: "list"
      }),
      markUncollectible: stripeMethod99({
        method: "POST",
        fullPath: "/v1/invoices/{invoice}/mark_uncollectible"
      }),
      pay: stripeMethod99({ method: "POST", fullPath: "/v1/invoices/{invoice}/pay" }),
      removeLines: stripeMethod99({
        method: "POST",
        fullPath: "/v1/invoices/{invoice}/remove_lines"
      }),
      search: stripeMethod99({
        method: "GET",
        fullPath: "/v1/invoices/search",
        methodType: "search"
      }),
      sendInvoice: stripeMethod99({
        method: "POST",
        fullPath: "/v1/invoices/{invoice}/send"
      }),
      updateLines: stripeMethod99({
        method: "POST",
        fullPath: "/v1/invoices/{invoice}/update_lines"
      }),
      updateLineItem: stripeMethod99({
        method: "POST",
        fullPath: "/v1/invoices/{invoice}/lines/{line_item_id}"
      }),
      voidInvoice: stripeMethod99({
        method: "POST",
        fullPath: "/v1/invoices/{invoice}/void"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Mandates.js
var stripeMethod100, Mandates;
var init_Mandates = __esm({
  "../node_modules/stripe/esm/resources/Mandates.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod100 = StripeResource.method;
    Mandates = StripeResource.extend({
      retrieve: stripeMethod100({ method: "GET", fullPath: "/v1/mandates/{mandate}" })
    });
  }
});

// ../node_modules/stripe/esm/resources/OAuth.js
var stripeMethod101, oAuthHost, OAuth;
var init_OAuth = __esm({
  "../node_modules/stripe/esm/resources/OAuth.js"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    init_utils3();
    stripeMethod101 = StripeResource.method;
    oAuthHost = "connect.stripe.com";
    OAuth = StripeResource.extend({
      basePath: "/",
      authorizeUrl(params, options) {
        params = params || {};
        options = options || {};
        let path = "oauth/authorize";
        if (options.express) {
          path = `express/${path}`;
        }
        if (!params.response_type) {
          params.response_type = "code";
        }
        if (!params.client_id) {
          params.client_id = this._stripe.getClientId();
        }
        if (!params.scope) {
          params.scope = "read_write";
        }
        return `https://${oAuthHost}/${path}?${queryStringifyRequestData(params)}`;
      },
      token: stripeMethod101({
        method: "POST",
        path: "oauth/token",
        host: oAuthHost
      }),
      deauthorize(spec, ...args) {
        if (!spec.client_id) {
          spec.client_id = this._stripe.getClientId();
        }
        return stripeMethod101({
          method: "POST",
          path: "oauth/deauthorize",
          host: oAuthHost
        }).apply(this, [spec, ...args]);
      }
    });
  }
});

// ../node_modules/stripe/esm/resources/PaymentIntents.js
var stripeMethod102, PaymentIntents;
var init_PaymentIntents = __esm({
  "../node_modules/stripe/esm/resources/PaymentIntents.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod102 = StripeResource.method;
    PaymentIntents = StripeResource.extend({
      create: stripeMethod102({ method: "POST", fullPath: "/v1/payment_intents" }),
      retrieve: stripeMethod102({
        method: "GET",
        fullPath: "/v1/payment_intents/{intent}"
      }),
      update: stripeMethod102({
        method: "POST",
        fullPath: "/v1/payment_intents/{intent}"
      }),
      list: stripeMethod102({
        method: "GET",
        fullPath: "/v1/payment_intents",
        methodType: "list"
      }),
      applyCustomerBalance: stripeMethod102({
        method: "POST",
        fullPath: "/v1/payment_intents/{intent}/apply_customer_balance"
      }),
      cancel: stripeMethod102({
        method: "POST",
        fullPath: "/v1/payment_intents/{intent}/cancel"
      }),
      capture: stripeMethod102({
        method: "POST",
        fullPath: "/v1/payment_intents/{intent}/capture"
      }),
      confirm: stripeMethod102({
        method: "POST",
        fullPath: "/v1/payment_intents/{intent}/confirm"
      }),
      incrementAuthorization: stripeMethod102({
        method: "POST",
        fullPath: "/v1/payment_intents/{intent}/increment_authorization"
      }),
      search: stripeMethod102({
        method: "GET",
        fullPath: "/v1/payment_intents/search",
        methodType: "search"
      }),
      verifyMicrodeposits: stripeMethod102({
        method: "POST",
        fullPath: "/v1/payment_intents/{intent}/verify_microdeposits"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/PaymentLinks.js
var stripeMethod103, PaymentLinks;
var init_PaymentLinks = __esm({
  "../node_modules/stripe/esm/resources/PaymentLinks.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod103 = StripeResource.method;
    PaymentLinks = StripeResource.extend({
      create: stripeMethod103({ method: "POST", fullPath: "/v1/payment_links" }),
      retrieve: stripeMethod103({
        method: "GET",
        fullPath: "/v1/payment_links/{payment_link}"
      }),
      update: stripeMethod103({
        method: "POST",
        fullPath: "/v1/payment_links/{payment_link}"
      }),
      list: stripeMethod103({
        method: "GET",
        fullPath: "/v1/payment_links",
        methodType: "list"
      }),
      listLineItems: stripeMethod103({
        method: "GET",
        fullPath: "/v1/payment_links/{payment_link}/line_items",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/PaymentMethodConfigurations.js
var stripeMethod104, PaymentMethodConfigurations;
var init_PaymentMethodConfigurations = __esm({
  "../node_modules/stripe/esm/resources/PaymentMethodConfigurations.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod104 = StripeResource.method;
    PaymentMethodConfigurations = StripeResource.extend({
      create: stripeMethod104({
        method: "POST",
        fullPath: "/v1/payment_method_configurations"
      }),
      retrieve: stripeMethod104({
        method: "GET",
        fullPath: "/v1/payment_method_configurations/{configuration}"
      }),
      update: stripeMethod104({
        method: "POST",
        fullPath: "/v1/payment_method_configurations/{configuration}"
      }),
      list: stripeMethod104({
        method: "GET",
        fullPath: "/v1/payment_method_configurations",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/PaymentMethodDomains.js
var stripeMethod105, PaymentMethodDomains;
var init_PaymentMethodDomains = __esm({
  "../node_modules/stripe/esm/resources/PaymentMethodDomains.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod105 = StripeResource.method;
    PaymentMethodDomains = StripeResource.extend({
      create: stripeMethod105({
        method: "POST",
        fullPath: "/v1/payment_method_domains"
      }),
      retrieve: stripeMethod105({
        method: "GET",
        fullPath: "/v1/payment_method_domains/{payment_method_domain}"
      }),
      update: stripeMethod105({
        method: "POST",
        fullPath: "/v1/payment_method_domains/{payment_method_domain}"
      }),
      list: stripeMethod105({
        method: "GET",
        fullPath: "/v1/payment_method_domains",
        methodType: "list"
      }),
      validate: stripeMethod105({
        method: "POST",
        fullPath: "/v1/payment_method_domains/{payment_method_domain}/validate"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/PaymentMethods.js
var stripeMethod106, PaymentMethods;
var init_PaymentMethods = __esm({
  "../node_modules/stripe/esm/resources/PaymentMethods.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod106 = StripeResource.method;
    PaymentMethods = StripeResource.extend({
      create: stripeMethod106({ method: "POST", fullPath: "/v1/payment_methods" }),
      retrieve: stripeMethod106({
        method: "GET",
        fullPath: "/v1/payment_methods/{payment_method}"
      }),
      update: stripeMethod106({
        method: "POST",
        fullPath: "/v1/payment_methods/{payment_method}"
      }),
      list: stripeMethod106({
        method: "GET",
        fullPath: "/v1/payment_methods",
        methodType: "list"
      }),
      attach: stripeMethod106({
        method: "POST",
        fullPath: "/v1/payment_methods/{payment_method}/attach"
      }),
      detach: stripeMethod106({
        method: "POST",
        fullPath: "/v1/payment_methods/{payment_method}/detach"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Payouts.js
var stripeMethod107, Payouts;
var init_Payouts = __esm({
  "../node_modules/stripe/esm/resources/Payouts.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod107 = StripeResource.method;
    Payouts = StripeResource.extend({
      create: stripeMethod107({ method: "POST", fullPath: "/v1/payouts" }),
      retrieve: stripeMethod107({ method: "GET", fullPath: "/v1/payouts/{payout}" }),
      update: stripeMethod107({ method: "POST", fullPath: "/v1/payouts/{payout}" }),
      list: stripeMethod107({
        method: "GET",
        fullPath: "/v1/payouts",
        methodType: "list"
      }),
      cancel: stripeMethod107({
        method: "POST",
        fullPath: "/v1/payouts/{payout}/cancel"
      }),
      reverse: stripeMethod107({
        method: "POST",
        fullPath: "/v1/payouts/{payout}/reverse"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Plans.js
var stripeMethod108, Plans;
var init_Plans = __esm({
  "../node_modules/stripe/esm/resources/Plans.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod108 = StripeResource.method;
    Plans = StripeResource.extend({
      create: stripeMethod108({ method: "POST", fullPath: "/v1/plans" }),
      retrieve: stripeMethod108({ method: "GET", fullPath: "/v1/plans/{plan}" }),
      update: stripeMethod108({ method: "POST", fullPath: "/v1/plans/{plan}" }),
      list: stripeMethod108({
        method: "GET",
        fullPath: "/v1/plans",
        methodType: "list"
      }),
      del: stripeMethod108({ method: "DELETE", fullPath: "/v1/plans/{plan}" })
    });
  }
});

// ../node_modules/stripe/esm/resources/Prices.js
var stripeMethod109, Prices;
var init_Prices = __esm({
  "../node_modules/stripe/esm/resources/Prices.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod109 = StripeResource.method;
    Prices = StripeResource.extend({
      create: stripeMethod109({ method: "POST", fullPath: "/v1/prices" }),
      retrieve: stripeMethod109({ method: "GET", fullPath: "/v1/prices/{price}" }),
      update: stripeMethod109({ method: "POST", fullPath: "/v1/prices/{price}" }),
      list: stripeMethod109({
        method: "GET",
        fullPath: "/v1/prices",
        methodType: "list"
      }),
      search: stripeMethod109({
        method: "GET",
        fullPath: "/v1/prices/search",
        methodType: "search"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Products.js
var stripeMethod110, Products2;
var init_Products2 = __esm({
  "../node_modules/stripe/esm/resources/Products.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod110 = StripeResource.method;
    Products2 = StripeResource.extend({
      create: stripeMethod110({ method: "POST", fullPath: "/v1/products" }),
      retrieve: stripeMethod110({ method: "GET", fullPath: "/v1/products/{id}" }),
      update: stripeMethod110({ method: "POST", fullPath: "/v1/products/{id}" }),
      list: stripeMethod110({
        method: "GET",
        fullPath: "/v1/products",
        methodType: "list"
      }),
      del: stripeMethod110({ method: "DELETE", fullPath: "/v1/products/{id}" }),
      createFeature: stripeMethod110({
        method: "POST",
        fullPath: "/v1/products/{product}/features"
      }),
      deleteFeature: stripeMethod110({
        method: "DELETE",
        fullPath: "/v1/products/{product}/features/{id}"
      }),
      listFeatures: stripeMethod110({
        method: "GET",
        fullPath: "/v1/products/{product}/features",
        methodType: "list"
      }),
      retrieveFeature: stripeMethod110({
        method: "GET",
        fullPath: "/v1/products/{product}/features/{id}"
      }),
      search: stripeMethod110({
        method: "GET",
        fullPath: "/v1/products/search",
        methodType: "search"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/PromotionCodes.js
var stripeMethod111, PromotionCodes;
var init_PromotionCodes = __esm({
  "../node_modules/stripe/esm/resources/PromotionCodes.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod111 = StripeResource.method;
    PromotionCodes = StripeResource.extend({
      create: stripeMethod111({ method: "POST", fullPath: "/v1/promotion_codes" }),
      retrieve: stripeMethod111({
        method: "GET",
        fullPath: "/v1/promotion_codes/{promotion_code}"
      }),
      update: stripeMethod111({
        method: "POST",
        fullPath: "/v1/promotion_codes/{promotion_code}"
      }),
      list: stripeMethod111({
        method: "GET",
        fullPath: "/v1/promotion_codes",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Quotes.js
var stripeMethod112, Quotes;
var init_Quotes = __esm({
  "../node_modules/stripe/esm/resources/Quotes.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod112 = StripeResource.method;
    Quotes = StripeResource.extend({
      create: stripeMethod112({ method: "POST", fullPath: "/v1/quotes" }),
      retrieve: stripeMethod112({ method: "GET", fullPath: "/v1/quotes/{quote}" }),
      update: stripeMethod112({ method: "POST", fullPath: "/v1/quotes/{quote}" }),
      list: stripeMethod112({
        method: "GET",
        fullPath: "/v1/quotes",
        methodType: "list"
      }),
      accept: stripeMethod112({ method: "POST", fullPath: "/v1/quotes/{quote}/accept" }),
      cancel: stripeMethod112({ method: "POST", fullPath: "/v1/quotes/{quote}/cancel" }),
      finalizeQuote: stripeMethod112({
        method: "POST",
        fullPath: "/v1/quotes/{quote}/finalize"
      }),
      listComputedUpfrontLineItems: stripeMethod112({
        method: "GET",
        fullPath: "/v1/quotes/{quote}/computed_upfront_line_items",
        methodType: "list"
      }),
      listLineItems: stripeMethod112({
        method: "GET",
        fullPath: "/v1/quotes/{quote}/line_items",
        methodType: "list"
      }),
      pdf: stripeMethod112({
        method: "GET",
        fullPath: "/v1/quotes/{quote}/pdf",
        host: "files.stripe.com",
        streaming: true
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Refunds.js
var stripeMethod113, Refunds2;
var init_Refunds2 = __esm({
  "../node_modules/stripe/esm/resources/Refunds.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod113 = StripeResource.method;
    Refunds2 = StripeResource.extend({
      create: stripeMethod113({ method: "POST", fullPath: "/v1/refunds" }),
      retrieve: stripeMethod113({ method: "GET", fullPath: "/v1/refunds/{refund}" }),
      update: stripeMethod113({ method: "POST", fullPath: "/v1/refunds/{refund}" }),
      list: stripeMethod113({
        method: "GET",
        fullPath: "/v1/refunds",
        methodType: "list"
      }),
      cancel: stripeMethod113({
        method: "POST",
        fullPath: "/v1/refunds/{refund}/cancel"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Reviews.js
var stripeMethod114, Reviews;
var init_Reviews = __esm({
  "../node_modules/stripe/esm/resources/Reviews.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod114 = StripeResource.method;
    Reviews = StripeResource.extend({
      retrieve: stripeMethod114({ method: "GET", fullPath: "/v1/reviews/{review}" }),
      list: stripeMethod114({
        method: "GET",
        fullPath: "/v1/reviews",
        methodType: "list"
      }),
      approve: stripeMethod114({
        method: "POST",
        fullPath: "/v1/reviews/{review}/approve"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/SetupAttempts.js
var stripeMethod115, SetupAttempts;
var init_SetupAttempts = __esm({
  "../node_modules/stripe/esm/resources/SetupAttempts.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod115 = StripeResource.method;
    SetupAttempts = StripeResource.extend({
      list: stripeMethod115({
        method: "GET",
        fullPath: "/v1/setup_attempts",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/SetupIntents.js
var stripeMethod116, SetupIntents;
var init_SetupIntents = __esm({
  "../node_modules/stripe/esm/resources/SetupIntents.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod116 = StripeResource.method;
    SetupIntents = StripeResource.extend({
      create: stripeMethod116({ method: "POST", fullPath: "/v1/setup_intents" }),
      retrieve: stripeMethod116({
        method: "GET",
        fullPath: "/v1/setup_intents/{intent}"
      }),
      update: stripeMethod116({
        method: "POST",
        fullPath: "/v1/setup_intents/{intent}"
      }),
      list: stripeMethod116({
        method: "GET",
        fullPath: "/v1/setup_intents",
        methodType: "list"
      }),
      cancel: stripeMethod116({
        method: "POST",
        fullPath: "/v1/setup_intents/{intent}/cancel"
      }),
      confirm: stripeMethod116({
        method: "POST",
        fullPath: "/v1/setup_intents/{intent}/confirm"
      }),
      verifyMicrodeposits: stripeMethod116({
        method: "POST",
        fullPath: "/v1/setup_intents/{intent}/verify_microdeposits"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/ShippingRates.js
var stripeMethod117, ShippingRates;
var init_ShippingRates = __esm({
  "../node_modules/stripe/esm/resources/ShippingRates.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod117 = StripeResource.method;
    ShippingRates = StripeResource.extend({
      create: stripeMethod117({ method: "POST", fullPath: "/v1/shipping_rates" }),
      retrieve: stripeMethod117({
        method: "GET",
        fullPath: "/v1/shipping_rates/{shipping_rate_token}"
      }),
      update: stripeMethod117({
        method: "POST",
        fullPath: "/v1/shipping_rates/{shipping_rate_token}"
      }),
      list: stripeMethod117({
        method: "GET",
        fullPath: "/v1/shipping_rates",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Sources.js
var stripeMethod118, Sources;
var init_Sources = __esm({
  "../node_modules/stripe/esm/resources/Sources.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod118 = StripeResource.method;
    Sources = StripeResource.extend({
      create: stripeMethod118({ method: "POST", fullPath: "/v1/sources" }),
      retrieve: stripeMethod118({ method: "GET", fullPath: "/v1/sources/{source}" }),
      update: stripeMethod118({ method: "POST", fullPath: "/v1/sources/{source}" }),
      listSourceTransactions: stripeMethod118({
        method: "GET",
        fullPath: "/v1/sources/{source}/source_transactions",
        methodType: "list"
      }),
      verify: stripeMethod118({
        method: "POST",
        fullPath: "/v1/sources/{source}/verify"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/SubscriptionItems.js
var stripeMethod119, SubscriptionItems;
var init_SubscriptionItems = __esm({
  "../node_modules/stripe/esm/resources/SubscriptionItems.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod119 = StripeResource.method;
    SubscriptionItems = StripeResource.extend({
      create: stripeMethod119({ method: "POST", fullPath: "/v1/subscription_items" }),
      retrieve: stripeMethod119({
        method: "GET",
        fullPath: "/v1/subscription_items/{item}"
      }),
      update: stripeMethod119({
        method: "POST",
        fullPath: "/v1/subscription_items/{item}"
      }),
      list: stripeMethod119({
        method: "GET",
        fullPath: "/v1/subscription_items",
        methodType: "list"
      }),
      del: stripeMethod119({
        method: "DELETE",
        fullPath: "/v1/subscription_items/{item}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/SubscriptionSchedules.js
var stripeMethod120, SubscriptionSchedules;
var init_SubscriptionSchedules = __esm({
  "../node_modules/stripe/esm/resources/SubscriptionSchedules.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod120 = StripeResource.method;
    SubscriptionSchedules = StripeResource.extend({
      create: stripeMethod120({
        method: "POST",
        fullPath: "/v1/subscription_schedules"
      }),
      retrieve: stripeMethod120({
        method: "GET",
        fullPath: "/v1/subscription_schedules/{schedule}"
      }),
      update: stripeMethod120({
        method: "POST",
        fullPath: "/v1/subscription_schedules/{schedule}"
      }),
      list: stripeMethod120({
        method: "GET",
        fullPath: "/v1/subscription_schedules",
        methodType: "list"
      }),
      cancel: stripeMethod120({
        method: "POST",
        fullPath: "/v1/subscription_schedules/{schedule}/cancel"
      }),
      release: stripeMethod120({
        method: "POST",
        fullPath: "/v1/subscription_schedules/{schedule}/release"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Subscriptions.js
var stripeMethod121, Subscriptions;
var init_Subscriptions = __esm({
  "../node_modules/stripe/esm/resources/Subscriptions.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod121 = StripeResource.method;
    Subscriptions = StripeResource.extend({
      create: stripeMethod121({ method: "POST", fullPath: "/v1/subscriptions" }),
      retrieve: stripeMethod121({
        method: "GET",
        fullPath: "/v1/subscriptions/{subscription_exposed_id}"
      }),
      update: stripeMethod121({
        method: "POST",
        fullPath: "/v1/subscriptions/{subscription_exposed_id}"
      }),
      list: stripeMethod121({
        method: "GET",
        fullPath: "/v1/subscriptions",
        methodType: "list"
      }),
      cancel: stripeMethod121({
        method: "DELETE",
        fullPath: "/v1/subscriptions/{subscription_exposed_id}"
      }),
      deleteDiscount: stripeMethod121({
        method: "DELETE",
        fullPath: "/v1/subscriptions/{subscription_exposed_id}/discount"
      }),
      migrate: stripeMethod121({
        method: "POST",
        fullPath: "/v1/subscriptions/{subscription}/migrate"
      }),
      resume: stripeMethod121({
        method: "POST",
        fullPath: "/v1/subscriptions/{subscription}/resume"
      }),
      search: stripeMethod121({
        method: "GET",
        fullPath: "/v1/subscriptions/search",
        methodType: "search"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TaxCodes.js
var stripeMethod122, TaxCodes;
var init_TaxCodes = __esm({
  "../node_modules/stripe/esm/resources/TaxCodes.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod122 = StripeResource.method;
    TaxCodes = StripeResource.extend({
      retrieve: stripeMethod122({ method: "GET", fullPath: "/v1/tax_codes/{id}" }),
      list: stripeMethod122({
        method: "GET",
        fullPath: "/v1/tax_codes",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/TaxIds.js
var stripeMethod123, TaxIds;
var init_TaxIds = __esm({
  "../node_modules/stripe/esm/resources/TaxIds.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod123 = StripeResource.method;
    TaxIds = StripeResource.extend({
      create: stripeMethod123({ method: "POST", fullPath: "/v1/tax_ids" }),
      retrieve: stripeMethod123({ method: "GET", fullPath: "/v1/tax_ids/{id}" }),
      list: stripeMethod123({
        method: "GET",
        fullPath: "/v1/tax_ids",
        methodType: "list"
      }),
      del: stripeMethod123({ method: "DELETE", fullPath: "/v1/tax_ids/{id}" })
    });
  }
});

// ../node_modules/stripe/esm/resources/TaxRates.js
var stripeMethod124, TaxRates;
var init_TaxRates = __esm({
  "../node_modules/stripe/esm/resources/TaxRates.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod124 = StripeResource.method;
    TaxRates = StripeResource.extend({
      create: stripeMethod124({ method: "POST", fullPath: "/v1/tax_rates" }),
      retrieve: stripeMethod124({ method: "GET", fullPath: "/v1/tax_rates/{tax_rate}" }),
      update: stripeMethod124({ method: "POST", fullPath: "/v1/tax_rates/{tax_rate}" }),
      list: stripeMethod124({
        method: "GET",
        fullPath: "/v1/tax_rates",
        methodType: "list"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/Tokens.js
var stripeMethod125, Tokens2;
var init_Tokens2 = __esm({
  "../node_modules/stripe/esm/resources/Tokens.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod125 = StripeResource.method;
    Tokens2 = StripeResource.extend({
      create: stripeMethod125({ method: "POST", fullPath: "/v1/tokens" }),
      retrieve: stripeMethod125({ method: "GET", fullPath: "/v1/tokens/{token}" })
    });
  }
});

// ../node_modules/stripe/esm/resources/Topups.js
var stripeMethod126, Topups;
var init_Topups = __esm({
  "../node_modules/stripe/esm/resources/Topups.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod126 = StripeResource.method;
    Topups = StripeResource.extend({
      create: stripeMethod126({ method: "POST", fullPath: "/v1/topups" }),
      retrieve: stripeMethod126({ method: "GET", fullPath: "/v1/topups/{topup}" }),
      update: stripeMethod126({ method: "POST", fullPath: "/v1/topups/{topup}" }),
      list: stripeMethod126({
        method: "GET",
        fullPath: "/v1/topups",
        methodType: "list"
      }),
      cancel: stripeMethod126({ method: "POST", fullPath: "/v1/topups/{topup}/cancel" })
    });
  }
});

// ../node_modules/stripe/esm/resources/Transfers.js
var stripeMethod127, Transfers;
var init_Transfers = __esm({
  "../node_modules/stripe/esm/resources/Transfers.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod127 = StripeResource.method;
    Transfers = StripeResource.extend({
      create: stripeMethod127({ method: "POST", fullPath: "/v1/transfers" }),
      retrieve: stripeMethod127({ method: "GET", fullPath: "/v1/transfers/{transfer}" }),
      update: stripeMethod127({ method: "POST", fullPath: "/v1/transfers/{transfer}" }),
      list: stripeMethod127({
        method: "GET",
        fullPath: "/v1/transfers",
        methodType: "list"
      }),
      createReversal: stripeMethod127({
        method: "POST",
        fullPath: "/v1/transfers/{id}/reversals"
      }),
      listReversals: stripeMethod127({
        method: "GET",
        fullPath: "/v1/transfers/{id}/reversals",
        methodType: "list"
      }),
      retrieveReversal: stripeMethod127({
        method: "GET",
        fullPath: "/v1/transfers/{transfer}/reversals/{id}"
      }),
      updateReversal: stripeMethod127({
        method: "POST",
        fullPath: "/v1/transfers/{transfer}/reversals/{id}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources/WebhookEndpoints.js
var stripeMethod128, WebhookEndpoints;
var init_WebhookEndpoints = __esm({
  "../node_modules/stripe/esm/resources/WebhookEndpoints.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_StripeResource();
    stripeMethod128 = StripeResource.method;
    WebhookEndpoints = StripeResource.extend({
      create: stripeMethod128({ method: "POST", fullPath: "/v1/webhook_endpoints" }),
      retrieve: stripeMethod128({
        method: "GET",
        fullPath: "/v1/webhook_endpoints/{webhook_endpoint}"
      }),
      update: stripeMethod128({
        method: "POST",
        fullPath: "/v1/webhook_endpoints/{webhook_endpoint}"
      }),
      list: stripeMethod128({
        method: "GET",
        fullPath: "/v1/webhook_endpoints",
        methodType: "list"
      }),
      del: stripeMethod128({
        method: "DELETE",
        fullPath: "/v1/webhook_endpoints/{webhook_endpoint}"
      })
    });
  }
});

// ../node_modules/stripe/esm/resources.js
var resources_exports = {};
__export(resources_exports, {
  Account: () => Accounts2,
  AccountLinks: () => AccountLinks,
  AccountSessions: () => AccountSessions,
  Accounts: () => Accounts2,
  ApplePayDomains: () => ApplePayDomains,
  ApplicationFees: () => ApplicationFees,
  Apps: () => Apps,
  Balance: () => Balance,
  BalanceTransactions: () => BalanceTransactions,
  Billing: () => Billing,
  BillingPortal: () => BillingPortal,
  Charges: () => Charges,
  Checkout: () => Checkout,
  Climate: () => Climate,
  ConfirmationTokens: () => ConfirmationTokens2,
  CountrySpecs: () => CountrySpecs,
  Coupons: () => Coupons,
  CreditNotes: () => CreditNotes,
  CustomerSessions: () => CustomerSessions,
  Customers: () => Customers2,
  Disputes: () => Disputes2,
  Entitlements: () => Entitlements,
  EphemeralKeys: () => EphemeralKeys,
  Events: () => Events2,
  ExchangeRates: () => ExchangeRates,
  FileLinks: () => FileLinks,
  Files: () => Files,
  FinancialConnections: () => FinancialConnections,
  Forwarding: () => Forwarding,
  Identity: () => Identity,
  InvoiceItems: () => InvoiceItems,
  InvoicePayments: () => InvoicePayments,
  InvoiceRenderingTemplates: () => InvoiceRenderingTemplates,
  Invoices: () => Invoices,
  Issuing: () => Issuing,
  Mandates: () => Mandates,
  OAuth: () => OAuth,
  PaymentIntents: () => PaymentIntents,
  PaymentLinks: () => PaymentLinks,
  PaymentMethodConfigurations: () => PaymentMethodConfigurations,
  PaymentMethodDomains: () => PaymentMethodDomains,
  PaymentMethods: () => PaymentMethods,
  Payouts: () => Payouts,
  Plans: () => Plans,
  Prices: () => Prices,
  Products: () => Products2,
  PromotionCodes: () => PromotionCodes,
  Quotes: () => Quotes,
  Radar: () => Radar,
  Refunds: () => Refunds2,
  Reporting: () => Reporting,
  Reviews: () => Reviews,
  SetupAttempts: () => SetupAttempts,
  SetupIntents: () => SetupIntents,
  ShippingRates: () => ShippingRates,
  Sigma: () => Sigma,
  Sources: () => Sources,
  SubscriptionItems: () => SubscriptionItems,
  SubscriptionSchedules: () => SubscriptionSchedules,
  Subscriptions: () => Subscriptions,
  Tax: () => Tax,
  TaxCodes: () => TaxCodes,
  TaxIds: () => TaxIds,
  TaxRates: () => TaxRates,
  Terminal: () => Terminal,
  TestHelpers: () => TestHelpers,
  Tokens: () => Tokens2,
  Topups: () => Topups,
  Transfers: () => Transfers,
  Treasury: () => Treasury,
  V2: () => V2,
  WebhookEndpoints: () => WebhookEndpoints
});
var Apps, Billing, BillingPortal, Checkout, Climate, Entitlements, FinancialConnections, Forwarding, Identity, Issuing, Radar, Reporting, Sigma, Tax, Terminal, TestHelpers, Treasury, V2;
var init_resources = __esm({
  "../node_modules/stripe/esm/resources.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_ResourceNamespace();
    init_Accounts();
    init_ActiveEntitlements();
    init_Alerts();
    init_Authorizations();
    init_Authorizations2();
    init_Calculations();
    init_Cardholders();
    init_Cards();
    init_Cards2();
    init_Configurations();
    init_Configurations2();
    init_ConfirmationTokens();
    init_ConnectionTokens();
    init_CreditBalanceSummary();
    init_CreditBalanceTransactions();
    init_CreditGrants();
    init_CreditReversals();
    init_Customers();
    init_DebitReversals();
    init_Disputes();
    init_EarlyFraudWarnings();
    init_EventDestinations();
    init_Events();
    init_Features();
    init_FinancialAccounts();
    init_InboundTransfers();
    init_InboundTransfers2();
    init_Locations();
    init_MeterEventAdjustments();
    init_MeterEventAdjustments2();
    init_MeterEventSession();
    init_MeterEventStream();
    init_MeterEvents();
    init_MeterEvents2();
    init_Meters();
    init_Orders();
    init_OutboundPayments();
    init_OutboundPayments2();
    init_OutboundTransfers();
    init_OutboundTransfers2();
    init_PersonalizationDesigns();
    init_PersonalizationDesigns2();
    init_PhysicalBundles();
    init_Products();
    init_Readers();
    init_Readers2();
    init_ReceivedCredits();
    init_ReceivedCredits2();
    init_ReceivedDebits();
    init_ReceivedDebits2();
    init_Refunds();
    init_Registrations();
    init_ReportRuns();
    init_ReportTypes();
    init_Requests();
    init_ScheduledQueryRuns();
    init_Secrets();
    init_Sessions();
    init_Sessions2();
    init_Sessions3();
    init_Settings();
    init_Suppliers();
    init_TestClocks();
    init_Tokens();
    init_TransactionEntries();
    init_Transactions();
    init_Transactions2();
    init_Transactions3();
    init_Transactions4();
    init_Transactions5();
    init_ValueListItems();
    init_ValueLists();
    init_VerificationReports();
    init_VerificationSessions();
    init_Accounts2();
    init_AccountLinks();
    init_AccountSessions();
    init_Accounts2();
    init_ApplePayDomains();
    init_ApplicationFees();
    init_Balance();
    init_BalanceTransactions();
    init_Charges();
    init_ConfirmationTokens2();
    init_CountrySpecs();
    init_Coupons();
    init_CreditNotes();
    init_CustomerSessions();
    init_Customers2();
    init_Disputes2();
    init_EphemeralKeys();
    init_Events2();
    init_ExchangeRates();
    init_FileLinks();
    init_Files();
    init_InvoiceItems();
    init_InvoicePayments();
    init_InvoiceRenderingTemplates();
    init_Invoices();
    init_Mandates();
    init_OAuth();
    init_PaymentIntents();
    init_PaymentLinks();
    init_PaymentMethodConfigurations();
    init_PaymentMethodDomains();
    init_PaymentMethods();
    init_Payouts();
    init_Plans();
    init_Prices();
    init_Products2();
    init_PromotionCodes();
    init_Quotes();
    init_Refunds2();
    init_Reviews();
    init_SetupAttempts();
    init_SetupIntents();
    init_ShippingRates();
    init_Sources();
    init_SubscriptionItems();
    init_SubscriptionSchedules();
    init_Subscriptions();
    init_TaxCodes();
    init_TaxIds();
    init_TaxRates();
    init_Tokens2();
    init_Topups();
    init_Transfers();
    init_WebhookEndpoints();
    Apps = resourceNamespace("apps", { Secrets });
    Billing = resourceNamespace("billing", {
      Alerts,
      CreditBalanceSummary,
      CreditBalanceTransactions,
      CreditGrants,
      MeterEventAdjustments,
      MeterEvents,
      Meters
    });
    BillingPortal = resourceNamespace("billingPortal", {
      Configurations,
      Sessions
    });
    Checkout = resourceNamespace("checkout", {
      Sessions: Sessions2
    });
    Climate = resourceNamespace("climate", {
      Orders,
      Products,
      Suppliers
    });
    Entitlements = resourceNamespace("entitlements", {
      ActiveEntitlements,
      Features
    });
    FinancialConnections = resourceNamespace("financialConnections", {
      Accounts,
      Sessions: Sessions3,
      Transactions: Transactions2
    });
    Forwarding = resourceNamespace("forwarding", {
      Requests
    });
    Identity = resourceNamespace("identity", {
      VerificationReports,
      VerificationSessions
    });
    Issuing = resourceNamespace("issuing", {
      Authorizations: Authorizations2,
      Cardholders,
      Cards: Cards2,
      Disputes,
      PersonalizationDesigns: PersonalizationDesigns2,
      PhysicalBundles,
      Tokens,
      Transactions: Transactions3
    });
    Radar = resourceNamespace("radar", {
      EarlyFraudWarnings,
      ValueListItems,
      ValueLists
    });
    Reporting = resourceNamespace("reporting", {
      ReportRuns,
      ReportTypes
    });
    Sigma = resourceNamespace("sigma", {
      ScheduledQueryRuns
    });
    Tax = resourceNamespace("tax", {
      Calculations,
      Registrations,
      Settings,
      Transactions: Transactions4
    });
    Terminal = resourceNamespace("terminal", {
      Configurations: Configurations2,
      ConnectionTokens,
      Locations,
      Readers: Readers2
    });
    TestHelpers = resourceNamespace("testHelpers", {
      ConfirmationTokens,
      Customers,
      Refunds,
      TestClocks,
      Issuing: resourceNamespace("issuing", {
        Authorizations,
        Cards,
        PersonalizationDesigns,
        Transactions
      }),
      Terminal: resourceNamespace("terminal", {
        Readers
      }),
      Treasury: resourceNamespace("treasury", {
        InboundTransfers,
        OutboundPayments,
        OutboundTransfers,
        ReceivedCredits,
        ReceivedDebits
      })
    });
    Treasury = resourceNamespace("treasury", {
      CreditReversals,
      DebitReversals,
      FinancialAccounts,
      InboundTransfers: InboundTransfers2,
      OutboundPayments: OutboundPayments2,
      OutboundTransfers: OutboundTransfers2,
      ReceivedCredits: ReceivedCredits2,
      ReceivedDebits: ReceivedDebits2,
      TransactionEntries,
      Transactions: Transactions5
    });
    V2 = resourceNamespace("v2", {
      Billing: resourceNamespace("billing", {
        MeterEventAdjustments: MeterEventAdjustments2,
        MeterEventSession,
        MeterEventStream,
        MeterEvents: MeterEvents2
      }),
      Core: resourceNamespace("core", {
        EventDestinations,
        Events
      })
    });
  }
});

// ../node_modules/stripe/esm/stripe.core.js
function createStripe(platformFunctions, requestSender = defaultRequestSenderFactory) {
  Stripe2.PACKAGE_VERSION = "18.4.0";
  Stripe2.API_VERSION = ApiVersion;
  Stripe2.USER_AGENT = Object.assign({ bindings_version: Stripe2.PACKAGE_VERSION, lang: "node", publisher: "stripe", uname: null, typescript: false }, determineProcessUserAgentProperties());
  Stripe2.StripeResource = StripeResource;
  Stripe2.resources = resources_exports;
  Stripe2.HttpClient = HttpClient;
  Stripe2.HttpClientResponse = HttpClientResponse;
  Stripe2.CryptoProvider = CryptoProvider;
  Stripe2.webhooks = createWebhooks(platformFunctions);
  function Stripe2(key, config = {}) {
    if (!(this instanceof Stripe2)) {
      return new Stripe2(key, config);
    }
    const props = this._getPropsFromConfig(config);
    this._platformFunctions = platformFunctions;
    Object.defineProperty(this, "_emitter", {
      value: this._platformFunctions.createEmitter(),
      enumerable: false,
      configurable: false,
      writable: false
    });
    this.VERSION = Stripe2.PACKAGE_VERSION;
    this.on = this._emitter.on.bind(this._emitter);
    this.once = this._emitter.once.bind(this._emitter);
    this.off = this._emitter.removeListener.bind(this._emitter);
    const agent = props.httpAgent || null;
    this._api = {
      host: props.host || DEFAULT_HOST,
      port: props.port || DEFAULT_PORT,
      protocol: props.protocol || "https",
      basePath: DEFAULT_BASE_PATH,
      version: props.apiVersion || DEFAULT_API_VERSION,
      timeout: validateInteger("timeout", props.timeout, DEFAULT_TIMEOUT),
      maxNetworkRetries: validateInteger("maxNetworkRetries", props.maxNetworkRetries, 2),
      agent,
      httpClient: props.httpClient || (agent ? this._platformFunctions.createNodeHttpClient(agent) : this._platformFunctions.createDefaultHttpClient()),
      dev: false,
      stripeAccount: props.stripeAccount || null,
      stripeContext: props.stripeContext || null
    };
    const typescript = props.typescript || false;
    if (typescript !== Stripe2.USER_AGENT.typescript) {
      Stripe2.USER_AGENT.typescript = typescript;
    }
    if (props.appInfo) {
      this._setAppInfo(props.appInfo);
    }
    this._prepResources();
    this._setAuthenticator(key, props.authenticator);
    this.errors = Error_exports;
    this.webhooks = Stripe2.webhooks;
    this._prevRequestMetrics = [];
    this._enableTelemetry = props.telemetry !== false;
    this._requestSender = requestSender(this);
    this.StripeResource = Stripe2.StripeResource;
  }
  __name(Stripe2, "Stripe");
  Stripe2.errors = Error_exports;
  Stripe2.createNodeHttpClient = platformFunctions.createNodeHttpClient;
  Stripe2.createFetchHttpClient = platformFunctions.createFetchHttpClient;
  Stripe2.createNodeCryptoProvider = platformFunctions.createNodeCryptoProvider;
  Stripe2.createSubtleCryptoProvider = platformFunctions.createSubtleCryptoProvider;
  Stripe2.prototype = {
    // Properties are set in the constructor above
    _appInfo: void 0,
    on: null,
    off: null,
    once: null,
    VERSION: null,
    StripeResource: null,
    webhooks: null,
    errors: null,
    _api: null,
    _prevRequestMetrics: null,
    _emitter: null,
    _enableTelemetry: null,
    _requestSender: null,
    _platformFunctions: null,
    rawRequest(method, path, params, options) {
      return this._requestSender._rawRequest(method, path, params, options);
    },
    /**
     * @private
     */
    _setAuthenticator(key, authenticator) {
      if (key && authenticator) {
        throw new Error("Can't specify both apiKey and authenticator");
      }
      if (!key && !authenticator) {
        throw new Error("Neither apiKey nor config.authenticator provided");
      }
      this._authenticator = key ? createApiKeyAuthenticator(key) : authenticator;
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _setAppInfo(info) {
      if (info && typeof info !== "object") {
        throw new Error("AppInfo must be an object.");
      }
      if (info && !info.name) {
        throw new Error("AppInfo.name is required");
      }
      info = info || {};
      this._appInfo = APP_INFO_PROPERTIES.reduce((accum, prop) => {
        if (typeof info[prop] == "string") {
          accum = accum || {};
          accum[prop] = info[prop];
        }
        return accum;
      }, {});
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _setApiField(key, value) {
      this._api[key] = value;
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     */
    getApiField(key) {
      return this._api[key];
    },
    setClientId(clientId) {
      this._clientId = clientId;
    },
    getClientId() {
      return this._clientId;
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     */
    getConstant: /* @__PURE__ */ __name((c) => {
      switch (c) {
        case "DEFAULT_HOST":
          return DEFAULT_HOST;
        case "DEFAULT_PORT":
          return DEFAULT_PORT;
        case "DEFAULT_BASE_PATH":
          return DEFAULT_BASE_PATH;
        case "DEFAULT_API_VERSION":
          return DEFAULT_API_VERSION;
        case "DEFAULT_TIMEOUT":
          return DEFAULT_TIMEOUT;
        case "MAX_NETWORK_RETRY_DELAY_SEC":
          return MAX_NETWORK_RETRY_DELAY_SEC;
        case "INITIAL_NETWORK_RETRY_DELAY_SEC":
          return INITIAL_NETWORK_RETRY_DELAY_SEC;
      }
      return Stripe2[c];
    }, "getConstant"),
    getMaxNetworkRetries() {
      return this.getApiField("maxNetworkRetries");
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _setApiNumberField(prop, n, defaultVal) {
      const val = validateInteger(prop, n, defaultVal);
      this._setApiField(prop, val);
    },
    getMaxNetworkRetryDelay() {
      return MAX_NETWORK_RETRY_DELAY_SEC;
    },
    getInitialNetworkRetryDelay() {
      return INITIAL_NETWORK_RETRY_DELAY_SEC;
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     *
     * Gets a JSON version of a User-Agent and uses a cached version for a slight
     * speed advantage.
     */
    getClientUserAgent(cb) {
      return this.getClientUserAgentSeeded(Stripe2.USER_AGENT, cb);
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     *
     * Gets a JSON version of a User-Agent by encoding a seeded object and
     * fetching a uname from the system.
     */
    getClientUserAgentSeeded(seed, cb) {
      this._platformFunctions.getUname().then((uname) => {
        var _a;
        const userAgent = {};
        for (const field in seed) {
          if (!Object.prototype.hasOwnProperty.call(seed, field)) {
            continue;
          }
          userAgent[field] = encodeURIComponent((_a = seed[field]) !== null && _a !== void 0 ? _a : "null");
        }
        userAgent.uname = encodeURIComponent(uname || "UNKNOWN");
        const client = this.getApiField("httpClient");
        if (client) {
          userAgent.httplib = encodeURIComponent(client.getClientName());
        }
        if (this._appInfo) {
          userAgent.application = this._appInfo;
        }
        cb(JSON.stringify(userAgent));
      });
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     */
    getAppInfoAsString() {
      if (!this._appInfo) {
        return "";
      }
      let formatted = this._appInfo.name;
      if (this._appInfo.version) {
        formatted += `/${this._appInfo.version}`;
      }
      if (this._appInfo.url) {
        formatted += ` (${this._appInfo.url})`;
      }
      return formatted;
    },
    getTelemetryEnabled() {
      return this._enableTelemetry;
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _prepResources() {
      for (const name in resources_exports) {
        if (!Object.prototype.hasOwnProperty.call(resources_exports, name)) {
          continue;
        }
        this[pascalToCamelCase(name)] = new resources_exports[name](this);
      }
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _getPropsFromConfig(config) {
      if (!config) {
        return {};
      }
      const isString = typeof config === "string";
      const isObject2 = config === Object(config) && !Array.isArray(config);
      if (!isObject2 && !isString) {
        throw new Error("Config must either be an object or a string");
      }
      if (isString) {
        return {
          apiVersion: config
        };
      }
      const values = Object.keys(config).filter((value) => !ALLOWED_CONFIG_PROPERTIES.includes(value));
      if (values.length > 0) {
        throw new Error(`Config object may only contain the following: ${ALLOWED_CONFIG_PROPERTIES.join(", ")}`);
      }
      return config;
    },
    parseThinEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
      return this.webhooks.constructEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt);
    }
  };
  return Stripe2;
}
var DEFAULT_HOST, DEFAULT_PORT, DEFAULT_BASE_PATH, DEFAULT_API_VERSION, DEFAULT_TIMEOUT, MAX_NETWORK_RETRY_DELAY_SEC, INITIAL_NETWORK_RETRY_DELAY_SEC, APP_INFO_PROPERTIES, ALLOWED_CONFIG_PROPERTIES, defaultRequestSenderFactory;
var init_stripe_core = __esm({
  "../node_modules/stripe/esm/stripe.core.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_Error();
    init_RequestSender();
    init_StripeResource();
    init_Webhooks();
    init_apiVersion();
    init_CryptoProvider();
    init_HttpClient();
    init_resources();
    init_utils3();
    DEFAULT_HOST = "api.stripe.com";
    DEFAULT_PORT = "443";
    DEFAULT_BASE_PATH = "/v1/";
    DEFAULT_API_VERSION = ApiVersion;
    DEFAULT_TIMEOUT = 8e4;
    MAX_NETWORK_RETRY_DELAY_SEC = 5;
    INITIAL_NETWORK_RETRY_DELAY_SEC = 0.5;
    APP_INFO_PROPERTIES = ["name", "version", "url", "partner_id"];
    ALLOWED_CONFIG_PROPERTIES = [
      "authenticator",
      "apiVersion",
      "typescript",
      "maxNetworkRetries",
      "httpAgent",
      "httpClient",
      "timeout",
      "host",
      "port",
      "protocol",
      "telemetry",
      "appInfo",
      "stripeAccount",
      "stripeContext"
    ];
    defaultRequestSenderFactory = /* @__PURE__ */ __name((stripe) => new RequestSender(stripe, StripeResource.MAX_BUFFERED_REQUEST_METRICS), "defaultRequestSenderFactory");
    __name(createStripe, "createStripe");
  }
});

// ../node_modules/stripe/esm/stripe.esm.worker.js
var Stripe, stripe_esm_worker_default;
var init_stripe_esm_worker = __esm({
  "../node_modules/stripe/esm/stripe.esm.worker.js"() {
    init_functionsRoutes_0_8044054200943971();
    init_WebPlatformFunctions();
    init_stripe_core();
    Stripe = createStripe(new WebPlatformFunctions());
    stripe_esm_worker_default = Stripe;
  }
});

// api/stripe-webhook.ts
function json22(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "https://stripe.com"
      // Only allow Stripe
    }
  });
}
async function getWebhookSecret(env) {
  if (env.STRIPE_WEBHOOK_SECRET) return env.STRIPE_WEBHOOK_SECRET;
  try {
    const row = await env.DB.prepare("SELECT value FROM settings WHERE key = ?").bind("payment_stripeWebhookSecret").first();
    if (row && row.value) return typeof row.value === "string" ? row.value : String(row.value);
  } catch (e) {
  }
  return null;
}
async function generateInvoicePDF(invoiceData) {
  return `/api/invoices/${invoiceData.invoiceNumber}.pdf`;
}
async function handleCheckoutSessionCompleted(session, storage2) {
  console.log("Processing checkout.session.completed for session:", session.id);
  const customerEmail = session.customer_details?.email;
  const customerName = session.customer_details?.name;
  const paymentIntentId = typeof session.payment_intent === "string" ? session.payment_intent : "";
  const amount = session.amount_total ? session.amount_total / 100 : 0;
  const currency = session.currency || "usd";
  if (!customerEmail) {
    throw new Error("Customer email is required for checkout completion");
  }
  if (paymentIntentId) {
    const existing = await storage2.getOrderByPaymentIntentId(paymentIntentId);
    if (existing) {
      console.log(`Idempotency: order already exists for paymentIntentId=${paymentIntentId}. Order ID: ${existing.id}`);
      return;
    }
  }
  console.log(`Processing purchase for: ${customerEmail}, Amount: ${amount} ${currency.toUpperCase()}`);
  const now = (/* @__PURE__ */ new Date()).getTime();
  try {
    let customer = await storage2.getCustomerByEmail(customerEmail);
    if (!customer) {
      console.log(`Creating new customer: ${customerEmail}`);
      customer = await storage2.createCustomer({
        email: customerEmail,
        name: customerName || customerEmail,
        extensionActivated: true,
        subscriptionStatus: "active",
        totalSpent: amount.toString(),
        totalOrders: 1,
        lastOrderDate: now
      });
    } else {
      console.log(`Updating existing customer: ${customerEmail}`);
      await storage2.updateCustomer(customer.id, {
        extensionActivated: true,
        subscriptionStatus: "active",
        totalSpent: (parseFloat(customer.totalSpent) + amount).toString(),
        totalOrders: customer.totalOrders + 1,
        lastOrderDate: now,
        updatedAt: now
      });
    }
    const user = await storage2.getUserByEmail(customerEmail);
    if (user) {
      console.log(`Updating user premium status: ${customerEmail}`);
      await storage2.updateUser(user.id, {
        isPremium: true,
        extensionActivated: true,
        premiumActivatedAt: now.toString(),
        totalSpent: (parseFloat(user.totalSpent) + amount).toString(),
        totalOrders: user.totalOrders + 1
      });
    }
    const downloadToken = `download_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const activationCode = `activation_${Date.now()}_${Math.random().toString(36).substr(2, 12)}`;
    console.log("Creating order record...");
    const order = await storage2.createOrder({
      userId: user?.id || null,
      customerEmail,
      customerName: customerName || customerEmail,
      originalAmount: amount.toString(),
      finalAmount: amount.toString(),
      currency: currency.toLowerCase(),
      status: "completed",
      paymentMethod: "stripe",
      paymentIntentId,
      downloadToken,
      activationCode,
      completedAt: now
    });
    console.log(`Order created with ID: ${order.id}`);
    const invoiceNumber = `INV-${order.id}-${Date.now()}`;
    console.log(`Creating invoice: ${invoiceNumber}`);
    const invoice = await storage2.createInvoice({
      orderId: order.id,
      invoiceNumber,
      customerId: customer.id,
      customerName: customerName || customerEmail,
      customerEmail,
      invoiceDate: now,
      dueDate: now,
      // Immediate payment
      subtotal: amount.toString(),
      taxAmount: "0.00",
      discountAmount: "0.00",
      totalAmount: amount.toString(),
      currency: currency.toUpperCase(),
      status: "paid",
      paidAt: now
    });
    await storage2.createInvoiceItem({
      invoiceId: invoice.id,
      productName: "OCUS Job Hunter Extension",
      description: "Premium Chrome Extension for OCUS Job Hunting",
      quantity: 1,
      unitPrice: amount.toString(),
      totalPrice: amount.toString()
    });
    const activationKey = await storage2.createActivationKey({
      activationKey: activationCode,
      orderId: order.id,
      userId: user?.id
    });
    console.log(`Activation key created: ${activationKey.activationKey}`);
    const invoiceUrl = await generateInvoicePDF({
      invoiceNumber,
      customerName: customerName || customerEmail,
      customerEmail,
      amount,
      currency,
      date: new Date(now).toISOString()
    });
    await storage2.updateOrder(order.id, { invoiceUrl });
    console.log(`\u2705 Successfully processed purchase for ${customerEmail}:`);
    console.log(`   - Customer ID: ${customer.id}`);
    console.log(`   - Order ID: ${order.id}`);
    console.log(`   - Invoice: ${invoiceNumber}`);
    console.log(`   - Activation Code: ${activationCode}`);
    console.log(`   - Amount: ${amount} ${currency.toUpperCase()}`);
  } catch (error) {
    console.error("Error in handleCheckoutSessionCompleted:", error);
    throw new Error(`Failed to process checkout completion: ${error.message}`);
  }
}
var onRequestPost26, onRequestOptions57;
var init_stripe_webhook = __esm({
  "api/stripe-webhook.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_storage();
    init_stripe_esm_worker();
    init_d1();
    init_schema();
    __name(json22, "json");
    __name(getWebhookSecret, "getWebhookSecret");
    __name(generateInvoicePDF, "generateInvoicePDF");
    onRequestPost26 = /* @__PURE__ */ __name(async (ctx) => {
      const { request, env, waitUntil } = ctx;
      const signature = request.headers.get("stripe-signature") || request.headers.get("Stripe-Signature");
      if (!signature) {
        console.error("Webhook Error: Missing Stripe-Signature header");
        return new Response("Missing Stripe-Signature header", { status: 400 });
      }
      if (!env.STRIPE_SECRET_KEY) {
        console.error("Missing STRIPE_SECRET_KEY");
        return new Response("Server not configured", { status: 500 });
      }
      const webhookSecret = await getWebhookSecret(env);
      if (!webhookSecret) {
        console.error("Missing STRIPE_WEBHOOK_SECRET");
        return new Response("Webhook not configured", { status: 500 });
      }
      let event;
      try {
        const stripe = new stripe_esm_worker_default(env.STRIPE_SECRET_KEY, {
          // Use account default API version
          httpClient: stripe_esm_worker_default.createFetchHttpClient()
        });
        const body = await request.text();
        const cryptoProvider = stripe_esm_worker_default.createSubtleCryptoProvider();
        event = await stripe.webhooks.constructEventAsync(body, signature, webhookSecret, void 0, cryptoProvider);
        console.log("Stripe webhook signature verified for event:", event.type);
      } catch (err) {
        console.error("Webhook signature verification failed:", err?.message || err);
        return new Response(`Webhook signature verification failed: ${err?.message || "unknown error"}`, { status: 400 });
      }
      const db = drizzle(env.DB, { schema: schema_exports });
      const storage2 = new DatabaseStorage(db);
      try {
        switch (event.type) {
          case "checkout.session.completed":
            console.log("Scheduling checkout.session.completed processing via waitUntil");
            waitUntil((async () => {
              try {
                await handleCheckoutSessionCompleted(event.data.object, storage2);
              } catch (e) {
                console.error("Deferred processing error (checkout.session.completed):", e);
              }
            })());
            break;
          case "payment_intent.succeeded":
            console.log("Payment intent succeeded:", event.data.object.id);
            break;
          case "payment_intent.payment_failed":
            console.log("Payment intent failed:", event.data.object.id);
            break;
          case "customer.subscription.created":
          case "customer.subscription.updated":
          case "customer.subscription.deleted":
            console.log("Subscription event:", event.type, event.data.object.id);
            break;
          default:
            console.log(`Unhandled event type: ${event.type}`);
        }
        return json22({ received: true, scheduled: true });
      } catch (err) {
        console.error("Error processing Stripe webhook:", err);
        return new Response(`Webhook processing error: ${err.message}`, { status: 500 });
      }
    }, "onRequestPost");
    __name(handleCheckoutSessionCompleted, "handleCheckoutSessionCompleted");
    onRequestOptions57 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "https://stripe.com",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, stripe-signature, Stripe-Signature",
          "Access-Control-Max-Age": "86400"
        }
      });
    }, "onRequestOptions");
  }
});

// api/test-upload.ts
var onRequestPost27, onRequestOptions58;
var init_test_upload = __esm({
  "api/test-upload.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_settings_storage();
    onRequestPost27 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        console.log("=== TEST UPLOAD ENDPOINT ===");
        if (!env.DB) {
          return new Response(JSON.stringify({
            success: false,
            message: "Database not available"
          }), {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
        const formData = await request.formData();
        console.log("Test upload - FormData keys:", Array.from(formData.keys()));
        const testFile = formData.get("testImage");
        console.log("Test file received:", testFile ? `${testFile.name} (${testFile.size} bytes, ${testFile.type})` : "null");
        if (testFile && testFile.size > 0) {
          console.log("Converting test file to base64...");
          const arrayBuffer = await testFile.arrayBuffer();
          const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
          const dataUrl = `data:${testFile.type};base64,${base64}`;
          console.log("Test file converted, data URL length:", dataUrl.length);
          const settingsStorage = new SettingsStorage(env.DB);
          await settingsStorage.initializeSettings();
          console.log("Saving test image to database...");
          await settingsStorage.setSetting("test_image", dataUrl);
          console.log("Test image saved successfully");
          console.log("Verifying saved data...");
          const savedData = await settingsStorage.getSetting("test_image");
          console.log("Retrieved data length:", savedData ? savedData.length : "null");
          return new Response(JSON.stringify({
            success: true,
            message: "Test upload successful",
            originalSize: testFile.size,
            dataUrlLength: dataUrl.length,
            savedDataLength: savedData ? savedData.length : 0,
            verified: savedData === dataUrl
          }), {
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        } else {
          return new Response(JSON.stringify({
            success: false,
            message: "No file received or file is empty"
          }), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }
      } catch (error) {
        console.error("Test upload error:", error);
        const message = error instanceof Error ? error.message : String(error);
        return new Response(JSON.stringify({
          success: false,
          message: `Test upload failed: ${message}`
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }
    }, "onRequestPost");
    onRequestOptions58 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        status: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization"
        }
      });
    }, "onRequestOptions");
  }
});

// api/test-user.ts
function json23(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var onRequestPost28;
var init_test_user = __esm({
  "api/test-user.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    __name(json23, "json");
    onRequestPost28 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const body = await request.json();
        const email = body.email || "heshmat@gmail.com";
        if (!env.DB) {
          return json23({ success: false, message: "Database not available" }, 500);
        }
        const user = await env.DB.prepare(`
      SELECT id, email, name, is_premium, extension_activated, premium_activated_at, created_at
      FROM users WHERE email = ?
    `).bind(email).first();
        const customer = await env.DB.prepare(`
      SELECT id, email, name, is_premium, extension_activated, created_at
      FROM customers WHERE email = ?
    `).bind(email).first();
        const ordersUserQuery = await env.DB.prepare(`
      SELECT id, customer_id, customer_email, original_amount, final_amount, status, created_at, completed_at
      FROM orders WHERE customer_email = ?
    `).bind(email).all();
        const ordersCustomerQuery = customer ? await env.DB.prepare(`
      SELECT id, customer_id, customer_email, original_amount, final_amount, status, created_at, completed_at
      FROM orders WHERE customer_id = ?
    `).bind(customer.id).all() : { results: [] };
        return json23({
          success: true,
          email,
          user,
          customer,
          ordersFromEmail: ordersUserQuery.results,
          ordersFromCustomerId: ordersCustomerQuery.results,
          summary: {
            userExists: !!user,
            customerExists: !!customer,
            userPremium: user?.is_premium === 1,
            customerPremium: customer?.is_premium === 1,
            userExtensionActivated: user?.extension_activated === 1,
            customerExtensionActivated: customer?.extension_activated === 1,
            totalOrdersFromEmail: ordersUserQuery.results?.length || 0,
            totalOrdersFromCustomerId: ordersCustomerQuery.results?.length || 0
          }
        });
      } catch (error) {
        console.error("Error checking user data:", error);
        return json23({
          success: false,
          message: error.message
        }, 500);
      }
    }, "onRequestPost");
  }
});

// api/tickets/index.ts
function json24(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var onRequestOptions59, onRequestGet58, onRequestPost29;
var init_tickets2 = __esm({
  "api/tickets/index.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    init_db();
    init_user_storage();
    __name(json24, "json");
    onRequestOptions59 = /* @__PURE__ */ __name(async () => {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, PATCH, DELETE, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
    onRequestGet58 = /* @__PURE__ */ __name(async ({ request, env }) => {
      const expressBase = env?.EXPRESS_API_BASE;
      if (expressBase) {
        const base = expressBase.replace(/\/$/, "");
        const urlObj = new URL(request.url);
        const qs2 = urlObj.search ? urlObj.search : "";
        const url2 = `${base}/api/tickets${qs2}`;
        const headers = {};
        const cookie = request.headers.get("cookie");
        const auth = request.headers.get("authorization");
        if (cookie) headers["cookie"] = cookie;
        if (auth) headers["authorization"] = auth;
        const proxied = await fetch(url2, { headers, redirect: "manual" });
        const respHeaders = new Headers(proxied.headers);
        const setCookie = respHeaders.get("set-cookie");
        if (setCookie) {
          const rewritten = setCookie.replace(/;\s*Domain=[^;]+/i, "");
          respHeaders.delete("set-cookie");
          respHeaders.append("set-cookie", rewritten);
        }
        return new Response(proxied.body, { status: proxied.status, headers: respHeaders });
      }
      const url = new URL(request.url);
      const isAdmin = url.searchParams.get("isAdmin") === "true";
      const customerEmail = url.searchParams.get("customerEmail");
      const customerId = url.searchParams.get("customerId");
      if (!env.DB) {
        console.error("D1 database not available");
        return json24({ error: "Database not available" }, 500);
      }
      try {
        const storage2 = new TicketStorage(env.DB);
        let result = [];
        if (isAdmin) {
          result = await storage2.getAllTickets();
        } else if (customerId) {
          result = await storage2.getTicketsByCustomerId(parseInt(customerId));
        } else if (customerEmail) {
          result = await storage2.getTicketsByCustomerEmail(customerEmail);
        } else {
          result = [];
        }
        return json24(result);
      } catch (error) {
        console.error("Database error:", error);
        return json24({ error: "Database query failed", details: error.message }, 500);
      }
    }, "onRequestGet");
    onRequestPost29 = /* @__PURE__ */ __name(async ({ request, env }) => {
      try {
        const expressBase = env?.EXPRESS_API_BASE;
        if (expressBase) {
          const base = expressBase.replace(/\/$/, "");
          const url = `${base}/api/tickets`;
          const headers = {};
          const cookie = request.headers.get("cookie");
          const ct = request.headers.get("content-type");
          const auth = request.headers.get("authorization");
          if (cookie) headers["cookie"] = cookie;
          if (ct) headers["content-type"] = ct;
          if (auth) headers["authorization"] = auth;
          const proxied = await fetch(url, { method: "POST", headers, body: request.body, redirect: "manual" });
          const respHeaders = new Headers(proxied.headers);
          const setCookie = respHeaders.get("set-cookie");
          if (setCookie) {
            const rewritten = setCookie.replace(/;\s*Domain=[^;]+/i, "");
            respHeaders.delete("set-cookie");
            respHeaders.append("set-cookie", rewritten);
          }
          return new Response(proxied.body, { status: proxied.status, headers: respHeaders });
        }
        const body = await request.json();
        const { title, description, category, priority, customerEmail, customerName, customerId } = body;
        const parsedCustomerId = customerId ? parseInt(customerId) : void 0;
        if (!title || !description || !customerEmail || !parsedCustomerId) {
          return json24({ success: false, message: "Missing required fields" }, 400);
        }
        if (!env.DB) {
          console.error("D1 database not available for ticket creation");
          return json24({ success: false, message: "Database not available" }, 500);
        }
        const storage2 = new TicketStorage(env.DB);
        let finalCustomerName = customerName;
        if (parsedCustomerId && !customerName) {
          try {
            const userStorage = new UserStorage(env.DB);
            await userStorage.initializeUsers();
            const user = await userStorage.getUserById(parsedCustomerId);
            if (user) {
              finalCustomerName = user.name;
            }
          } catch (error) {
            console.error("Failed to fetch user name:", error);
          }
        }
        const ticket = await storage2.createTicket({
          customer_id: parsedCustomerId,
          title,
          description,
          category: category || "general",
          priority: priority || "medium",
          status: "open",
          customer_email: customerEmail,
          customer_name: finalCustomerName || customerEmail
        });
        return json24({ success: true, ticket });
      } catch (e) {
        console.error("Failed to create ticket:", e);
        const message = e instanceof Error ? e.message : "An unknown error occurred";
        return json24({ success: false, message }, 500);
      }
    }, "onRequestPost");
  }
});

// health.ts
var onRequestGet59;
var init_health = __esm({
  "health.ts"() {
    "use strict";
    init_functionsRoutes_0_8044054200943971();
    onRequestGet59 = /* @__PURE__ */ __name(async () => {
      return new Response(JSON.stringify({
        status: "ok",
        timestamp: Date.now(),
        message: "OCUS Job Hunter API is running"
      }), {
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*"
        }
      });
    }, "onRequestGet");
  }
});

// ../.wrangler/tmp/pages-UCTxDL/functionsRoutes-0.8044054200943971.mjs
var routes;
var init_functionsRoutes_0_8044054200943971 = __esm({
  "../.wrangler/tmp/pages-UCTxDL/functionsRoutes-0.8044054200943971.mjs"() {
    "use strict";
    init_translate();
    init_translate();
    init_list();
    init_id();
    init_id();
    init_id();
    init_id();
    init_id2();
    init_id2();
    init_id2();
    init_id2();
    init_feature();
    init_feature();
    init_orderId();
    init_id3();
    init_id4();
    init_download();
    init_download_receipt();
    init_html();
    init_receipt();
    init_archive();
    init_messages();
    init_messages();
    init_messages();
    init_status();
    init_status();
    init_purchase_status();
    init_invoices();
    init_invoices();
    init_orders();
    init_orders();
    init_purchase_status2();
    init_purchase_status2();
    init_analytics();
    init_analytics();
    init_announcement_badges();
    init_announcement_badges();
    init_announcement_badges();
    init_announcement_badges();
    init_announcement_badges();
    init_auth_settings();
    init_auth_settings();
    init_auth_settings();
    init_chat_settings();
    init_chat_settings();
    init_chat_settings();
    init_check_user_data();
    init_countdown_banners();
    init_countdown_banners();
    init_countdown_banners();
    init_countdown_banners();
    init_countdown_banners();
    init_create_default_banner();
    init_create_default_banner();
    init_customers();
    init_customers();
    init_dashboard_features();
    init_dashboard_features();
    init_dashboard_features();
    init_fix_banner_price();
    init_fix_existing_purchases();
    init_fix_existing_purchases();
    init_fix_premium_users();
    init_fix_purchased_users();
    init_force_update_price();
    init_invoices2();
    init_invoices2();
    init_login();
    init_login();
    init_orders2();
    init_orders2();
    init_payment_settings();
    init_payment_settings();
    init_payment_settings();
    init_pricing();
    init_pricing();
    init_pricing();
    init_reset_db();
    init_reset_db();
    init_seo_settings();
    init_seo_settings();
    init_seo_settings();
    init_seo_settings();
    init_stats();
    init_stats();
    init_sync_banner_price();
    init_sync_banner_price();
    init_tickets();
    init_tickets();
    init_update_banner_price();
    init_update_banner_price();
    init_update_banner_price_direct();
    init_update_premium_status();
    init_update_premium_status();
    init_update_user_premium();
    init_users();
    init_users();
    init_active();
    init_active();
    init_facebook();
    init_github();
    init_google();
    init_register();
    init_register();
    init_active2();
    init_active2();
    init_login2();
    init_login2();
    init_profile();
    init_profile();
    init_profile();
    init_register2();
    init_register2();
    init_stats2();
    init_stats2();
    init_premium();
    init_trial();
    init_premium_extension();
    init_premium_extension();
    init_customer();
    init_generate();
    init_generate();
    init_invoices3();
    init_invoices3();
    init_orders3();
    init_orders3();
    init_complete_purchase();
    init_complete_purchase();
    init_user_orders();
    init_user_orders();
    init_pricing2();
    init_pricing2();
    init_type();
    init_type();
    init_orderId2();
    init_id5();
    init_id5();
    init_id5();
    init_id5();
    init_auth_settings2();
    init_auth_settings2();
    init_chat();
    init_chat();
    init_complete_stripe_payment();
    init_complete_stripe_payment();
    init_create_user_payment_intent();
    init_create_user_payment_intent();
    init_download_premium();
    init_download_premium();
    init_download_premium();
    init_init_db();
    init_init_db();
    init_invoice_settings();
    init_invoice_settings();
    init_invoice_settings();
    init_invoices4();
    init_me();
    init_migrate_db();
    init_migrate_db();
    init_purchase_complete();
    init_purchase_complete();
    init_stripe_webhook();
    init_stripe_webhook();
    init_test_upload();
    init_test_upload();
    init_test_user();
    init_tickets2();
    init_tickets2();
    init_tickets2();
    init_health();
    routes = [
      {
        routePath: "/api/admin/announcement-badges/translate",
        mountPath: "/api/admin/announcement-badges",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions]
      },
      {
        routePath: "/api/admin/announcement-badges/translate",
        mountPath: "/api/admin/announcement-badges",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost]
      },
      {
        routePath: "/api/invoices/admin/list",
        mountPath: "/api/invoices/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet]
      },
      {
        routePath: "/api/admin/announcement-badges/:id",
        mountPath: "/api/admin/announcement-badges",
        method: "DELETE",
        middlewares: [],
        modules: [onRequestDelete]
      },
      {
        routePath: "/api/admin/announcement-badges/:id",
        mountPath: "/api/admin/announcement-badges",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet2]
      },
      {
        routePath: "/api/admin/announcement-badges/:id",
        mountPath: "/api/admin/announcement-badges",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions2]
      },
      {
        routePath: "/api/admin/announcement-badges/:id",
        mountPath: "/api/admin/announcement-badges",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut]
      },
      {
        routePath: "/api/admin/countdown-banners/:id",
        mountPath: "/api/admin/countdown-banners",
        method: "DELETE",
        middlewares: [],
        modules: [onRequestDelete2]
      },
      {
        routePath: "/api/admin/countdown-banners/:id",
        mountPath: "/api/admin/countdown-banners",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet3]
      },
      {
        routePath: "/api/admin/countdown-banners/:id",
        mountPath: "/api/admin/countdown-banners",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions3]
      },
      {
        routePath: "/api/admin/countdown-banners/:id",
        mountPath: "/api/admin/countdown-banners",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut2]
      },
      {
        routePath: "/api/admin/dashboard-features/:feature",
        mountPath: "/api/admin/dashboard-features",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions4]
      },
      {
        routePath: "/api/admin/dashboard-features/:feature",
        mountPath: "/api/admin/dashboard-features",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut3]
      },
      {
        routePath: "/api/admin/orders/:orderId",
        mountPath: "/api/admin/orders",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut4]
      },
      {
        routePath: "/api/extension/check/:id",
        mountPath: "/api/extension/check",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet4]
      },
      {
        routePath: "/api/extension/downloads/:id",
        mountPath: "/api/extension/downloads",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet5]
      },
      {
        routePath: "/api/invoices/:id/download",
        mountPath: "/api/invoices/:id",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet6]
      },
      {
        routePath: "/api/invoices/:id/download-receipt",
        mountPath: "/api/invoices/:id",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet7]
      },
      {
        routePath: "/api/invoices/:id/html",
        mountPath: "/api/invoices/:id",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet8]
      },
      {
        routePath: "/api/invoices/:id/receipt",
        mountPath: "/api/invoices/:id",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet9]
      },
      {
        routePath: "/api/tickets/:id/archive",
        mountPath: "/api/tickets/:id",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost2]
      },
      {
        routePath: "/api/tickets/:id/messages",
        mountPath: "/api/tickets/:id",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet10]
      },
      {
        routePath: "/api/tickets/:id/messages",
        mountPath: "/api/tickets/:id",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions5]
      },
      {
        routePath: "/api/tickets/:id/messages",
        mountPath: "/api/tickets/:id",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost3]
      },
      {
        routePath: "/api/tickets/:id/status",
        mountPath: "/api/tickets/:id",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions6]
      },
      {
        routePath: "/api/tickets/:id/status",
        mountPath: "/api/tickets/:id",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut5]
      },
      {
        routePath: "/api/user/:id/purchase-status",
        mountPath: "/api/user/:id",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet11]
      },
      {
        routePath: "/api/user/:userId/invoices",
        mountPath: "/api/user/:userId",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet12]
      },
      {
        routePath: "/api/user/:userId/invoices",
        mountPath: "/api/user/:userId",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions7]
      },
      {
        routePath: "/api/user/:userId/orders",
        mountPath: "/api/user/:userId",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet13]
      },
      {
        routePath: "/api/user/:userId/orders",
        mountPath: "/api/user/:userId",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions8]
      },
      {
        routePath: "/api/user/:userId/purchase-status",
        mountPath: "/api/user/:userId",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet14]
      },
      {
        routePath: "/api/user/:userId/purchase-status",
        mountPath: "/api/user/:userId",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions9]
      },
      {
        routePath: "/api/admin/analytics",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet15]
      },
      {
        routePath: "/api/admin/analytics",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions10]
      },
      {
        routePath: "/api/admin/announcement-badges",
        mountPath: "/api/admin",
        method: "DELETE",
        middlewares: [],
        modules: [onRequestDelete3]
      },
      {
        routePath: "/api/admin/announcement-badges",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet16]
      },
      {
        routePath: "/api/admin/announcement-badges",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions11]
      },
      {
        routePath: "/api/admin/announcement-badges",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost4]
      },
      {
        routePath: "/api/admin/announcement-badges",
        mountPath: "/api/admin",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut6]
      },
      {
        routePath: "/api/admin/auth-settings",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet17]
      },
      {
        routePath: "/api/admin/auth-settings",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions12]
      },
      {
        routePath: "/api/admin/auth-settings",
        mountPath: "/api/admin",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut7]
      },
      {
        routePath: "/api/admin/chat-settings",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet18]
      },
      {
        routePath: "/api/admin/chat-settings",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions13]
      },
      {
        routePath: "/api/admin/chat-settings",
        mountPath: "/api/admin",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut8]
      },
      {
        routePath: "/api/admin/check-user-data",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet19]
      },
      {
        routePath: "/api/admin/countdown-banners",
        mountPath: "/api/admin",
        method: "DELETE",
        middlewares: [],
        modules: [onRequestDelete4]
      },
      {
        routePath: "/api/admin/countdown-banners",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet20]
      },
      {
        routePath: "/api/admin/countdown-banners",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions14]
      },
      {
        routePath: "/api/admin/countdown-banners",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost5]
      },
      {
        routePath: "/api/admin/countdown-banners",
        mountPath: "/api/admin",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut9]
      },
      {
        routePath: "/api/admin/create-default-banner",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions15]
      },
      {
        routePath: "/api/admin/create-default-banner",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost6]
      },
      {
        routePath: "/api/admin/customers",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet21]
      },
      {
        routePath: "/api/admin/customers",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions16]
      },
      {
        routePath: "/api/admin/dashboard-features",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet22]
      },
      {
        routePath: "/api/admin/dashboard-features",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions17]
      },
      {
        routePath: "/api/admin/dashboard-features",
        mountPath: "/api/admin",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut10]
      },
      {
        routePath: "/api/admin/fix-banner-price",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost7]
      },
      {
        routePath: "/api/admin/fix-existing-purchases",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions18]
      },
      {
        routePath: "/api/admin/fix-existing-purchases",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost8]
      },
      {
        routePath: "/api/admin/fix-premium-users",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost9]
      },
      {
        routePath: "/api/admin/fix-purchased-users",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost10]
      },
      {
        routePath: "/api/admin/force-update-price",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet23]
      },
      {
        routePath: "/api/admin/invoices",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet24]
      },
      {
        routePath: "/api/admin/invoices",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions19]
      },
      {
        routePath: "/api/admin/login",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions20]
      },
      {
        routePath: "/api/admin/login",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost11]
      },
      {
        routePath: "/api/admin/orders",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet25]
      },
      {
        routePath: "/api/admin/orders",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions21]
      },
      {
        routePath: "/api/admin/payment-settings",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet26]
      },
      {
        routePath: "/api/admin/payment-settings",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions22]
      },
      {
        routePath: "/api/admin/payment-settings",
        mountPath: "/api/admin",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut11]
      },
      {
        routePath: "/api/admin/pricing",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet27]
      },
      {
        routePath: "/api/admin/pricing",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions23]
      },
      {
        routePath: "/api/admin/pricing",
        mountPath: "/api/admin",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut12]
      },
      {
        routePath: "/api/admin/reset-db",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions24]
      },
      {
        routePath: "/api/admin/reset-db",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost12]
      },
      {
        routePath: "/api/admin/seo-settings",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet28]
      },
      {
        routePath: "/api/admin/seo-settings",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions25]
      },
      {
        routePath: "/api/admin/seo-settings",
        mountPath: "/api/admin",
        method: "PATCH",
        middlewares: [],
        modules: [onRequestPatch]
      },
      {
        routePath: "/api/admin/seo-settings",
        mountPath: "/api/admin",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut13]
      },
      {
        routePath: "/api/admin/stats",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet29]
      },
      {
        routePath: "/api/admin/stats",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions26]
      },
      {
        routePath: "/api/admin/sync-banner-price",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions27]
      },
      {
        routePath: "/api/admin/sync-banner-price",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost13]
      },
      {
        routePath: "/api/admin/tickets",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet30]
      },
      {
        routePath: "/api/admin/tickets",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions28]
      },
      {
        routePath: "/api/admin/update-banner-price",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions29]
      },
      {
        routePath: "/api/admin/update-banner-price",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost14]
      },
      {
        routePath: "/api/admin/update-banner-price-direct",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet31]
      },
      {
        routePath: "/api/admin/update-premium-status",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet32]
      },
      {
        routePath: "/api/admin/update-premium-status",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions30]
      },
      {
        routePath: "/api/admin/update-user-premium",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost15]
      },
      {
        routePath: "/api/admin/users",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet33]
      },
      {
        routePath: "/api/admin/users",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions31]
      },
      {
        routePath: "/api/announcement-badge/active",
        mountPath: "/api/announcement-badge",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet34]
      },
      {
        routePath: "/api/announcement-badge/active",
        mountPath: "/api/announcement-badge",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions32]
      },
      {
        routePath: "/api/auth/facebook",
        mountPath: "/api/auth",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet35]
      },
      {
        routePath: "/api/auth/github",
        mountPath: "/api/auth",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet36]
      },
      {
        routePath: "/api/auth/google",
        mountPath: "/api/auth",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet37]
      },
      {
        routePath: "/api/auth/register",
        mountPath: "/api/auth",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions33]
      },
      {
        routePath: "/api/auth/register",
        mountPath: "/api/auth",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost16]
      },
      {
        routePath: "/api/countdown-banner/active",
        mountPath: "/api/countdown-banner",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet38]
      },
      {
        routePath: "/api/countdown-banner/active",
        mountPath: "/api/countdown-banner",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions34]
      },
      {
        routePath: "/api/customer/login",
        mountPath: "/api/customer",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions35]
      },
      {
        routePath: "/api/customer/login",
        mountPath: "/api/customer",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost17]
      },
      {
        routePath: "/api/customer/profile",
        mountPath: "/api/customer",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet39]
      },
      {
        routePath: "/api/customer/profile",
        mountPath: "/api/customer",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions36]
      },
      {
        routePath: "/api/customer/profile",
        mountPath: "/api/customer",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut14]
      },
      {
        routePath: "/api/customer/register",
        mountPath: "/api/customer",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions37]
      },
      {
        routePath: "/api/customer/register",
        mountPath: "/api/customer",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost18]
      },
      {
        routePath: "/api/customer/stats",
        mountPath: "/api/customer",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet40]
      },
      {
        routePath: "/api/customer/stats",
        mountPath: "/api/customer",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions38]
      },
      {
        routePath: "/api/download-extension/premium",
        mountPath: "/api/download-extension",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet41]
      },
      {
        routePath: "/api/download-extension/trial",
        mountPath: "/api/download-extension",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet42]
      },
      {
        routePath: "/api/downloads/premium-extension",
        mountPath: "/api/downloads",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet43]
      },
      {
        routePath: "/api/downloads/premium-extension",
        mountPath: "/api/downloads",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions39]
      },
      {
        routePath: "/api/invoices/customer",
        mountPath: "/api/invoices",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet44]
      },
      {
        routePath: "/api/invoices/generate",
        mountPath: "/api/invoices",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet45]
      },
      {
        routePath: "/api/invoices/generate",
        mountPath: "/api/invoices",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions40]
      },
      {
        routePath: "/api/me/invoices",
        mountPath: "/api/me",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet46]
      },
      {
        routePath: "/api/me/invoices",
        mountPath: "/api/me",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions41]
      },
      {
        routePath: "/api/me/orders",
        mountPath: "/api/me",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet47]
      },
      {
        routePath: "/api/me/orders",
        mountPath: "/api/me",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions42]
      },
      {
        routePath: "/api/orders/complete-purchase",
        mountPath: "/api/orders",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions43]
      },
      {
        routePath: "/api/orders/complete-purchase",
        mountPath: "/api/orders",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost19]
      },
      {
        routePath: "/api/orders/user-orders",
        mountPath: "/api/orders",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet48]
      },
      {
        routePath: "/api/orders/user-orders",
        mountPath: "/api/orders",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions44]
      },
      {
        routePath: "/api/products/pricing",
        mountPath: "/api/products",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet49]
      },
      {
        routePath: "/api/products/pricing",
        mountPath: "/api/products",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions45]
      },
      {
        routePath: "/api/download-extension/:type",
        mountPath: "/api/download-extension",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet50]
      },
      {
        routePath: "/api/download-extension/:type",
        mountPath: "/api/download-extension",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions46]
      },
      {
        routePath: "/api/generate-invoice/:orderId",
        mountPath: "/api/generate-invoice",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost20]
      },
      {
        routePath: "/api/tickets/:id",
        mountPath: "/api/tickets",
        method: "DELETE",
        middlewares: [],
        modules: [onRequestDelete5]
      },
      {
        routePath: "/api/tickets/:id",
        mountPath: "/api/tickets",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions47]
      },
      {
        routePath: "/api/tickets/:id",
        mountPath: "/api/tickets",
        method: "PATCH",
        middlewares: [],
        modules: [onRequestPatch2]
      },
      {
        routePath: "/api/tickets/:id",
        mountPath: "/api/tickets",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut15]
      },
      {
        routePath: "/api/auth-settings",
        mountPath: "/api",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet51]
      },
      {
        routePath: "/api/auth-settings",
        mountPath: "/api",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions48]
      },
      {
        routePath: "/api/chat",
        mountPath: "/api",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions49]
      },
      {
        routePath: "/api/chat",
        mountPath: "/api",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost21]
      },
      {
        routePath: "/api/complete-stripe-payment",
        mountPath: "/api",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions50]
      },
      {
        routePath: "/api/complete-stripe-payment",
        mountPath: "/api",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost22]
      },
      {
        routePath: "/api/create-user-payment-intent",
        mountPath: "/api",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions51]
      },
      {
        routePath: "/api/create-user-payment-intent",
        mountPath: "/api",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost23]
      },
      {
        routePath: "/api/download-premium",
        mountPath: "/api",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet52]
      },
      {
        routePath: "/api/download-premium",
        mountPath: "/api",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions52]
      },
      {
        routePath: "/api/download-premium",
        mountPath: "/api",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost24]
      },
      {
        routePath: "/api/init-db",
        mountPath: "/api",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet53]
      },
      {
        routePath: "/api/init-db",
        mountPath: "/api",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions53]
      },
      {
        routePath: "/api/invoice-settings",
        mountPath: "/api",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet54]
      },
      {
        routePath: "/api/invoice-settings",
        mountPath: "/api",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions54]
      },
      {
        routePath: "/api/invoice-settings",
        mountPath: "/api",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut16]
      },
      {
        routePath: "/api/invoices",
        mountPath: "/api",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet55]
      },
      {
        routePath: "/api/me",
        mountPath: "/api",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet56]
      },
      {
        routePath: "/api/migrate-db",
        mountPath: "/api",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet57]
      },
      {
        routePath: "/api/migrate-db",
        mountPath: "/api",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions55]
      },
      {
        routePath: "/api/purchase-complete",
        mountPath: "/api",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions56]
      },
      {
        routePath: "/api/purchase-complete",
        mountPath: "/api",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost25]
      },
      {
        routePath: "/api/stripe-webhook",
        mountPath: "/api",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions57]
      },
      {
        routePath: "/api/stripe-webhook",
        mountPath: "/api",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost26]
      },
      {
        routePath: "/api/test-upload",
        mountPath: "/api",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions58]
      },
      {
        routePath: "/api/test-upload",
        mountPath: "/api",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost27]
      },
      {
        routePath: "/api/test-user",
        mountPath: "/api",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost28]
      },
      {
        routePath: "/api/tickets",
        mountPath: "/api/tickets",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet58]
      },
      {
        routePath: "/api/tickets",
        mountPath: "/api/tickets",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions59]
      },
      {
        routePath: "/api/tickets",
        mountPath: "/api/tickets",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost29]
      },
      {
        routePath: "/health",
        mountPath: "/",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet59]
      }
    ];
  }
});

// ../.wrangler/tmp/bundle-vdH2kt/middleware-loader.entry.ts
init_functionsRoutes_0_8044054200943971();

// ../.wrangler/tmp/bundle-vdH2kt/middleware-insertion-facade.js
init_functionsRoutes_0_8044054200943971();

// ../node_modules/wrangler/templates/pages-template-worker.ts
init_functionsRoutes_0_8044054200943971();

// ../node_modules/wrangler/node_modules/path-to-regexp/dist.es2015/index.js
init_functionsRoutes_0_8044054200943971();
function lexer(str) {
  var tokens = [];
  var i = 0;
  while (i < str.length) {
    var char = str[i];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i, value: str[i++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i, value: str[i++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j = i + 1;
      while (j < str.length) {
        var code = str.charCodeAt(j);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str[j++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i));
      tokens.push({ type: "NAME", index: i, value: name });
      i = j;
      continue;
    }
    if (char === "(") {
      var count2 = 1;
      var pattern = "";
      var j = i + 1;
      if (str[j] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j));
      }
      while (j < str.length) {
        if (str[j] === "\\") {
          pattern += str[j++] + str[j++];
          continue;
        }
        if (str[j] === ")") {
          count2--;
          if (count2 === 0) {
            j++;
            break;
          }
        } else if (str[j] === "(") {
          count2++;
          if (str[j + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j));
          }
        }
        pattern += str[j++];
      }
      if (count2)
        throw new TypeError("Unbalanced pattern at ".concat(i));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i));
      tokens.push({ type: "PATTERN", index: i, value: pattern });
      i = j;
      continue;
    }
    tokens.push({ type: "CHAR", index: i, value: str[i++] });
  }
  tokens.push({ type: "END", index: i, value: "" });
  return tokens;
}
__name(lexer, "lexer");
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a, _b = options.delimiter, delimiter = _b === void 0 ? "/#?" : _b;
  var result = [];
  var key = 0;
  var i = 0;
  var path = "";
  var tryConsume = /* @__PURE__ */ __name(function(type) {
    if (i < tokens.length && tokens[i].type === type)
      return tokens[i++].value;
  }, "tryConsume");
  var mustConsume = /* @__PURE__ */ __name(function(type) {
    var value2 = tryConsume(type);
    if (value2 !== void 0)
      return value2;
    var _a2 = tokens[i], nextType = _a2.type, index = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
  }, "mustConsume");
  var consumeText = /* @__PURE__ */ __name(function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  }, "consumeText");
  var isSafe = /* @__PURE__ */ __name(function(value2) {
    for (var _i = 0, delimiter_1 = delimiter; _i < delimiter_1.length; _i++) {
      var char2 = delimiter_1[_i];
      if (value2.indexOf(char2) > -1)
        return true;
    }
    return false;
  }, "isSafe");
  var safePattern = /* @__PURE__ */ __name(function(prefix2) {
    var prev = result[result.length - 1];
    var prevText = prefix2 || (prev && typeof prev === "string" ? prev : "");
    if (prev && !prevText) {
      throw new TypeError('Must have text between two parameters, missing text after "'.concat(prev.name, '"'));
    }
    if (!prevText || isSafe(prevText))
      return "[^".concat(escapeString(delimiter), "]+?");
    return "(?:(?!".concat(escapeString(prevText), ")[^").concat(escapeString(delimiter), "])+?");
  }, "safePattern");
  while (i < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || safePattern(prefix),
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? safePattern(prefix) : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
__name(parse, "parse");
function match(str, options) {
  var keys = [];
  var re = pathToRegexp(str, keys, options);
  return regexpToFunction(re, keys, options);
}
__name(match, "match");
function regexpToFunction(re, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.decode, decode = _a === void 0 ? function(x) {
    return x;
  } : _a;
  return function(pathname) {
    var m = re.exec(pathname);
    if (!m)
      return false;
    var path = m[0], index = m.index;
    var params = /* @__PURE__ */ Object.create(null);
    var _loop_1 = /* @__PURE__ */ __name(function(i2) {
      if (m[i2] === void 0)
        return "continue";
      var key = keys[i2 - 1];
      if (key.modifier === "*" || key.modifier === "+") {
        params[key.name] = m[i2].split(key.prefix + key.suffix).map(function(value) {
          return decode(value, key);
        });
      } else {
        params[key.name] = decode(m[i2], key);
      }
    }, "_loop_1");
    for (var i = 1; i < m.length; i++) {
      _loop_1(i);
    }
    return { path, index, params };
  };
}
__name(regexpToFunction, "regexpToFunction");
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
__name(escapeString, "escapeString");
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
__name(flags, "flags");
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index = 0;
  var execResult = groupsRegex.exec(path.source);
  while (execResult) {
    keys.push({
      // Use parenthesized substring match if available, index otherwise
      name: execResult[1] || index++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path.source);
  }
  return path;
}
__name(regexpToRegexp, "regexpToRegexp");
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path) {
    return pathToRegexp(path, keys, options).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
__name(arrayToRegexp, "arrayToRegexp");
function stringToRegexp(path, keys, options) {
  return tokensToRegexp(parse(path, options), keys, options);
}
__name(stringToRegexp, "stringToRegexp");
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x) {
    return x;
  } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString(encode(token));
    } else {
      var prefix = escapeString(encode(token.prefix));
      var suffix = escapeString(encode(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            throw new TypeError('Can not repeat "'.concat(token.name, '" without a prefix and suffix'));
          }
          route += "(".concat(token.pattern, ")").concat(token.modifier);
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options));
}
__name(tokensToRegexp, "tokensToRegexp");
function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp)
    return regexpToRegexp(path, keys);
  if (Array.isArray(path))
    return arrayToRegexp(path, keys, options);
  return stringToRegexp(path, keys, options);
}
__name(pathToRegexp, "pathToRegexp");

// ../node_modules/wrangler/templates/pages-template-worker.ts
var escapeRegex = /[.+?^${}()|[\]\\]/g;
function* executeRequest(request) {
  const requestPath = new URL(request.url).pathname;
  for (const route of [...routes].reverse()) {
    if (route.method && route.method !== request.method) {
      continue;
    }
    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const matchResult = routeMatcher(requestPath);
    const mountMatchResult = mountMatcher(requestPath);
    if (matchResult && mountMatchResult) {
      for (const handler of route.middlewares.flat()) {
        yield {
          handler,
          params: matchResult.params,
          path: mountMatchResult.path
        };
      }
    }
  }
  for (const route of routes) {
    if (route.method && route.method !== request.method) {
      continue;
    }
    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\$&"), {
      end: true
    });
    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const matchResult = routeMatcher(requestPath);
    const mountMatchResult = mountMatcher(requestPath);
    if (matchResult && mountMatchResult && route.modules.length) {
      for (const handler of route.modules.flat()) {
        yield {
          handler,
          params: matchResult.params,
          path: matchResult.path
        };
      }
      break;
    }
  }
}
__name(executeRequest, "executeRequest");
var pages_template_worker_default = {
  async fetch(originalRequest, env, workerContext) {
    let request = originalRequest;
    const handlerIterator = executeRequest(request);
    let data = {};
    let isFailOpen = false;
    const next = /* @__PURE__ */ __name(async (input, init) => {
      if (input !== void 0) {
        let url = input;
        if (typeof input === "string") {
          url = new URL(input, request.url).toString();
        }
        request = new Request(url, init);
      }
      const result = handlerIterator.next();
      if (result.done === false) {
        const { handler, params, path } = result.value;
        const context = {
          request: new Request(request.clone()),
          functionPath: path,
          next,
          params,
          get data() {
            return data;
          },
          set data(value) {
            if (typeof value !== "object" || value === null) {
              throw new Error("context.data must be an object");
            }
            data = value;
          },
          env,
          waitUntil: workerContext.waitUntil.bind(workerContext),
          passThroughOnException: /* @__PURE__ */ __name(() => {
            isFailOpen = true;
          }, "passThroughOnException")
        };
        const response = await handler(context);
        if (!(response instanceof Response)) {
          throw new Error("Your Pages function should return a Response");
        }
        return cloneResponse(response);
      } else if ("ASSETS") {
        const response = await env["ASSETS"].fetch(request);
        return cloneResponse(response);
      } else {
        const response = await fetch(request);
        return cloneResponse(response);
      }
    }, "next");
    try {
      return await next();
    } catch (error) {
      if (isFailOpen) {
        const response = await env["ASSETS"].fetch(request);
        return cloneResponse(response);
      }
      throw error;
    }
  }
};
var cloneResponse = /* @__PURE__ */ __name((response) => (
  // https://fetch.spec.whatwg.org/#null-body-status
  new Response(
    [101, 204, 205, 304].includes(response.status) ? null : response.body,
    response
  )
), "cloneResponse");

// ../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_functionsRoutes_0_8044054200943971();
var drainBody = /* @__PURE__ */ __name(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// ../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_functionsRoutes_0_8044054200943971();
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e) {
    const error = reduceError(e);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// ../.wrangler/tmp/bundle-vdH2kt/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = pages_template_worker_default;

// ../node_modules/wrangler/templates/middleware/common.ts
init_functionsRoutes_0_8044054200943971();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// ../.wrangler/tmp/bundle-vdH2kt/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type, init) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request, env, ctx) => {
      this.env = env;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type, init) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
//# sourceMappingURL=functionsWorker-0.5073429534170399.mjs.map
